<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>🐏 suda-morris 个人博客 🐇</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Personal Blog">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="about-me.html">关于我</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">体系结构</li><li class="chapter-item expanded "><a href="cs/riscv.html"><strong aria-hidden="true">1.</strong> RISC-V</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">编译系统</li><li class="chapter-item expanded "><a href="cs/gcc-toolchains.html"><strong aria-hidden="true">2.</strong> GCC</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">操作系统</li><li class="chapter-item expanded "><a href="cs/openwrt.html"><strong aria-hidden="true">3.</strong> OpenWRT</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">控制系统</li><li class="chapter-item expanded "><a href="ee/control-system.html"><strong aria-hidden="true">4.</strong> 控制系统基础</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">测试框架</li><li class="chapter-item expanded "><a href="cs/pytest.html"><strong aria-hidden="true">5.</strong> pytest</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">多媒体</li><li class="chapter-item expanded "><a href="cs/video-process.html"><strong aria-hidden="true">6.</strong> 视频处理</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">通信协议</li><li class="chapter-item expanded "><a href="ee/usb.html"><strong aria-hidden="true">7.</strong> USB 协议基础</a></li><li class="chapter-item expanded "><a href="ee/can.html"><strong aria-hidden="true">8.</strong> CAN 协议基础</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">电路设计</li><li class="chapter-item expanded "><a href="ee/yosys.html"><strong aria-hidden="true">9.</strong> Yosys</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">管理</li><li class="chapter-item expanded "><a href="cs/git.html"><strong aria-hidden="true">10.</strong> git</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">演示</li><li class="chapter-item expanded "><a href="ux/slides-tool.html"><strong aria-hidden="true">11.</strong> slides 工具</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">🐏 suda-morris 个人博客 🐇</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/suda-morris/blog" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <center>
    <h1 id="茅胜荣"><a class="header" href="#茅胜荣">茅胜荣</a></h1>
    <div>
        <span>
            📞 18862141982
        </span>
        <span>
            📬 18862141982@163.com
        </span>
        <span>
            ✒️ <a href="https://suda-morris.github.io/blog">blog</a>
        </span>
        <span>
            📷 <a href="https://space.bilibili.com/9635864">vlog</a>
        </span>
    </div>
</center>
<h2 id="-个人信息"><a class="header" href="#-个人信息">🛈 个人信息</a></h2>
<ul>
<li>男，1992 年出生</li>
<li>求职意向：高级嵌入式软件工程师</li>
<li>工作经验：4 年</li>
<li>现居地：江苏省苏州市吴中区</li>
</ul>
<h2 id="-教育经历"><a class="header" href="#-教育经历">🎓️ 教育经历</a></h2>
<ul>
<li>硕士，苏州大学，电子科学与技术专业，2015.9~2018.7，GPA(3.9/4.0)</li>
<li>学士，苏州大学，电子信息工程专业，2011.9~2015.7，GPA(3.8/4.0)</li>
</ul>
<h2 id="-工作经历"><a class="header" href="#-工作经历">💼 工作经历</a></h2>
<ul>
<li>
<p><strong>乐鑫信息科技，芯片支持部门，嵌入式驱动工程师，2018.7 月至今</strong></p>
<ul>
<li>芯片 bring up</li>
<li>SOC 外设驱动框架</li>
</ul>
</li>
</ul>
<h2 id="-卓越贡献"><a class="header" href="#-卓越贡献">🚵 卓越贡献</a></h2>
<ul>
<li>
<p><strong>设计实现通用序列收发器驱动框架</strong></p>
<p><em>event-driven, OOP, IR, encoder</em></p>
<ul>
<li>工厂模式分配 RMT 通道，收发功能接口隔离</li>
<li>事务模型，每个事务独立的编码器驱动</li>
<li>组合设计模式，可自由组合原生编码器，为特定应用创建新的编码器</li>
<li>传输层抽象，支持 DMA 与非 DMA 传输，接口层统一</li>
<li>详见 <a href="https://github.com/espressif/esp-idf/tree/master/components/driver/rmt">GitHub 项目地址</a></li>
</ul>
</li>
<li>
<p><strong>设计实现嵌入式以太网驱动框架</strong></p>
<p><em>mediator pattern, OOP, Ethernet</em></p>
<ul>
<li>中介器设计模式，分隔用户、MAC 层和 PHY 层</li>
<li>多态设计，支持 ESP32 内部 MAC 控制器以及其他 SPI 接口的以太网模块</li>
<li>驱动分层设计，LL + HAL + driver，降低驱动在不同芯片平台上移植的难度</li>
<li>详见 <a href="https://github.com/espressif/esp-idf/tree/master/components/esp_eth">GitHub 项目地址</a></li>
</ul>
</li>
<li>
<p><strong>设计实现嵌入式LCD驱动框架</strong></p>
<p><em>RGB/YUV, I80, SPI, I2C, LvGL, OOP, LCD</em></p>
<ul>
<li>抽象出 panel_io 接口，统一 SPI/I2C/I80 对 LCD 模组发送命令与显存数据的操作</li>
<li>抽象出 panel 对象，统一应用层对显存设备的操作，支持 RGB 接口的 LCD 和 panel_io 抽象接口的 LCD 设备</li>
<li>IO 接口与显存操作分离，LCD 控制器驱动可复用程度最大化</li>
<li>适配 LvGL 库，对接异步接口</li>
<li>详见 <a href="https://github.com/espressif/esp-idf/tree/master/components/esp_lcd">GitHub 项目地址</a></li>
</ul>
</li>
<li>
<p><strong>BSP 软件包</strong></p>
<p><em>BSP, Interface Segregation Principle</em></p>
<ul>
<li>定义并实现可寻址灯带 <a href="https://components.espressif.com/component/espressif/led_strip">led-strip</a> 设备的操作接口</li>
<li>定义并实现直流有刷电机 <a href="https://components.espressif.com/component/espressif/bdc_motor">bdc-motor</a> 设备的操作接口</li>
</ul>
</li>
</ul>
<h2 id="-技能清单"><a class="header" href="#-技能清单">🛠 技能清单</a></h2>
<ul>
<li>★★★ C 语言面向对象建模与实现</li>
<li>★★☆ Python、Bash</li>
<li>★★☆ 计算机网络</li>
</ul>
<h2 id="-职业认证"><a class="header" href="#-职业认证">🏆️ 职业认证</a></h2>
<ul>
<li>职称: 江苏省<strong>中级</strong>专业技术资格</li>
<li>网络: CCNA(920分), 全国计算机等级4级(网络工程师)</li>
<li>语言: CET-6(511分)</li>
<li>编程: 江苏省计算机等级3级(软件)</li>
<li>竞赛: 全国大学生电子设计竞赛二等奖</li>
</ul>
<h2 id="-业余爱好"><a class="header" href="#-业余爱好">⛵️ 业余爱好</a></h2>
<ul>
<li>媒体: 用博客、视频记录工作与生活</li>
<li>创客: 接触最新最好玩的创客玩具(树莓派, OpenWRT, XMOS, PSoC)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="risc-v-基础"><a class="header" href="#risc-v-基础">RISC-V 基础</a></h1>
<h2 id="指令集划分"><a class="header" href="#指令集划分">指令集划分</a></h2>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>类别</th><th>说明</th></tr></thead><tbody>
<tr><td>RV32I</td><td>基础指令</td><td>整数指令，包含算术、分支、逻辑、访存指令，有32个32位寄存器，能寻址32位地址空间</td></tr>
<tr><td>RV32E</td><td>基础指令</td><td>与RV32I一样，只不过只能使用前16个32位寄存器</td></tr>
<tr><td>RV64I</td><td>基础指令</td><td>整数指令，包含算术、分支、逻辑、访存指令，有32个64位寄存器，能寻址64位地址空间</td></tr>
<tr><td>RV128I</td><td>基础指令</td><td>整数指令，包含算术、分支、逻辑、访存指令，有32个128位寄存器，能寻址128位地址空间</td></tr>
<tr><td>M</td><td>扩展指令</td><td>包含乘法、除法、求模取余指令</td></tr>
<tr><td>F</td><td>扩展指令</td><td>单精度(32bit)浮点指令</td></tr>
<tr><td>D</td><td>扩展指令</td><td>双精度(32bit)浮点指令,必须要同时支持F扩展指令</td></tr>
<tr><td>Q</td><td>扩展指令</td><td>四倍精度浮点指令</td></tr>
<tr><td>A</td><td>扩展指令</td><td>存储器原子操作指令，比如比较并交换，读-改-写等指令</td></tr>
<tr><td>C</td><td>扩展指令</td><td>压缩指令,指令长度为16位，主要用于改善程序大小</td></tr>
<tr><td>P</td><td>扩展指令</td><td>单指令多数据（Packed-SIMD)指令</td></tr>
<tr><td>B</td><td>扩展指令</td><td>位操作指令</td></tr>
<tr><td>H</td><td>扩展指令</td><td>支持 Hypervisor 管理指令</td></tr>
<tr><td>J</td><td>扩展指令</td><td>动态翻译语言的指令</td></tr>
<tr><td>L</td><td>扩展指令</td><td>十进制浮点指令</td></tr>
<tr><td>N</td><td>扩展指令</td><td>用户中断指令</td></tr>
<tr><td>G</td><td>通用指令</td><td>包含 I、M、A、F、D指令</td></tr>
</tbody></table>
</div>
<h3 id="rv32i-基础指令集"><a class="header" href="#rv32i-基础指令集">RV32I 基础指令集</a></h3>
<p><img src="cs/../images/risc-v/rv32i.png" alt="RV32I" /></p>
<h3 id="rv32i-通用寄存器"><a class="header" href="#rv32i-通用寄存器">RV32I 通用寄存器</a></h3>
<div class="table-wrapper"><table><thead><tr><th>寄存器</th><th>ABI 名字</th><th>描述</th><th>Saver</th></tr></thead><tbody>
<tr><td>x0</td><td>zero</td><td>0值寄存器，硬编码为0,写入数据忽略，读取永远为0</td><td>-</td></tr>
<tr><td>x1</td><td>ra</td><td>返回地址</td><td>Caller</td></tr>
<tr><td>x2</td><td>sp</td><td>栈指针</td><td>Callee</td></tr>
<tr><td>x3</td><td>gp</td><td>全局指针</td><td>-</td></tr>
<tr><td>x4</td><td>tp</td><td>线程指针</td><td>-</td></tr>
<tr><td>x5</td><td>t0</td><td>临时寄存器或者备用的链接寄存器</td><td>Caller</td></tr>
<tr><td>x6-x7</td><td>t1-t2</td><td>临时寄存器</td><td>Caller</td></tr>
<tr><td>x8</td><td>s0/fp</td><td>需要保存的寄存器或者帧指针寄存器</td><td>Callee</td></tr>
<tr><td>x9</td><td>s1</td><td>需要保存的寄存器，保存原进程中的关键数据，避免在函数调用过程中被破坏</td><td>Callee</td></tr>
<tr><td>x10-x11</td><td>a0-a1</td><td>函数参数/返回值</td><td>Caller</td></tr>
<tr><td>x12-x17</td><td>a2-a7</td><td>函数参数</td><td>Caller</td></tr>
<tr><td>x18-x27</td><td>s2-s11</td><td>需要保存的寄存器</td><td>Callee</td></tr>
<tr><td>x28-x31</td><td>t3-t6</td><td>临时寄存器</td><td>Caller</td></tr>
</tbody></table>
</div>
<h4 id="函数调用时保留的寄存器"><a class="header" href="#函数调用时保留的寄存器">函数调用时保留的寄存器</a></h4>
<p>被调用函数一般不会使用这些寄存器，即便使用也会提前保存好原值，可以信任。这些寄存器有：sp, gp, tp 和 s0-s11 寄存器。</p>
<h4 id="函数调用时不保存的寄存器"><a class="header" href="#函数调用时不保存的寄存器">函数调用时不保存的寄存器</a></h4>
<p>有可能被调用函数使用更改，需要caller在调用前对自己用到的寄存器进行保存。这些寄存器有：参数与返回地址寄存器 a0-a7，返回地址寄存器 ra，临时寄存器 t0-t6</p>
<h2 id="rv32i-基础指令格式"><a class="header" href="#rv32i-基础指令格式">RV32I 基础指令格式</a></h2>
<p><img src="cs/../images/risc-v/rv32i_instruction_format.webp" alt="RV32I 指令编码格式" /></p>
<ul>
<li>源寄存器和目标寄存器都设计固定在所有 RISC-V 指令同样的位置上，指令译码相对简单，所以指令在 CPU 流水线中执行时，可以先开始访问寄存器，然后再完成指令解码。</li>
<li>所有立即数的<strong>符号位</strong>总是在指令的<strong>最高位</strong>。这么做的好处是，有可能成为关键路径的<strong>立即数符号扩展</strong>可以在指令解码前进行，有利于 CPU 流水线的时序优化。</li>
</ul>
<h3 id="寄存器-寄存器的算术指令"><a class="header" href="#寄存器-寄存器的算术指令">寄存器-寄存器的算术指令</a></h3>
<p><img src="cs/../images/risc-v/rv32i_instruction_arithmetic_reg2reg.webp" alt="RV32I 寄存器-寄存器的算术指令" /></p>
<h4 id="指令汇编格式"><a class="header" href="#指令汇编格式">指令汇编格式</a></h4>
<h5 id="加法"><a class="header" href="#加法">加法</a></h5>
<pre><code class="language-assembly">add rd, rs1, rs2
</code></pre>
<h5 id="减法"><a class="header" href="#减法">减法</a></h5>
<pre><code class="language-assembly">sub rd, rs1, rs2
</code></pre>
<h5 id="逻辑与"><a class="header" href="#逻辑与">逻辑与</a></h5>
<pre><code class="language-assembly">and rd, rs1, rs2
</code></pre>
<h5 id="逻辑或"><a class="header" href="#逻辑或">逻辑或</a></h5>
<pre><code class="language-assembly">or rd, rs1, rs2
</code></pre>
<h5 id="逻辑异或"><a class="header" href="#逻辑异或">逻辑异或</a></h5>
<pre><code class="language-assembly">xor rd, rs1, rs2
</code></pre>
<h5 id="有符号小于比较"><a class="header" href="#有符号小于比较">有符号小于比较</a></h5>
<pre><code class="language-assembly">slt rd, rs1, rs2
</code></pre>
<h5 id="无符号小于比较"><a class="header" href="#无符号小于比较">无符号小于比较</a></h5>
<pre><code class="language-assembly">sltu rd, rs1, rs2
</code></pre>
<h5 id="逻辑左移"><a class="header" href="#逻辑左移">逻辑左移</a></h5>
<pre><code class="language-assembly">sll rd, rs1, rs2
</code></pre>
<h5 id="逻辑右移"><a class="header" href="#逻辑右移">逻辑右移</a></h5>
<pre><code class="language-assembly">srl rd, rs1, rs2
</code></pre>
<h5 id="算数右移"><a class="header" href="#算数右移">算数右移</a></h5>
<pre><code class="language-assembly">sra rd, rs1, rs2
</code></pre>
<h3 id="立即数的算术指令"><a class="header" href="#立即数的算术指令">立即数的算术指令</a></h3>
<p><img src="cs/../images/risc-v/rv32i_instruction_arithmetic_immediate.webp" alt="RV32I 立即数的算术指令" /></p>
<blockquote>
<p>注意，在立即数算术指令中，没有减法运算。</p>
</blockquote>
<h4 id="指令汇编格式-1"><a class="header" href="#指令汇编格式-1">指令汇编格式</a></h4>
<h5 id="立即数加法"><a class="header" href="#立即数加法">立即数加法</a></h5>
<pre><code class="language-assembly">addi rd, rs1, imm[11:0]
</code></pre>
<h5 id="立即数逻辑与"><a class="header" href="#立即数逻辑与">立即数逻辑与</a></h5>
<pre><code class="language-assembly">andi rd, rs1, imm[11:0]
</code></pre>
<h5 id="立即数逻辑或"><a class="header" href="#立即数逻辑或">立即数逻辑或</a></h5>
<pre><code class="language-assembly">ori rd, rs1, imm[11:0]
</code></pre>
<h5 id="立即数逻辑异或"><a class="header" href="#立即数逻辑异或">立即数逻辑异或</a></h5>
<pre><code class="language-assembly">xori rd, rs1, imm[11:0]
</code></pre>
<h5 id="立即数有符号小于比较"><a class="header" href="#立即数有符号小于比较">立即数有符号小于比较</a></h5>
<pre><code class="language-assembly">slti rd, rs1, imm[11:0]
</code></pre>
<h5 id="立即数无符号小于比较"><a class="header" href="#立即数无符号小于比较">立即数无符号小于比较</a></h5>
<pre><code class="language-assembly">sltiu rd, rs1, imm[11:0]
</code></pre>
<h5 id="立即数逻辑左移"><a class="header" href="#立即数逻辑左移">立即数逻辑左移</a></h5>
<pre><code class="language-assembly">slli rd, rs1, shamt[4:0]
</code></pre>
<h5 id="立即数逻辑右移"><a class="header" href="#立即数逻辑右移">立即数逻辑右移</a></h5>
<pre><code class="language-assembly">srli rd, rs1, shamt[4:0]
</code></pre>
<h5 id="立即数算数右移"><a class="header" href="#立即数算数右移">立即数算数右移</a></h5>
<pre><code class="language-assembly">srai rd, rs1, shamt[4:0]
</code></pre>
<h3 id="loadstore-指令"><a class="header" href="#loadstore-指令">Load/Store 指令</a></h3>
<p><img src="cs/../images/risc-v/rv32i_instruction_load_store.webp" alt="RV32I Load/Store 指令" /></p>
<p>Load 和 Store 的寻址模式只能是符号扩展 12 位的立即数，加上基地址寄存器得到访问的存储器地址。因为没有了复杂的内存寻址方式，这让 CPU 流水线可以对数据冲突提前做出判断，并通过流水线各级之间的转送加以处理，而不需要插入空操作（NOP），极大提高了代码的执行效率。</p>
<blockquote>
<p>注意，Load指令属于 <strong>I</strong> 型指令，而 Store 指令属于 <strong>S</strong> 型指令。</p>
</blockquote>
<h4 id="指令汇编格式-2"><a class="header" href="#指令汇编格式-2">指令汇编格式</a></h4>
<h5 id="字加载"><a class="header" href="#字加载">字加载</a></h5>
<pre><code class="language-assembly">lw rd, offset[11:0](rs1)
</code></pre>
<h5 id="半字加载"><a class="header" href="#半字加载">半字加载</a></h5>
<pre><code class="language-assembly">lh rd, offset[11:0](rs1)
</code></pre>
<h5 id="无符号半字加载"><a class="header" href="#无符号半字加载">无符号半字加载</a></h5>
<pre><code class="language-assembly">lhu rd, offset[11:0](rs1)
</code></pre>
<h5 id="字节加载"><a class="header" href="#字节加载">字节加载</a></h5>
<pre><code class="language-assembly">lb rd, offset[11:0](rs1)
</code></pre>
<h5 id="无符号字节加载"><a class="header" href="#无符号字节加载">无符号字节加载</a></h5>
<pre><code class="language-assembly">lbu rd, offset[11:0](rs1)
</code></pre>
<h5 id="字存储"><a class="header" href="#字存储">字存储</a></h5>
<pre><code class="language-assembly">sw rs2, offset[11:0](rs1)
</code></pre>
<h5 id="半字存储"><a class="header" href="#半字存储">半字存储</a></h5>
<pre><code class="language-assembly">sh rs2, offset[11:0](rs1)
</code></pre>
<h5 id="字节存储"><a class="header" href="#字节存储">字节存储</a></h5>
<pre><code class="language-assembly">sb rs2, offset[11:0](rs1)
</code></pre>
<h3 id="有条件分支跳转指令"><a class="header" href="#有条件分支跳转指令">有条件分支跳转指令</a></h3>
<p><img src="cs/../images/risc-v/rv32i_instruction_branch_condition.webp" alt="有条件分支跳转指令" /></p>
<h4 id="指令汇编格式-3"><a class="header" href="#指令汇编格式-3">指令汇编格式</a></h4>
<h5 id="相等跳转"><a class="header" href="#相等跳转">相等跳转</a></h5>
<pre><code class="language-assembly">beq rs1, rs2, label
</code></pre>
<h5 id="不等跳转"><a class="header" href="#不等跳转">不等跳转</a></h5>
<pre><code class="language-assembly">bne rs1, rs2, label
</code></pre>
<h5 id="小于跳转"><a class="header" href="#小于跳转">小于跳转</a></h5>
<pre><code class="language-assembly">blt rs1, rs2, label
</code></pre>
<h5 id="无符号小于跳转"><a class="header" href="#无符号小于跳转">无符号小于跳转</a></h5>
<pre><code class="language-assembly">bltu rs1, rs2, label
</code></pre>
<h5 id="大于等于跳转"><a class="header" href="#大于等于跳转">大于等于跳转</a></h5>
<pre><code class="language-assembly">bge rs1, rs2, label
</code></pre>
<h5 id="无符号大于等于跳转"><a class="header" href="#无符号大于等于跳转">无符号大于等于跳转</a></h5>
<pre><code class="language-assembly">bgeu rs1, rs2, label
</code></pre>
<h3 id="无条件跳转指令"><a class="header" href="#无条件跳转指令">无条件跳转指令</a></h3>
<blockquote>
<p>注意，直接跳转是 <strong>J</strong> 型指令，而相对跳转是 <strong>I</strong> 型指令。</p>
</blockquote>
<h4 id="直接跳转指令"><a class="header" href="#直接跳转指令">直接跳转指令</a></h4>
<p><img src="cs/../images/risc-v/rv32i_instruction_branch_direct.webp" alt="无条件直接跳转" /></p>
<p>JAL 指令的执行过程：</p>
<ol>
<li>首先，把 20 位的立即数做符号扩展，并左移一位，产生一个 32 位的符号数</li>
<li>然后，将该 32 位符号数和 PC 相加来产生目标地址（这样 JAL 可以作为短跳转指令，跳转至 PC±1MB 的地址范围内）</li>
<li>同时，JAL 会把紧随其后的那条指令的地址，存入目标寄存器中。这样，如果目标寄存器是0,则 JAL 就等同于 goto 指令；如果目标寄存器不为零，JAL 可以实现函数调用的功能</li>
</ol>
<h4 id="相对跳转指令"><a class="header" href="#相对跳转指令">相对跳转指令</a></h4>
<p><img src="cs/../images/risc-v/rv32i_instruction_branch_relative.webp" alt="无条件相对跳转" /></p>
<p>JALR 指令会把 12 位立即数和源寄存器相加，并把相加的结果末位清零，作为新的跳转地址。和 JAL 指令一样，JALR 也会把紧随其后的那条指令的地址，存入目标寄存器中。</p>
<h4 id="指令汇编格式-4"><a class="header" href="#指令汇编格式-4">指令汇编格式</a></h4>
<h5 id="无条件直接跳转"><a class="header" href="#无条件直接跳转">无条件直接跳转</a></h5>
<pre><code class="language-assembly">jal rd, label # 将 PC+4 的值保存到 rd 寄存器中，然后设置 PC = PC + offset
</code></pre>
<p>伪指令 <code>j</code> 实际上就是jal指令的变体，此时 rd 会被设置为 x0,表示丢弃返回地址</p>
<h5 id="无条件相对跳转"><a class="header" href="#无条件相对跳转">无条件相对跳转</a></h5>
<pre><code class="language-assembly">jalr rd, rs1, imm # 将 PC+4 保存到 rd 寄存器中，然后设置 PC = rs1  + imm
</code></pre>
<p>跳转到任意 32 位绝对地址处</p>
<pre><code class="language-assembly">lui x1, &lt;hi20bits&gt;
jalr ra, x1, &lt;lo12bits&gt;
</code></pre>
<p>相对PC地址32位偏移量的相对跳转</p>
<pre><code class="language-assembly">auipc x1, &lt;hi20bits&gt;
jalr x0, x1, &lt;lo12bits&gt;
</code></pre>
<h3 id="uupper-immediate型指令"><a class="header" href="#uupper-immediate型指令">U(Upper immediate)型指令</a></h3>
<p><img src="cs/../images/risc-v/riscv_U_instruction.png" alt="U型指令" /></p>
<h4 id="指令汇编格式-5"><a class="header" href="#指令汇编格式-5">指令汇编格式</a></h4>
<h5 id="lui-指令-load-upper-immediate"><a class="header" href="#lui-指令-load-upper-immediate">lui 指令 (Load Upper Immediate)</a></h5>
<pre><code class="language-assembly">lui rd, imm # 将 20 位的立即数左移12位，低 12 位补零，并写回寄存器 rd 中
</code></pre>
<p>配合 addi 指令（设置低 12 比特）可实现讲寄存器设置为任意 32 比特的立即数，例如：</p>
<pre><code class="language-assembly">lui x10, 0x87654     # x10 = 0x87654000
addi x10, x10, 0x321 # x10 = 0x87654321
</code></pre>
<p>但是，当这个 12 位的立即数为负数（即最高比特位是1）时，得到的结果是高 20 位减 1 再和低 12 位拼接，比如：</p>
<pre><code class="language-assembly">lui x10, 0xDEADB     # x10 = 0xDEADB000
addi x10, x10, 0xEEF # x10 = 0xDEADBEEF
</code></pre>
<p>解决这个问题的一种方法是，如果低 12 位的立即数的符号位是 1 ,那就预先给高 20 位的数加 1。<code>li</code> 伪指令可以替我们处理好这种特殊情况。</p>
<h5 id="auipc-指令-add-upper-immediate-to-pc"><a class="header" href="#auipc-指令-add-upper-immediate-to-pc">auipc 指令 (Add Upper Immediate to PC)</a></h5>
<pre><code class="language-assembly">auipc rd, imm # 将 20 位的立即数左移12位，低 12 位补零，将得到的 32 位数与 pc 的值相加，最后写回寄存器 rd 中
</code></pre>
<p>具体应用有：</p>
<pre><code class="language-assembly">Label: auipc x10, 0 # 将 Label 的地址保存在 x10 寄存器中
</code></pre>
<h3 id="指令编码空间的可扩展性"><a class="header" href="#指令编码空间的可扩展性">指令编码空间的可扩展性</a></h3>
<p><img src="cs/../images/risc-v/riscv_isa_custom_instruction.png" alt="指令编码空间的扩展" /></p>
<ul>
<li>custom-0、custom-1 用于 RV32 的自定义指令集扩展</li>
<li>custom-2、custom-3 预留给 RV128，也可以用于 RV32、RV64 的用户自定义指令集扩展</li>
</ul>
<h2 id="csr-寄存器指令"><a class="header" href="#csr-寄存器指令">CSR 寄存器指令</a></h2>
<p>除了内存地址空间和通用寄存器地址空间外，RISC-V 中还定义了一个独立的控制与状态寄存器（CSR）地址空间。</p>
<h3 id="独立的-12-位地址编码空间"><a class="header" href="#独立的-12-位地址编码空间">独立的 12 位地址编码空间</a></h3>
<p><img src="cs/../images/risc-v/csr_register_encoding.png" alt="CSR寄存器访问指令的编码" /></p>
<h3 id="专用的-csr-指令"><a class="header" href="#专用的-csr-指令">专用的 CSR 指令</a></h3>
<p><img src="cs/../images/risc-v/rv32i_csr_instruction.webp" alt="CSR 指令" /></p>
<h2 id="其他指令"><a class="header" href="#其他指令">其他指令</a></h2>
<ul>
<li>系统调用 <code>ecall</code> 指令</li>
<li>调试时用于将控制转移到调试环境的 <code>ebreak</code> 指令</li>
</ul>
<h3 id="常用汇编伪指令"><a class="header" href="#常用汇编伪指令">常用汇编伪指令</a></h3>
<h5 id="赋值指令"><a class="header" href="#赋值指令">赋值指令</a></h5>
<pre><code class="language-assembly">mv rd, rs # 等效于 addi rd, rs, x0
</code></pre>
<h5 id="加载立即数"><a class="header" href="#加载立即数">加载立即数</a></h5>
<pre><code class="language-assembly">li rd, 13 # 等效于 addi rd, x0, 13
</code></pre>
<h5 id="函数调用和返回"><a class="header" href="#函数调用和返回">函数调用和返回</a></h5>
<pre><code class="language-assembly">jal my_foo # 函数调用
ret # 函数返回，等效于 jr ra，等效于 jalr x0, ra, 0
</code></pre>
<h2 id="单核-cpu-组成结构"><a class="header" href="#单核-cpu-组成结构">单核 CPU 组成结构</a></h2>
<p><img src="cs/../images/risc-v/riscv_alu.png" alt="ALU" /></p>
<p><strong>数据通路</strong>是处理器中执行处理器所需操作的硬件部分，就像是处理器的四肢。</p>
<p><strong>控制器</strong>是对数据通路要做什么操作进行行为调度的硬件结构，就像是处理器的大脑。</p>
<h3 id="流水线技术"><a class="header" href="#流水线技术">流水线技术</a></h3>
<h4 id="五级流水线"><a class="header" href="#五级流水线">五级流水线</a></h4>
<p><img src="cs/../images/risc-v/rv32i_5stage_pipelines.jpeg" alt="五级流水线" /></p>
<h4 id="流水线在不同阶段使用的资源"><a class="header" href="#流水线在不同阶段使用的资源">流水线在不同阶段使用的资源</a></h4>
<p><img src="cs/../images/risc-v/riscv_pipeline_resource_usage.png" alt="流水线资源使用" /></p>
<blockquote>
<p>为了确保硬件共享的时候，前一阶段的数据不被丢失，需要在流水线之间插入“阶段寄存器”来保存中间值和控制信号。</p>
</blockquote>
<h3 id="数据通路"><a class="header" href="#数据通路">数据通路</a></h3>
<p><img src="cs/../images/risc-v/riscv_data_path.png" alt="数据通路" /></p>
<ol>
<li>取指阶段（Instruction Fetch）：将指令从存储器中读取出来，PC 寄存器告诉当前指令在存储器中的位置。读取一条指令后，PC 寄存器会根据指令的长度自动递增，或者改写成指定的地址。</li>
<li>译码阶段（Instruction Decode）：将存储器中取出的指令进行翻译，识别出指令的类别以及所需的各种操作数。</li>
<li>执行阶段（Instruction Execute）：对指令进行真正的运算，期间最关键的模块是算术逻辑单元（ALU）。</li>
<li>访存阶段（Memory Access）：存储器访问指令将数据从存储器中读出，或写入存储器。</li>
<li>写回阶段（Write Back）：将指令执行的结果写回通用寄存器。</li>
</ol>
<h3 id="简易-cpu-内部组件框图"><a class="header" href="#简易-cpu-内部组件框图">简易 CPU 内部组件框图</a></h3>
<p><img src="cs/../images/risc-v/rv32i_cpu_design.jpeg" alt="RV32I CPU 5级流水线设计框图" /></p>
<h3 id="pre_if-模块设计"><a class="header" href="#pre_if-模块设计">pre_if 模块设计</a></h3>
<p>根据当前的指令和 PC 寄存器，预测下一条指令的地址。为了实现程序分支跳转的功能，就需要设计一个<strong>预读取</strong>模块，不管指令是否跳转（这个结果会在指令执行阶段结束才能知道），都提前把跳转之后的下一条指令从存储器中读取出来，以备流水线的下一个阶段使用，这能提到 CPU 的执行效率。</p>
<pre><code class="language-verilog">module pre_if (
    input [31:0] instr,
    input [31:0] pc,

    output [31:0] pre_pc
);

    wire is_bxx = (instr[6:0] == `OPCODE_BRANCH); // 条件跳转指令的操作码
    wire is_jal = (instr[6:0] == `OPCODE_JAL) ;   // 无条件跳转指令的操作码

    // B型指令的立即数拼接
    wire [31:0] bimm  = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};
    // J型指令的立即数拼接
    wire [31:0] jimm  = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};

    // 指令地址的偏移量
    // 这里实际上做了一个简单的分支预测
    wire [31:0] adder = is_jal ? jimm : (is_bxx &amp; bimm[31]) ? bimm : 4;
    // 根据当前 PC 和指令的偏移量相加，得到预测的 PC 值
    assign pre_pc = pc + adder;

endmodule
</code></pre>
<h3 id="if_id-模块设计"><a class="header" href="#if_id-模块设计">if_id 模块设计</a></h3>
<p>预读取模块读出的指令并不是全部都能发送给后续的模块执行的，比如条件分支指令在执行后发现跳转条件不成立，这时预读取的指令就是无效的，需要对流水线进行冲刷（flush），把无效的指令都清除掉。</p>
<pre><code class="language-verilog">module if_id (
  input         clk,
  input         reset,
  input  [31:0] in_instr,
  input  [31:0] in_pc,
  input         flush,
  input         valid,
  output [31:0] out_instr,
  output [31:0] out_pc,
  output        out_noflush
);

  reg [31:0] reg_instr;
  reg [31:0] reg_pc;
  reg        reg_noflush;

  assign out_instr = reg_instr;
  assign out_pc = reg_pc;
  assign out_noflush = reg_noflush;

  //指令传递
  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_instr &lt;= 32'h0;
    end else if (flush) begin
      reg_instr &lt;= 32'h0;
    end else if (valid) begin
      reg_instr &lt;= in_instr;
    end
  end

  //PC值转递
  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_pc &lt;= 32'h0;
    end else if (flush) begin
      reg_pc &lt;= 32'h0;
    end else if (valid) begin
      reg_pc &lt;= in_pc;
    end
  end

  //流水线冲刷标志位
  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_noflush &lt;= 1'h0;
    end else if (flush) begin
      reg_noflush &lt;= 1'h0;
    end else if (valid) begin
      reg_noflush &lt;= 1'h1;
    end

  end

endmodule
</code></pre>
<h3 id="decode-模块设计"><a class="header" href="#decode-模块设计">decode 模块设计</a></h3>
<p>尽管指令格式不同，但是指令译码模块翻译指令的工作机制是<strong>统一</strong>的。首先会翻译出指令中携带的寄存器索引、立即数等信息，接着处理可能存在的数据冒险，再由译码数据通路负责把译码后的指令信息，发送给对应的执行单元去执行。</p>
<p>译码的过程：先识别指令的操作码（永远是低7位），根据操作码对应的代码标识，产生分支信号 branch、跳转信号 jump、读存储器信号 mem_read ......</p>
<pre><code class="language-verilog">module decode (
  input   [31:0] instr,

  output  [4:0] rs1_addr,
  output  [4:0] rs2_addr,
  output  [4:0] rd_addr,
  output  [2:0] funct3,
  output  [6:0] funct7,
  output        branch,
  output [1:0]  jump,
  output        mem_read,
  output        mem_write,
  output        reg_write,
  output        to_reg,
  output [1:0]  result_sel,
  output        alu_src,
  output        pc_add,
  output [6:0]  types,
  output [1:0]  alu_ctrlop,
  output        valid_inst,
  output [31:0] imm
);

localparam DEC_INVALID = 21'b0;

reg [20:0] dec_array;

//---------- decode rs1、rs2 -----------------
assign rs1_addr = instr[19:15];
assign rs2_addr = instr[24:20];

//---------- decode rd -----------------------
assign rd_addr = instr[11:7];

//---------- decode funct3、funct7 -----------
assign funct7 = instr[31:25];
assign funct3 = instr[14:12];

// ----------------------------- decode signals ---------------------------------

//                        20     19-18  17       16        15        14     13-12      11      10     9--------3  2---1      0
//                        branch jump   memRead  memWrite  regWrite  toReg  resultSel  aluSrc  pcAdd     RISBUJZ  aluctrlop  validInst
localparam DEC_LUI     = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b01,     1'b0,   1'b0,  7'b0000100, 2'b00,     1'b1};
localparam DEC_AUIPC   = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b1,   1'b1,  7'b0000100, 2'b00,     1'b1};
localparam DEC_JAL     = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b10,     1'b0,   1'b0,  7'b0000010, 2'b00,     1'b1};
localparam DEC_JALR    = {1'b0,  2'b11, 1'b0,    1'b0,     1'b1,     1'b0,  2'b10,     1'b1,   1'b0,  7'b0100000, 2'b00,     1'b1};
localparam DEC_BRANCH  = {1'b1,  2'b00, 1'b0,    1'b0,     1'b0,     1'b0,  2'b00,     1'b0,   1'b0,  7'b0001000, 2'b10,     1'b1};
localparam DEC_LOAD    = {1'b0,  2'b00, 1'b1,    1'b0,     1'b1,     1'b1,  2'b00,     1'b1,   1'b0,  7'b0100000, 2'b00,     1'b1};
localparam DEC_STORE   = {1'b0,  2'b00, 1'b0,    1'b1,     1'b0,     1'b0,  2'b00,     1'b1,   1'b0,  7'b0010000, 2'b00,     1'b1};
localparam DEC_ALUI    = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b1,   1'b0,  7'b0100000, 2'b01,     1'b1};
localparam DEC_ALUR    = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b0,   1'b0,  7'b1000000, 2'b01,     1'b1};

assign  {branch, jump, mem_read, mem_write, reg_write, to_reg, result_sel, alu_src, pc_add, types, alu_ctrlop, valid_inst} = dec_array;


always @(*) begin
  //$write(&quot;%x&quot;, instr);
  case(instr[6:0])
    `OPCODE_LUI    :   dec_array &lt;= DEC_LUI;
    `OPCODE_AUIPC  :   dec_array &lt;= DEC_AUIPC;
    `OPCODE_JAL    :   dec_array &lt;= DEC_JAL;
    `OPCODE_JALR   :   dec_array &lt;= DEC_JALR;
    `OPCODE_BRANCH :   dec_array &lt;= DEC_BRANCH;
    `OPCODE_LOAD   :   dec_array &lt;= DEC_LOAD;
    `OPCODE_STORE  :   dec_array &lt;= DEC_STORE;
    `OPCODE_ALUI   :   dec_array &lt;= DEC_ALUI;
    `OPCODE_ALUR   :   dec_array &lt;= DEC_ALUR;
    default        :  begin
                 dec_array &lt;= DEC_INVALID;
               //  $display(&quot;~~~decode error~~~%x&quot;, instr);
    end
  endcase
end

// -------------------- IMM -------------------------

wire [31:0] Iimm = {{21{instr[31]}}, instr[30:20]};
wire [31:0] Simm = {{21{instr[31]}}, instr[30:25], instr[11:7]};
wire [31:0] Bimm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};
wire [31:0] Uimm = {instr[31:12], 12'b0};
wire [31:0] Jimm = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};

assign imm = {32{types[5]}} &amp; Iimm
           | {32{types[4]}} &amp; Simm
           | {32{types[3]}} &amp; Bimm
           | {32{types[2]}} &amp; Uimm
           | {32{types[1]}} &amp; Jimm;

endmodule
</code></pre>
<p>前面译码模块得到的指令信号可以分为两大类，一类是指令的操作码经过译码后产生的<strong>指令控制信号</strong>，另一类是从指令源码中提取出来的<strong>数据信息</strong>，如立即数、寄存器索引、功能码等。为了能对流水线更好地实施控制，我们把译码后的数据和控制信号分开处理。</p>
<h3 id="译码控制模块"><a class="header" href="#译码控制模块">译码控制模块</a></h3>
<p>当指令发生冲突时，需要对流水线进行冲刷，译码阶段的指令信息也需要清除。</p>
<pre><code class="language-Verilog">module id_ex_ctrl (
  input        clk,
  input        reset,
  input        in_ex_ctrl_itype,
  input  [1:0] in_ex_ctrl_alu_ctrlop,
  input  [1:0] in_ex_ctrl_result_sel,
  input        in_ex_ctrl_alu_src,
  input        in_ex_ctrl_pc_add,
  input        in_ex_ctrl_branch,
  input  [1:0] in_ex_ctrl_jump,
  input        in_mem_ctrl_mem_read,
  input        in_mem_ctrl_mem_write,
  input  [1:0] in_mem_ctrl_mask_mode,
  input        in_mem_ctrl_sext,
  input        in_wb_ctrl_to_reg,
  input        in_wb_ctrl_reg_write,
  input        in_noflush,
  input        flush,
  input        valid,
  output       out_ex_ctrl_itype,
  output [1:0] out_ex_ctrl_alu_ctrlop,
  output [1:0] out_ex_ctrl_result_sel,
  output       out_ex_ctrl_alu_src,
  output       out_ex_ctrl_pc_add,
  output       out_ex_ctrl_branch,
  output [1:0] out_ex_ctrl_jump,
  output       out_mem_ctrl_mem_read,
  output       out_mem_ctrl_mem_write,
  output [1:0] out_mem_ctrl_mask_mode,
  output       out_mem_ctrl_sext,
  output       out_wb_ctrl_to_reg,
  output       out_wb_ctrl_reg_write,
  output       out_noflush
);

  reg  reg_ex_ctrl_itype;
  reg [1:0] reg_ex_ctrl_alu_ctrlop;
  reg [1:0] reg_ex_ctrl_result_sel;
  reg  reg_ex_ctrl_alu_src;
  reg  reg_ex_ctrl_pc_add;
  reg  reg_ex_ctrl_branch;
  reg [1:0] reg_ex_ctrl_jump;
  reg  reg_mem_ctrl_mem_read;
  reg  reg_mem_ctrl_mem_write;
  reg [1:0] reg_mem_ctrl_mask_mode;
  reg  reg_mem_ctrl_sext;
  reg  reg_wb_ctrl_to_reg;
  reg  reg_wb_ctrl_reg_write;
  reg  reg_noflush;

  assign out_ex_ctrl_itype = reg_ex_ctrl_itype;
  assign out_ex_ctrl_alu_ctrlop = reg_ex_ctrl_alu_ctrlop;
  assign out_ex_ctrl_result_sel = reg_ex_ctrl_result_sel;
  assign out_ex_ctrl_alu_src = reg_ex_ctrl_alu_src;
  assign out_ex_ctrl_pc_add = reg_ex_ctrl_pc_add;
  assign out_ex_ctrl_branch = reg_ex_ctrl_branch;
  assign out_ex_ctrl_jump = reg_ex_ctrl_jump;
  assign out_mem_ctrl_mem_read = reg_mem_ctrl_mem_read;
  assign out_mem_ctrl_mem_write = reg_mem_ctrl_mem_write;
  assign out_mem_ctrl_mask_mode = reg_mem_ctrl_mask_mode;
  assign out_mem_ctrl_sext = reg_mem_ctrl_sext;
  assign out_wb_ctrl_to_reg = reg_wb_ctrl_to_reg;
  assign out_wb_ctrl_reg_write = reg_wb_ctrl_reg_write;
  assign out_noflush = reg_noflush;

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_ex_ctrl_itype &lt;= 1'h0;
    end else if (flush) begin
      reg_ex_ctrl_itype &lt;= 1'h0;
    end else if (valid) begin
      reg_ex_ctrl_itype &lt;= in_ex_ctrl_itype;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_ex_ctrl_alu_ctrlop &lt;= 2'h0;
    end else if (flush) begin
      reg_ex_ctrl_alu_ctrlop &lt;= 2'h0;
    end else if (valid) begin
      reg_ex_ctrl_alu_ctrlop &lt;= in_ex_ctrl_alu_ctrlop;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_ex_ctrl_result_sel &lt;= 2'h0;
    end else if (flush) begin
      reg_ex_ctrl_result_sel &lt;= 2'h0;
    end else if (valid) begin
      reg_ex_ctrl_result_sel &lt;= in_ex_ctrl_result_sel;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_ex_ctrl_alu_src &lt;= 1'h0;
    end else if (flush) begin
      reg_ex_ctrl_alu_src &lt;= 1'h0;
    end else if (valid) begin
      reg_ex_ctrl_alu_src &lt;= in_ex_ctrl_alu_src;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_ex_ctrl_pc_add &lt;= 1'h0;
    end else if (flush) begin
      reg_ex_ctrl_pc_add &lt;= 1'h0;
    end else if (valid) begin
      reg_ex_ctrl_pc_add &lt;= in_ex_ctrl_pc_add;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_ex_ctrl_branch &lt;= 1'h0;
    end else if (flush) begin
      reg_ex_ctrl_branch &lt;= 1'h0;
    end else if (valid) begin
      reg_ex_ctrl_branch &lt;= in_ex_ctrl_branch;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_ex_ctrl_jump &lt;= 2'h0;
    end else if (flush) begin
      reg_ex_ctrl_jump &lt;= 2'h0;
    end else if (valid) begin
      reg_ex_ctrl_jump &lt;= in_ex_ctrl_jump;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_mem_ctrl_mem_read &lt;= 1'h0;
    end else if (flush) begin
      reg_mem_ctrl_mem_read &lt;= 1'h0;
    end else if (valid) begin
      reg_mem_ctrl_mem_read &lt;= in_mem_ctrl_mem_read;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_mem_ctrl_mem_write &lt;= 1'h0;
    end else if (flush) begin
      reg_mem_ctrl_mem_write &lt;= 1'h0;
    end else if (valid) begin
      reg_mem_ctrl_mem_write &lt;= in_mem_ctrl_mem_write;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_mem_ctrl_mask_mode &lt;= 2'h0;
    end else if (flush) begin
      reg_mem_ctrl_mask_mode &lt;= 2'h0;
    end else if (valid) begin
      reg_mem_ctrl_mask_mode &lt;= in_mem_ctrl_mask_mode;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_mem_ctrl_sext &lt;= 1'h0;
    end else if (flush) begin
      reg_mem_ctrl_sext &lt;= 1'h0;
    end else if (valid) begin
      reg_mem_ctrl_sext &lt;= in_mem_ctrl_sext;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_wb_ctrl_to_reg &lt;= 1'h0;
    end else if (flush) begin
      reg_wb_ctrl_to_reg &lt;= 1'h0;
    end else if (valid) begin
      reg_wb_ctrl_to_reg &lt;= in_wb_ctrl_to_reg;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_wb_ctrl_reg_write &lt;= 1'h0;
    end else if (flush) begin
      reg_wb_ctrl_reg_write &lt;= 1'h0;
    end else if (valid) begin
      reg_wb_ctrl_reg_write &lt;= in_wb_ctrl_reg_write;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_noflush &lt;= 1'h0;
    end else if (flush) begin
      reg_noflush &lt;= 1'h0;
    end else if (valid) begin
      reg_noflush &lt;= in_noflush;
    end
  end


endmodule
</code></pre>
<h3 id="译码数据通路模块"><a class="header" href="#译码数据通路模块">译码数据通路模块</a></h3>
<p>译码数据通路会根据 CPU 相关控制模块产生的流水线冲刷控制信号，决定要不要把这些数据发送给后续模块。</p>
<pre><code class="language-Verilog">module id_ex (
  input         clk,
  input         reset,
  input  [4:0]  in_rd_addr,
  input  [6:0]  in_funct7,
  input  [2:0]  in_funct3,
  input  [31:0] in_imm,
  input  [31:0] in_rs2_data,
  input  [31:0] in_rs1_data,
  input  [31:0] in_pc,
  input  [4:0]  in_rs1_addr,
  input  [4:0]  in_rs2_addr,
  input         flush,
  input         valid,
  output [4:0]  out_rd_addr,
  output [6:0]  out_funct7,
  output [2:0]  out_funct3,
  output [31:0] out_imm,
  output [31:0] out_rs2_data,
  output [31:0] out_rs1_data,
  output [31:0] out_pc,
  output [4:0]  out_rs1_addr,
  output [4:0]  out_rs2_addr
);
  reg [4:0] reg_rd_addr;
  reg [6:0] reg_funct7;
  reg [2:0] reg_funct3;
  reg [31:0] reg_imm;
  reg [31:0] reg_rs2_data;
  reg [31:0] reg_rs1_data;
  reg [31:0] reg_pc;
  reg [4:0] reg_rs1_addr;
  reg [4:0] reg_rs2_addr;

  assign out_rd_addr = reg_rd_addr;
  assign out_funct7 = reg_funct7;
  assign out_funct3 = reg_funct3;
  assign out_imm = reg_imm;
  assign out_rs2_data = reg_rs2_data;
  assign out_rs1_data = reg_rs1_data;
  assign out_pc = reg_pc;
  assign out_rs1_addr = reg_rs1_addr;
  assign out_rs2_addr = reg_rs2_addr;

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_rd_addr &lt;= 5'h0;
    end else if (flush) begin
      reg_rd_addr &lt;= 5'h0;
    end else if (valid) begin
      reg_rd_addr &lt;= in_rd_addr;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_funct7 &lt;= 7'h0;
    end else if (flush) begin
      reg_funct7 &lt;= 7'h0;
    end else if (valid) begin
      reg_funct7 &lt;= in_funct7;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_funct3 &lt;= 3'h0;
    end else if (flush) begin
      reg_funct3 &lt;= 3'h0;
    end else if (valid) begin
      reg_funct3 &lt;= in_funct3;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_imm &lt;= 32'h0;
    end else if (flush) begin
      reg_imm &lt;= 32'h0;
    end else if (valid) begin
      reg_imm &lt;= in_imm;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_rs2_data &lt;= 32'h0;
    end else if (flush) begin
      reg_rs2_data &lt;= 32'h0;
    end else if (valid) begin
      reg_rs2_data &lt;= in_rs2_data;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_rs1_data &lt;= 32'h0;
    end else if (flush) begin
      reg_rs1_data &lt;= 32'h0;
    end else if (valid) begin
      reg_rs1_data &lt;= in_rs1_data;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_pc &lt;= 32'h0;
    end else if (flush) begin
      reg_pc &lt;= 32'h0;
    end else if (valid) begin
      reg_pc &lt;= in_pc;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_rs1_addr &lt;= 5'h0;
    end else if (flush) begin
      reg_rs1_addr &lt;= 5'h0;
    end else if (valid) begin
      reg_rs1_addr &lt;= in_rs1_addr;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_rs2_addr &lt;= 5'h0;
    end else if (flush) begin
      reg_rs2_addr &lt;= 5'h0;
    end else if (valid) begin
      reg_rs2_addr &lt;= in_rs2_addr;
    end
  end

endmodule
</code></pre>
<h3 id="执行控制模块"><a class="header" href="#执行控制模块">执行控制模块</a></h3>
<p>在指令执行阶段，存储访问指令用 ALU 进行地址计算，条件分支跳转指令用 ALU 进行条件比较，算术逻辑指令用 ALU 进行逻辑运算。</p>
<pre><code class="language-Verilog">module alu_ctrl (
    input [2:0]  funct3,
    input [6:0]  funct7,
    input [1:0]  aluCtrlOp,
    input        itype,
    output reg [3:0] aluOp
);
    always @(*) begin
      case(aluCtrlOp)
        2'b00:  aluOp &lt;= `ALU_OP_ADD;           // Load or Store
        2'b01:  begin
          if(itype &amp; funct3[1:0] != 2'b01)
            aluOp &lt;= {1'b0, funct3};
          else
            aluOp &lt;= {funct7[5], funct3};   // normal ALUI/ALUR
        end
        2'b10:  begin
         // $display(&quot;~~~aluCtrl bxx~~~%d&quot;, funct3);
          case(funct3)                    // bxx
            `BEQ_FUNCT3:  aluOp &lt;= `ALU_OP_EQ;
            `BNE_FUNCT3:  aluOp &lt;= `ALU_OP_NEQ;
            `BLT_FUNCT3:  aluOp &lt;= `ALU_OP_SLT;
            `BGE_FUNCT3:  aluOp &lt;= `ALU_OP_GE;
            `BLTU_FUNCT3: aluOp &lt;= `ALU_OP_SLTU;
            `BGEU_FUNCT3: aluOp &lt;= `ALU_OP_GEU;
            default:      aluOp &lt;= `ALU_OP_XXX;
          endcase
          end
        default: aluOp &lt;= `ALU_OP_XXX;
      endcase
    end
endmodule
</code></pre>
<h3 id="通用寄存器模块"><a class="header" href="#通用寄存器模块">通用寄存器模块</a></h3>
<pre><code class="language-Verilog">module gen_regs (
    input  clk,
    input  reset,
    input  wen,
    input  [4:0] regRAddr1, regRAddr2, regWAddr,
    input  [31:0] regWData,
    output [31:0] regRData1,
    output [31:0] regRData2
);
    integer ii;
    reg [31:0] regs[31:0];

    // write registers
    always @(posedge clk or posedge reset) begin
        if(reset) begin
            for(ii=0; ii&lt;32; ii=ii+1)
                regs[ii] &lt;= 32'b0;
        end
        else if(wen &amp; (|regWAddr))
                regs[regWAddr] &lt;= regWData;
    end

    // read registers
    assign regRData1 = wen &amp; (regWAddr == regRAddr1) ? regWData
                    : ((regRAddr1 != 5'b0) ? regs[regRAddr1] : 32'b0);
    assign regRData2 = wen &amp; (regWAddr == regRAddr2) ? regWData
                    : ((regRAddr2 != 5'b0) ? regs[regRAddr2] : 32'b0);

endmodule
</code></pre>
<p>写寄存器是边沿触发的，在一个时钟周期内写入的存储器数据，需要在写一个时钟周期才能把写入的数据读取出来。为了提高读写效率，在对同一个寄存器进行读写时，如果写使能 wen 有效，就直接把写入寄存器的数据送给读数据接口。</p>
<h3 id="alu-模块"><a class="header" href="#alu-模块">ALU 模块</a></h3>
<pre><code class="language-Verilog">module alu (
  input  [31:0] alu_data1_i,
  input  [31:0] alu_data2_i,
  input  [ 3:0] alu_op_i,
  output [31:0] alu_result_o
);

  reg  [31:0] result;

  // alu_op_i 的第3位和第1位为1时，做减法运算，这是为减法指令或者比较大小而准备的
  wire [31:0] sum    = alu_data1_i + ((alu_op_i[3] | alu_op_i[1]) ? -alu_data2_i : alu_data2_i);
  // 根据前面两个操作数相减的结果判断两个操作数是否相等
  wire        neq    = |sum;
  // 比较两个操作数的大小：
  // 如果操作数的符号位相同，则根据两个操作数相减的差值的符号位去判断
  // 如果操作数的符号位不同，先根据alu_op_i 的最低位判断是否是无符号数比较运算
  wire        cmp    = (alu_data1_i[31] == alu_data2_i[31]) ? sum[31]
                     : alu_op_i[0] ? alu_data2_i[31] : alu_data1_i[31];
  wire [ 4:0] shamt  = alu_data2_i[4:0];
  // 判断是左移还是右移，如果是左移，就先对源操作数做镜像处理
  wire [31:0] shin   = alu_op_i[2] ? alu_data1_i : reverse(alu_data1_i);
  // 判断是算术右移还是逻辑右移，如果是算术右移，需要在最高位补一个符号位
  wire [32:0] shift  = {alu_op_i[3] &amp; shin[31], shin};
  // $signed() 函数会在右移操作前先把操作数的符号位扩位成跟结果相同的位宽
  wire [32:0] shiftt = ($signed(shift) &gt;&gt;&gt; shamt);
  wire [31:0] shiftr = shiftt[31:0];
  // 左移的结果是右移后的结果再进行镜像处理
  wire [31:0] shiftl = reverse(shiftr);

  always @(*) begin
    case(alu_op_i)
      `ALU_OP_ADD:    result &lt;= sum;
      `ALU_OP_SUB:    result &lt;= sum;
      `ALU_OP_SLL:    result &lt;= shiftl;
      `ALU_OP_SLT:    result &lt;= cmp;
      `ALU_OP_SLTU:   result &lt;= cmp;
      `ALU_OP_XOR:    result &lt;= (alu_data1_i ^ alu_data2_i);
      `ALU_OP_SRL:    result &lt;= shiftr;
      `ALU_OP_SRA:    result &lt;= shiftr;
      `ALU_OP_OR:     result &lt;= (alu_data1_i | alu_data2_i);
      `ALU_OP_AND:    result &lt;= (alu_data1_i &amp; alu_data2_i);

      `ALU_OP_EQ:     result &lt;= {31'b0, ~neq};
      `ALU_OP_NEQ:    result &lt;= {31'b0, neq};
      `ALU_OP_GE:     result &lt;= {31'b0, ~cmp};
      `ALU_OP_GEU:    result &lt;= {31'b0, ~cmp};
      default:        begin
                      result &lt;= 32'b0;
                      //$display(&quot;*** alu error ! ***%x&quot;, alu_op_i);
        end
    endcase
  end

  function [31:0] reverse;
    input [31:0] in;
    integer i;
    for(i=0; i&lt;32; i=i+1) begin
      reverse[i] = in[31-i];
    end
  endfunction

  assign alu_result_o = result;

endmodule
</code></pre>
<ul>
<li>左移运算复用了右移运算的电路，方便实现</li>
</ul>
<h3 id="完整的数据通路"><a class="header" href="#完整的数据通路">完整的数据通路</a></h3>
<p><img src="cs/../images/risc-v/riscv_full_data_path.png" alt="完整的数据通路" /></p>
<ul>
<li>译码阶段，会将指令的功能码和操作码发送给<strong>控制器</strong>，来产生相应的控制信号</li>
<li>立即数扩展信号：ImmSel</li>
<li>ALU 功能选择信号：ALUSel</li>
</ul>
<h3 id="控制器的设计"><a class="header" href="#控制器的设计">控制器的设计</a></h3>
<p><img src="cs/../images/risc-v/riscv_cpu_controller_truth_table.png" alt="控制器的设计" /></p>
<h3 id="r-型指令数据通路"><a class="header" href="#r-型指令数据通路">R 型指令数据通路</a></h3>
<p><img src="cs/../images/risc-v/riscv_R_instruction_data_path.png" alt="R型指令数据通路" /></p>
<ul>
<li><code>ALUSel</code> 会根据指令的 <code>funct3</code>来取不同的值</li>
</ul>
<h3 id="i-型指令数据通路"><a class="header" href="#i-型指令数据通路">I 型指令数据通路</a></h3>
<p><img src="cs/../images/risc-v/riscv_I_instruction_data_path.png" alt="I型指令数据通路" /></p>
<h3 id="load-指令数据通路"><a class="header" href="#load-指令数据通路">Load 指令数据通路</a></h3>
<p><img src="cs/../images/risc-v/riscv_load_instruction_data_path.png" alt="Load指令数据通路" /></p>
<h3 id="store-指令数据通路"><a class="header" href="#store-指令数据通路">Store 指令数据通路</a></h3>
<p><img src="cs/../images/risc-v/riscv_store_instruction_data_path.png" alt="Store指令数据通路" /></p>
<ul>
<li>立即数来自<code>inst[31:25][11:7]</code>，这个和Load不同</li>
<li>Store指令没有<strong>写回</strong>阶段</li>
</ul>
<h3 id="b-型指令数据通路"><a class="header" href="#b-型指令数据通路">B 型指令数据通路</a></h3>
<p><img src="cs/../images/risc-v/riscv_B_instruction_data_path.png" alt="B指令数据通路" /></p>
<ul>
<li>无<strong>访存</strong>和<strong>写回</strong>阶段</li>
</ul>
<h3 id="jalr-指令数据通路"><a class="header" href="#jalr-指令数据通路">jalr 指令数据通路</a></h3>
<p><img src="cs/../images/risc-v/riscv_jalr_instruction_data_path.png" alt="jalr指令数据通路" /></p>
<ul>
<li>PC+4 的值会保存到<code>rd</code> 中</li>
</ul>
<h3 id="jal-指令数据通路"><a class="header" href="#jal-指令数据通路">jal 指令数据通路</a></h3>
<p><img src="cs/../images/risc-v/riscv_jal_instruction_data_path.png" alt="jal指令数据通路" /></p>
<h2 id="cache"><a class="header" href="#cache">Cache</a></h2>
<p><img src="cs/../images/risc-v/riscv_cache.png" alt="Cache" /></p>
<h3 id="cache-的结构"><a class="header" href="#cache-的结构">Cache 的结构</a></h3>
<p><img src="cs/../images/risc-v/riscv_cache_structure.png" alt="Cache的结构" /></p>
<ul>
<li>块（block）：两级存储器层次结构中存储器信息交换的最小单元</li>
<li>命中（hit）：如果处理器需要的数据存放在高层存储器中的某个块中，称为一次命中</li>
<li>缺失（miss）：如果在高层存储器中没有找到所需的数据，这次数据请求称为一次缺失
<ul>
<li>缺失代价（miss penalty）：将相应的块从底层存储器替换到高层存储器的时间+将该信息块传送给处理器的时间</li>
</ul>
</li>
</ul>
<h3 id="cache-直接映射"><a class="header" href="#cache-直接映射">Cache 直接映射</a></h3>
<p>直接映射：一种 cache 结构，其中每个存储器地址仅仅对应到 cache 中的一个位置</p>
<p>映射方法：（块地址）mod（cache 中的块数）</p>
<p>标记：表中的一个字段，包含了地址信息，这些地址信息可以用来判断cache中的字是否就是所请求的字</p>
<p>有效位：表中的一个字段，用来标识一个块是否包含有一个有效数据</p>
<p><img src="cs/../images/risc-v/riscv_cache_direct_mapping.png" alt="Cache直接映射" /></p>
<p><img src="cs/../images/risc-v/riscv_cache_direct_mapping_example.png" alt="Cache直接映射示例" /></p>
<p>缺点：利用率低，命中率低</p>
<h3 id="cache-全相联映射"><a class="header" href="#cache-全相联映射">Cache 全相联映射</a></h3>
<p>全相联映射：一个块可以被放置在 cache 中的任何位置</p>
<p><img src="cs/../images/risc-v/riscv_cache_full_association_mapping.png" alt="Cache全相联映射" /></p>
<p><img src="cs/../images/risc-v/riscv_cache_full_association_mapping_example.png" alt="Cache全相联映射示例" /></p>
<p>缺点：硬件开销大（有多少cache块就配有相等数量的比较器）</p>
<h3 id="cache-组相联映射"><a class="header" href="#cache-组相联映射">Cache 组相联映射</a></h3>
<p>在组相联映射中，每个块可被放置的位置数是固定的，每个块有 n 个位置可放的 cache 被称为 n 路组相联 Cache</p>
<p><img src="cs/../images/risc-v/riscv_set_associative_cache.png" alt="Cache组相联映射" /></p>
<p><img src="cs/../images/risc-v/riscv_set_associative_cache_example.png" alt="Cache组相联映射示例" /></p>
<p>四路组相联 Cache：</p>
<ul>
<li>4 个比较器</li>
<li>1 个四选一多路选择器</li>
</ul>
<h3 id="cache-的设计"><a class="header" href="#cache-的设计">Cache 的设计</a></h3>
<ul>
<li>要考虑的维度
<ul>
<li>Cache 的容量</li>
<li>块大小</li>
<li>组织方式（Direct，Fully Associative，Set Associative）</li>
<li>替换算法（FIFO，LRU）</li>
<li>写策略（write-through, write-back）</li>
</ul>
</li>
</ul>
<h2 id="虚拟地址"><a class="header" href="#虚拟地址">虚拟地址</a></h2>
<p><img src="cs/../images/risc-v/riscv_mmu.png" alt="虚拟存储器管理" /></p>
<h3 id="分段管理"><a class="header" href="#分段管理">分段管理</a></h3>
<p><img src="cs/../images/risc-v/riscv_mmu_segment_manage.png" alt="分段管理" /></p>
<p>分段管理：将一个程序按照逻辑单元分成多个程序段，每一个段使用自己单独的虚拟地址空间。</p>
<ul>
<li>逻辑上相互独立</li>
<li>容易实现共享和保护</li>
<li>非常容易产生碎片（段长是不确定的）</li>
</ul>
<h3 id="分页管理"><a class="header" href="#分页管理">分页管理</a></h3>
<p><img src="cs/../images/risc-v/riscv_mmu_page_manage.png" alt="分页管理" /></p>
<ul>
<li>如果页表项为4字节，那么整张页表会占据4MB大小的内存空间</li>
</ul>
<h3 id="两级分页管理"><a class="header" href="#两级分页管理">两级分页管理</a></h3>
<p><img src="cs/../images/risc-v/riscv_mmu_two_level_page_manage.png" alt="两级分页管理" /></p>
<ul>
<li>4KB的页目录+4KB的页表</li>
</ul>
<h3 id="快速地址转换-tlb"><a class="header" href="#快速地址转换-tlb">快速地址转换 TLB</a></h3>
<p><img src="cs/../images/risc-v/riscv_tlb.png" alt="块表" /></p>
<p>块表（Translation-Lookaside Buffer）：用于记录最近使用地址的映射信息的高速缓存，从而可以避免每次都要访问页表</p>
<h3 id="使用-tlb-进行地址转换"><a class="header" href="#使用-tlb-进行地址转换">使用 TLB 进行地址转换</a></h3>
<p><img src="cs/../images/risc-v/riscv_tlb_location.png" alt="TLB的位置" /></p>
<p><img src="cs/../images/risc-v/riscv_tlb_translation.png" alt="TLB实现地址转换的原理" /></p>
<p><img src="cs/../images/risc-v/riscv_vma_pma_translation.png" alt="TLB虚实地址转换" /></p>
<h2 id="特权级别"><a class="header" href="#特权级别">特权级别</a></h2>
<p>一个 RISC-V 的硬件线程在任一时刻只能运行在某一个特权级上，这个特权级由 CSR 指定和配置。</p>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>级别</th><th>缩写</th><th>编码</th><th>说明</th></tr></thead><tbody>
<tr><td>用户应用程序特权级</td><td>0</td><td>U</td><td>00</td><td>运行应用程序，同样也适用于嵌入式系统</td></tr>
<tr><td>管理员特权级</td><td>1</td><td>S</td><td>01</td><td>主要用于支持现代操作系统，如Linux</td></tr>
<tr><td>虚拟机监视特权级</td><td>2</td><td>H</td><td>10</td><td>支持虚拟机监视器</td></tr>
<tr><td>机器特权级</td><td>3</td><td>M</td><td>11</td><td>对内存、I/O和一些必要的底层功能（启动和系统配置）有着完全的控制权</td></tr>
</tbody></table>
</div>
<h3 id="标准寄存器列表"><a class="header" href="#标准寄存器列表">标准寄存器列表</a></h3>
<h4 id="machine-mode"><a class="header" href="#machine-mode">Machine Mode</a></h4>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>地址</th><th>属性</th><th>备注</th></tr></thead><tbody>
<tr><td>mvendorid</td><td>0xF11</td><td>RO</td><td>商业供应商编号寄存器</td></tr>
<tr><td>marchid</td><td>0xF12</td><td>RO</td><td>架构编号寄存器</td></tr>
<tr><td>mimpid</td><td>0xF13</td><td>RO</td><td>硬件实现编号寄存器</td></tr>
<tr><td>mhartid</td><td>0xF14</td><td>RO</td><td>Hart编号寄存器 (Hart: Hardware Thread)</td></tr>
<tr><td>mstatus</td><td>0x300</td><td>RW</td><td>异常处理状态寄存器</td></tr>
<tr><td>misa</td><td>0x301</td><td>RO</td><td>指令集架构寄存器</td></tr>
<tr><td>mie</td><td>0x304</td><td>RW</td><td>局部中断屏蔽控制寄存器</td></tr>
<tr><td>mtvec</td><td>0x305</td><td>RW</td><td>异常入口基地址寄存器</td></tr>
<tr><td>mtvt</td><td>0x307</td><td>RW</td><td>中断向量表的基地址，至少为 <strong>64byte</strong> 对齐</td></tr>
<tr><td>mscratch</td><td>0x340</td><td>RW</td><td>暂存寄存器，比如进入异常处理模式后，将应用程序的用户的 sp 寄存器临时保存到这个寄存器中</td></tr>
<tr><td>mepc</td><td>0x341</td><td>RW</td><td>异常PC寄存器</td></tr>
<tr><td>mcause</td><td>0x342</td><td>RW</td><td>异常原因寄存器</td></tr>
<tr><td>mtval</td><td>0x343</td><td>RW</td><td>异常值寄存器，保存进入异常之前出错指令的编码值或者存储器访问的地址值</td></tr>
<tr><td>mip</td><td>0x344</td><td>RW</td><td>中断等待寄存器</td></tr>
<tr><td>mnxti</td><td>0x345</td><td>RW</td><td>读操作返回值是下一个中断的handler地址，写回操作会更新中断使能的状态</td></tr>
<tr><td>mintstatus</td><td>0x346</td><td>RO</td><td>用于保存当前中断 Level</td></tr>
<tr><td>mscratchcsw</td><td>0x348</td><td>RW</td><td>用于在特权模式变化时交换mscratch与目的寄存器的值</td></tr>
<tr><td>mscratchcswl</td><td>0x349</td><td>RW</td><td>用于在中断Level变化时交换mscratch与目的寄存器的值</td></tr>
<tr><td>mcycle</td><td>0xB00</td><td>RW</td><td>周期计数器的低32位</td></tr>
<tr><td>mcycleh</td><td>0xB80</td><td>RW</td><td>周期计数器的高32位</td></tr>
<tr><td>minstret</td><td>0xB02</td><td>RW</td><td>完成指令计数器的低32位，该寄存器用于衡量处理器的性能</td></tr>
<tr><td>minstrech</td><td>0xB82</td><td>RW</td><td>完成指令计数器的高32位</td></tr>
</tbody></table>
</div>
<h4 id="user-mode"><a class="header" href="#user-mode">User Mode</a></h4>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>地址</th><th>属性</th><th>备注</th></tr></thead><tbody>
<tr><td>cycle</td><td>0xC00</td><td>RO</td><td>mcycle寄存器的只读副本</td></tr>
<tr><td>time</td><td>0xC01</td><td>RO</td><td>mtime寄存器的只读副本</td></tr>
<tr><td>instret</td><td>0xC02</td><td>RO</td><td>minstret寄存器的只读副本</td></tr>
<tr><td>cycleh</td><td>0xC80</td><td>RO</td><td>mcycleh寄存器的只读副本</td></tr>
<tr><td>timeh</td><td>0xC81</td><td>RO</td><td>mtimeh寄存器的只读副本</td></tr>
<tr><td>instreth</td><td>0xC82</td><td>RO</td><td>minstreth寄存器的只读副本</td></tr>
</tbody></table>
</div>
<h2 id="risc-v-的中断"><a class="header" href="#risc-v-的中断">RISC-V 的中断</a></h2>
<p><img src="cs/../images/risc-v/riscv_interrupt_enter.png" alt="进入中断" /></p>
<p><img src="cs/../images/risc-v/riscv_interrupt_exit.png" alt="退出中断" /></p>
<h3 id="中断和异常相关的寄存器"><a class="header" href="#中断和异常相关的寄存器">中断和异常相关的寄存器</a></h3>
<p><img src="cs/../images/risc-v/riscv_exception_csr_registers.png" alt="异常相关的CSR寄存器" /></p>
<p><img src="cs/../images/risc-v/riscv_exception_csr_register_definitions.png" alt="异常相关的CSR寄存器具体定义" /></p>
<h3 id="mstatus"><a class="header" href="#mstatus">mstatus</a></h3>
<ul>
<li>MIE：为1表示中断的全局开关打开，中断能够被正常响应</li>
<li>FS：维护浮点单元的状态。上电默认为0,表示Off，为了能够正常使用浮点单元，软件需要使用 CSR 写指令将 FS 的值改写为非 0 值以打开浮点单元的功能。操作系统在进行上下文切换的时候，需要通过该值来判断是否需要对浮点单元进行上下文的保存</li>
<li>XS：维护用户自定义的扩展指令单元状态，类似与 FS</li>
</ul>
<h3 id="mtvec"><a class="header" href="#mtvec">mtvec</a></h3>
<p><img src="cs/../images/risc-v/riscv_exception_mtvec_register.png" alt="mtvec寄存器" /></p>
<h3 id="异常代码"><a class="header" href="#异常代码">异常代码</a></h3>
<p><img src="cs/../images/risc-v/riscv_machine_exception_codes.png" alt="异常代码" /></p>
<h3 id="中断返回"><a class="header" href="#中断返回">中断返回</a></h3>
<p><img src="cs/../images/risc-v/riscv_exception_return.png" alt="中断返回" /></p>
<h3 id="中断屏蔽与中断等待"><a class="header" href="#中断屏蔽与中断等待">中断屏蔽与中断等待</a></h3>
<p><img src="cs/../images/risc-v/riscv_interrupt_enable_pending.png" alt="中断屏蔽和等待相关额寄存器" /></p>
<h3 id="中断优先级"><a class="header" href="#中断优先级">中断优先级</a></h3>
<p><img src="cs/../images/risc-v/riscv_interrupt_priority.png" alt="中断优先级" /></p>
<h3 id="单指令数据通路的中断响应与退出"><a class="header" href="#单指令数据通路的中断响应与退出">单指令数据通路的中断响应与退出</a></h3>
<p><img src="cs/../images/risc-v/riscv_one_cycle_intruction_interrupt_enter.png" alt="中断响应" /></p>
<p><img src="cs/../images/risc-v/riscv_one_cycle_intruction_interrupt_exit.png" alt="中断退出" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gcc-工具链基础"><a class="header" href="#gcc-工具链基础">GCC 工具链基础</a></h1>
<p>GCC 实质上不是一个单独的程序，而是多个程序的集合，因此通常称为 GCC 工具链。工具链软件包括 GCC、C 运行库、Binutils 和 GDB 等等。</p>
<ul>
<li>GCC（GNU C Compiler）是编译工具，可以将 C/C++ 语言编写的程序转换成为处理器能够执行的二进制代码。</li>
<li>GDB（GNU Project Debugger）是调试工具，可以用于对程序进行调试。</li>
</ul>
<h2 id="binutils"><a class="header" href="#binutils">Binutils</a></h2>
<p>这是一组二进制程序的处理工具，包括：<code>addr2line</code>、<code>ar</code>、<code>objcopy</code>、<code>objdump</code>、<code>as</code>、<code>ld</code>、<code>ldd</code>、<code>readelf</code>、<code>size</code>等。</p>
<ul>
<li>addr2line：用来将程序地址转换成其所对应的程序源文件及所对应的代码行，也可以得到所对应的函数。该工具将帮助调试器在调试的过程中定位对应的源代码位置。</li>
<li>as：主要用于汇编。</li>
<li>ld：主要用于链接。</li>
<li>ar：主要用于创建<strong>静态库</strong>。
<ul>
<li>如果要将多个 <code>.o</code> 目标文件生成一个库文件，则存在两种类型的库，一种是静态库，另一种是动态库。</li>
<li>在 Windows 中静态库是以 <code>.lib</code> 为后缀的文件，共享库是以 <code>.dll</code> 为后缀的文件。在 Linux 中静态库是以 <code>.a</code> 为后缀的文件，共享库是以 <code>.so</code> 为后缀的文件。</li>
<li>静态库和动态库的不同点在于代码被载入的时刻不同。静态库的代码在编译过程中已经被载入可执行程序，因此体积较大。共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。在 Linux 系统中，可以用 <code>ldd</code> 命令查看一个可执行程序依赖的共享库。</li>
<li>如果一个系统中存在多个需要同时运行的程序且这些程序之间存在共享库，那么采用动态库的形式将更节省内存。但是对于嵌入式系统，大多数情况下都是整个软件就是一个可执行程序且不支持动态加载的方式，即以静态库为主。</li>
</ul>
</li>
<li>ldd：可以用于查看一个可执行程序依赖的<strong>共享库</strong>。</li>
<li>objcopy：将一种对象文件翻译成另一种格式，比如将<code>.bin</code> 转换成 <code>.elf</code>、或者将 <code>.elf</code> 转换成 <code>.bin</code> 等。</li>
<li>objdump：主要的作用是反汇编。</li>
<li>readelf：显示有关 <code>ELF</code> 文件的信息。</li>
<li>size：列出可执行文件每个部分的尺寸和总尺寸，代码段、数据段、总大小等。</li>
</ul>
<h2 id="c-运行库"><a class="header" href="#c-运行库">C 运行库</a></h2>
<p>C语言标准主要由两部分组成：一部分描述 C 的语法，另一部分描述 C 标准库。C 标准库定义了一组标准头文件，每个头文件中包含一些相关的函数、变量、类型声明和宏定义，比如常见的 printf 函数便是一个 C 标准库函数，其原型定义在 stdio 头文件中。</p>
<p>:::tip</p>
<p>C 语言标准仅仅定义了 C 标准库函数原型，并没有提供实现。因此，C 编译器需要一个 C 运行时库(C Run Time  Libray,CRT)的支持。</p>
<p>:::</p>
<p>glibc (GNU C Library) 是 Linux 下的 C 标准库的实现：</p>
<ul>
<li>
<p>glibc 本身是 GNU 旗下的 C 标准库，后来逐渐成为了 Linux 的标准 C 库。glibc 的主体分布在 Linux 系统的 /lib 与 /usr/lib 目录中，包括 libc 标准 C 函数库、libm 数学函式库等，都以 <code>.so</code> 结尾。</p>
<p>:::warning</p>
<p>Linux 系统下的标准 C 库不只有 glibc，还存在 uclibc、klibc、musl 等等，但是 glibc 使用最为广泛。</p>
<p>嵌入式系统中使用较多的 C 运行库是 <code>newlib</code>。</p>
<p>:::</p>
</li>
<li>
<p>Linux 系统通常将 libc 库作为操作系统的一部分，它被视为操作系统与用户程序的接口。比如：glibc 不仅实现标准 C 语言中的函数，还封装了操作系统提供的系统调用。</p>
<ul>
<li>通常情况，每个特定的系统调用对应了至少一个 glibc 封装的库函数，比如系统调用 <code>sys_open</code> 对应的是glibc 中的 <code>open</code> 函数；其次，glibc 一个单独的 API 可能会调用多个系统调用，比如 <code>printf</code>  函数会调用如  <code>sys_open</code>、<code>sys_mmap</code>、<code>sys_write</code>、<code>sys_close</code> 等系统调用；另外，多个 glibc  API 也可能对应同一个系统调用，如 glibc 下实现的 <code>malloc</code>、<code>free</code> 等函数用来分配和释放内存，都是基于内核的<code>sys_brk</code> 的系统调用。</li>
</ul>
</li>
<li>
<p>对于 C++ 语言，常用的 C++ 标准库为 <code>libstdc++</code>。通常 <code>libstdc++</code> 与 GCC 捆绑在一起的，即安装 gcc 的时候会把 libstdc++ 装上。而 glibc 并没有和 GCC 捆绑于一起，这是因为 glibc 需要与操作系统内核打交道，因此其与具体的操作系统平台紧密耦合。而 libstdc++ 虽然提供了 c++ 程序的标准库，但其并不与内核打交道。对于系统级别的事件，libstdc++ 会与 glibc 交互，从而和内核通信。</p>
</li>
</ul>
<h2 id="编译过程"><a class="header" href="#编译过程">编译过程</a></h2>
<h3 id="准备-hello-world-程序"><a class="header" href="#准备-hello-world-程序">准备 Hello World 程序</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main(void)
{
  printf(&quot;Hello World! \n&quot;);
  return 0;
}
</code></pre>
<h3 id="预处理"><a class="header" href="#预处理">预处理</a></h3>
<p>预处理的过程主要包括以下过程：</p>
<ul>
<li>将所有的 <code>#define</code> 删除，并且展开所有的宏定义，并且处理所有的条件预编译指令，比如 <code>#if</code> <code>#ifdef</code> <code>#elif</code> <code>#else</code> <code>#endif</code> 等。</li>
<li>处理 <code>#include</code> 预编译指令，将被包含的文件插入到该预编译指令的位置。</li>
<li>删除所有注释 <code>//</code> 和 <code>/**/</code>。</li>
<li>添加行号和文件标识，以便编译时产生调试用的行号及编译错误警告行号。</li>
<li>保留所有的 <code>#pragma</code> 编译器指令，后续编译过程需要使用它们。</li>
</ul>
<p>使用 gcc 进行预处理的命令如下：</p>
<pre><code class="language-bash">gcc -E hello.c -o hello.i 	# 将源文件 hello.c 文件预处理生成 hello.i
</code></pre>
<p>hello.i 文件可以作为普通文本文件打开进行查看，其代码片段如下所示：</p>
<pre><code class="language-c">extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 942 &quot;/usr/include/stdio.h&quot; 3 4

# 2 &quot;hello.c&quot; 2


# 3 &quot;hello.c&quot;
int
main(void)
{
  printf(&quot;Hello World!&quot; &quot;\n&quot;);
  return 0;
}
</code></pre>
<h3 id="编译"><a class="header" href="#编译">编译</a></h3>
<p>编译过程就是对预处理完的文件进行一系列的词法分析，语法分析，语义分析及优化后生成相应的汇编代码。</p>
<p>使用 gcc 进行编译的命令如下：</p>
<pre><code class="language-bash">gcc -S hello.i -o hello.s 	# 将预处理生成的 hello.i 文件编译生成汇编程序 hello.s
</code></pre>
<p>上述命令生成的汇编程序 hello.s 的代码片段如下所示，其全部为汇编代码。</p>
<pre><code class="language-assembly">main:
.LFB0:
    .cfi_startproc
    pushq   %rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq    %rsp, %rbp
    .cfi_def_cfa_register 6
    movl    $.LC0, %edi
    call    puts
    movl    $0, %eax
    popq    %rbp
    .cfi_def_cfa 7, 8
    ret
    .cfi_endproc
</code></pre>
<h3 id="汇编"><a class="header" href="#汇编">汇编</a></h3>
<p>汇编过程调用对汇编代码进行处理，生成处理器能识别的指令，保存在后缀为 <code>.o</code> 的目标文件中。由于每一个汇编语句几乎都对应一条处理器指令，因此，汇编相对于编译过程比较简单，通过调用 <code>Binutils</code> 中的汇编器 <code>as</code> 根据汇编指令和处理器指令的对照表一一翻译即可。</p>
<p>当程序由多个源代码文件构成时，每个文件都要先完成汇编工作，生成 <code>.o</code> 目标文件后，才能进入下一步的链接工作。注意：目标文件已经是最终程序的某一部分了，但是在链接之前还不能运行。</p>
<p>使用 gcc 进行汇编的命令如下：</p>
<pre><code class="language-bash">gcc -c hello.s -o hello.o 	# 将编译生成的 hello.s 文件汇编生成目标文件 hello.o
# 或者直接调用 as 进行汇编
as -c hello.s -o hello.o 	# 使用 Binutils 中的 as 将 hello.s 文件汇编生成目标文件
</code></pre>
<p>:::warning</p>
<p>hello.o 目标文件为 <code>ELF(Executable and Linkable Format)</code> 格式的可重定向文件。</p>
<p>:::</p>
<h3 id="链接"><a class="header" href="#链接">链接</a></h3>
<p>经过汇编以后的目标文件还不能直接运行，为了变成能够被加载的可执行文件，文件中必须包含固定格式的信息头，还必须与系统提供的启动代码链接起来才能正常运行，这些工作都是由链接器来完成的。</p>
<p>GCC 可以通过调用 Binutils 中的链接器 <code>ld</code> 来链接程序运行需要的所有目标文件，以及所依赖的其它库文件，最后生成一个 <code>ELF</code> 格式可执行文件。</p>
<p>如果直接调用 <code>Binutils</code> 中的<code>ld</code> 进行链接，命令如下，则会报出错误：</p>
<pre><code class="language-bash"># 直接调用ld试图将hello.o文件链接成为最终的可执行文件hello
ld hello.o –o hello
ld: warning: cannot find entry symbol _start; defaulting to 00000000004000b0
hello.o: In function `main':
hello.c:(.text+0xa): undefined reference to `puts'
</code></pre>
<p>之所以直接用 <code>ld</code> 进行链接会报错是因为仅仅依靠一个 <code>hello.o</code> 目标文件还无法链接成为一个完整的可执行文件，需要明确的指明其需要的各种依赖库和引导程序以及链接脚本，此过程在嵌入式软件开发时是必不可少的。而在 <code>Linux</code> 系统中，可以直接使用 <code>gcc</code> 命令执行编译直至链接的过程，gcc 会自动将所需的依赖库以及引导程序链接在一起成为 Linux 系统可以加载的 <code>ELF</code> 格式可执行文件。使用 gcc 进行编译直至链接的命令如下：</p>
<pre><code class="language-bash">gcc hello.c -o hello  	# 将 hello.c 文件编译汇编链接生成可执行文件 hello
./hello                 # 成功执行该文件，在终端上会打印 Hello World！字符串 Hello World!
</code></pre>
<p>注意：hello 可执行文件为 ELF（Executable and Linkable Format）格式的可执行文件。</p>
<p>链接分为静态链接和动态链接：</p>
<ul>
<li>
<p>静态链接是指在编译阶段直接把静态库加入到可执行文件中去，这样可执行文件会比较大。链接器将函数的代码从其所在地（不同的目标文件或静态链接库中）拷贝到最终的可执行程序中。为创建可执行文件，链接器必须要完成的主要任务是：符号解析（把目标文件中符号的定义和引用联系起来）和重定位（把符号定义和内存地址对应起来然后修改所有对符号的引用）。</p>
</li>
<li>
<p>而动态链接则是指链接阶段仅仅只加入一些描述信息，而程序执行时再从系统中把相应动态库加载到内存中去。</p>
<ul>
<li>在 Linux 系统中，gcc 编译链接时的动态库搜索路径的顺序通常为：首先从 gcc 命令的参数 <code>-L</code> 指定的路径寻找；再从环境变量 <code>LIBRARY_PATH</code> 指定的路径寻址；再从默认路径 <code>/lib</code>、<code>/usr/lib</code>、<code>/usr/local/lib</code> 中寻找。</li>
<li>在 Linux 系统中，执行二进制文件时的动态库搜索路径的顺序通常为：首先搜索编译目标代码时指定的动态库搜索路径；再从环境变量 <code>LD_LIBRARY_PATH</code> 指定的路径寻址；再从配置文件 <code>/etc/ld.so.conf</code> 中指定的动态库搜索路径；再从默认路径 <code>/lib</code>、<code>/usr/lib</code> 中寻找。</li>
<li>在 Linux 系统中，可以用 <code>ldd</code> 命令查看一个可执行程序依赖的共享库。</li>
</ul>
</li>
<li>
<p>由于链接动态库和静态库的路径可能有重合，所以如果在路径中有同名的静态库文件和动态库文件，比如libtest.a 和 libtest.so，gcc 链接时默认优先选择动态库，会链接 libtest.so，如果要让 gcc 选择链接 libtest.a则可以指定 gcc 选项 <code>-static</code>，该选项会强制使用静态库进行链接。</p>
<ul>
<li>
<p>如果使用命令 <code>gcc hello.c -o hello</code> 则会使用动态库进行链接，生成的 ELF 可执行文件的大小（使用Binutils 的 <code>size</code> 命令查看）和链接的动态库（使用 Binutils 的 <code>ldd</code> 命令查看）如下所示：</p>
<pre><code class="language-bash">$ gcc hello.c -o hello
$ size hello  	# 使用size查看大小
   text    data     bss     dec     hex     filename
   1183     552       8    1743     6cf     hello
$ ldd hello 	# 可以看出该可执行文件链接了很多其他动态库，主要是 Linux 的 glibc 动态库
        linux-vdso.so.1 =&gt;  (0x00007fffefd7c000)
        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fadcdd82000)
        /lib64/ld-linux-x86-64.so.2 (0x00007fadce14c000)
</code></pre>
</li>
<li>
<p>如果使用命令 <code>gcc -static hello.c -o hello</code> 则会使用静态库进行链接，生成的 ELF 可执行文件的大小和链接的动态库如下所示：</p>
<pre><code class="language-bash">$ gcc -static hello.c -o hello
$ size hello 	# 使用size查看大小
     text    data     bss     dec     hex   filename
 823726    7284    6360  837370   cc6fa     hello 	# 可以看出 text 段的代码尺寸变大
$ ldd hello
       not a dynamic executable 	# 说明没有链接动态库
</code></pre>
</li>
</ul>
</li>
</ul>
<p>链接器链接后生成的最终文件为 ELF 格式可执行文件，一个 ELF 可执行文件通常被链接为不同的段，常见的段有 <code>.text</code>、<code>.data</code>、<code>.rodata</code>、<code>.bss</code> 等。</p>
<h3 id="一步到位的编译"><a class="header" href="#一步到位的编译">一步到位的编译</a></h3>
<p>从功能上分，预处理、编译、汇编、链接是四个不同的阶段，但 GCC 的实际操作上，它可以把这四个步骤合并为一个步骤来执行。如下例所示：</p>
<pre><code class="language-bash">gcc –o test first.c second.c third.c
# 该命令将同时编译三个源文件，即 first.c、second.c 和 third.c，然后将它们链接成一个可执行文件
</code></pre>
<p>注意：</p>
<ul>
<li>一个程序无论有一个源文件还是多个源文件，所有被编译和链接的源文件中必须有且仅有一个 <code>main</code> 函数。</li>
<li>但如果仅仅是把源文件编译成目标文件，因为不会进行链接，所以 <code>main</code> 函数不是必需的。</li>
</ul>
<h2 id="分析-elf-文件"><a class="header" href="#分析-elf-文件">分析 ELF 文件</a></h2>
<h3 id="elf-文件介绍"><a class="header" href="#elf-文件介绍">ELF 文件介绍</a></h3>
<p>在介绍ELF文件之前，首先将其与另一种常见的二进制文件格式bin进行对比：</p>
<ul>
<li>binary文件，其中只有机器码。</li>
<li>elf文件除了含有机器码之外还有其它信息，如：段加载地址，运行入口地址，数据段等。</li>
</ul>
<p>ELF全称Executable and Linkable Format，可执行链接格式。ELF文件格式主要三种：</p>
<ul>
<li>可重定向（Relocatable）文件：
<ul>
<li>文件保存着代码和适当的数据，用来和其他的目标文件一起来创建一个可执行文件或者是一个共享目标文件。</li>
</ul>
</li>
<li>可执行（Executable）文件：
<ul>
<li>文件保存着一个用来执行的程序（例如bash，gcc等）。</li>
</ul>
</li>
<li>共享（Shared）目标文件（Linux下后缀为.so的文件）：
<ul>
<li>即所谓共享库。</li>
</ul>
</li>
</ul>
<h3 id="elf文件的段"><a class="header" href="#elf文件的段">ELF文件的段</a></h3>
<p>ELF文件格式如图1中所示，位于ELF Header和Section Header Table之间的都是段（Section）。一个典型的ELF文件包含下面几个段：</p>
<ul>
<li>.text：已编译程序的指令代码段。</li>
<li>.rodata：ro代表read only，即只读数据（譬如常数const）。</li>
<li>.data：已初始化的C程序全局变量和静态局部变量。
<ul>
<li>注意：C程序普通局部变量在运行时被保存在堆栈中，既不出现在.data段中，也不出现在.bss段中。此外，如果变量被初始化值为0，也可能会放到bss段。</li>
</ul>
</li>
<li>.bss：未初始化的C程序全局变量和静态局部变量。
<ul>
<li>注意：目标文件格式区分初始化和未初始化变量是为了空间效率，在ELF文件中.bss段不占据实际的存储器空间，它仅仅是一个占位符。</li>
</ul>
</li>
<li>.debug：调试符号表，调试器用此段的信息帮助调试。</li>
<li>上述仅讲解了最常见的节，ELF文件还包含很多其他类型的节，本文在此不做赘述，请感兴趣的读者自行查阅其他资料了解学习。</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/11/02/ihFmes.png" alt="ELF文件格式" /></p>
<h3 id="查看elf文件"><a class="header" href="#查看elf文件">查看ELF文件</a></h3>
<p>可以使用Binutils中readelf来查看ELF文件的信息，可以通过readelf --help来查看readelf的选项：</p>
<pre><code class="language-bash">$ readelf --help
Usage: readelf &lt;option(s)&gt; elf-file(s)
 Display information about the contents of ELF format files
 Options are:
  -a --all               Equivalent to: -h -l -S -s -r -d -V -A -I
  -h --file-header       Display the ELF file header
  -l --program-headers   Display the program headers
     --segments          An alias for --program-headers
  -S --section-headers   Display the sections' header
</code></pre>
<p>以本文Hello World示例，使用readelf -S查看其各个section的信息如下：</p>
<pre><code class="language-bash">$ readelf -S hello
There are 31 section headers, starting at offset 0x19d8:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
……
  [11] .init             PROGBITS         00000000004003c8  000003c8
       000000000000001a  0000000000000000  AX       0     0     4
……
  [14] .text             PROGBITS         0000000000400430  00000430
       0000000000000182  0000000000000000  AX       0     0     16
  [15] .fini             PROGBITS         00000000004005b4  000005b4
……
</code></pre>
<h3 id="反汇编"><a class="header" href="#反汇编">反汇编</a></h3>
<p>由于ELF文件无法被当做普通文本文件打开，如果希望直接查看一个ELF文件包含的指令和数据，需要使用反汇编的方法。反汇编是用于调试和定位处理器问题时最常用的手段。 可以使用Binutils中objdump来对ELF文件进行反汇编，可以通过objdump --help来查看其选项：</p>
<pre><code class="language-bash">$ objdump --help
Usage: objdump &lt;option(s)&gt; &lt;file(s)&gt;
 Display information from object &lt;file(s)&gt;.
 At least one of the following switches must be given:
……
  -D, --disassemble-all    Display assembler contents of all sections
  -S, --source             Intermix source code with disassembly
……
</code></pre>
<p>以本文Hello World示例，使用objdump -D对其进行反汇编如下：</p>
<pre><code class="language-bash">$ objdump -D hello
……
0000000000400526 &lt;main&gt;:  # main标签的PC地址
# PC地址：    指令编码                 指令的汇编格式
  400526:    55                      push   %rbp
  400527:    48 89 e5                mov    %rsp,%rbp
  40052a:    bf c4 05 40 00          mov    $0x4005c4,%edi
  40052f:    e8 cc fe ff ff          callq  400400 &lt;puts@plt&gt;
  400534:    b8 00 00 00 00          mov    $0x0,%eax
  400539:    5d                      pop    %rbp
  40053a:    c3                      retq
  40053b:    0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
……
</code></pre>
<p>使用objdump -S将其反汇编并且将其C语言源代码混合显示出来：</p>
<pre><code class="language-bash">$ gcc -o hello -g hello.c # 要加上-g选项
$ objdump -S hello
……
0000000000400526 &lt;main&gt;:
#include &lt;stdio.h&gt;

int
main(void)
{
  400526:    55                      push   %rbp
  400527:    48 89 e5                mov    %rsp,%rbp
  printf(&quot;Hello World!&quot; &quot;\n&quot;);
  40052a:    bf c4 05 40 00          mov    $0x4005c4,%edi
  40052f:    e8 cc fe ff ff          callq  400400 &lt;puts@plt&gt;
  return 0;
  400534:    b8 00 00 00 00          mov    $0x0,%eax
}
  400539:    5d                      pop    %rbp
  40053a:    c3                      retq
  40053b:    0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
……
</code></pre>
<h2 id="嵌入式系统编译的特殊性"><a class="header" href="#嵌入式系统编译的特殊性">嵌入式系统编译的特殊性</a></h2>
<p>为了易于读者理解，本文以一个Hello World程序为例讲解了在Linux环境中的编译过程以帮助初学者入门，但是了解这些基础背景知识对于嵌入式开发还远远不够。
对于嵌入式开发，嵌入式系统的编译过程和开发有其特殊性，譬如：</p>
<ul>
<li>嵌入式系统需要使用交叉编译与远程调试的方法进行开发。</li>
<li>需要自己定义引导程序。</li>
<li>需要注意减少代码尺寸。</li>
<li>需要移植printf从而使得嵌入式系统也能够打印输入。</li>
<li>使用Newlib作为C运行库。</li>
<li>每个特定的嵌入式系统都需要配套的板级支持包。</li>
</ul>
<h3 id="交叉编译和远程调试"><a class="header" href="#交叉编译和远程调试">交叉编译和远程调试</a></h3>
<p>嵌入式平台上往往资源有限，嵌入式系统（譬如常见ARM   MCU或8051单片机）的存储器容量通常只在几KB到几MB之间，且只有闪存而没有硬盘这种大容量存储设备，在这种资源有限的环境中，不可能将编译器等开发工具安装在嵌入式设备中，所以无法直接在嵌入式设备中进行软件开发。因此，嵌入式平台的软件一般在主机PC上进行开发和编译，然后将编译好的二进制代码下载至目标嵌入式系统平台上运行，这种编译方式属于交叉编译。</p>
<p>交叉编译可以简单理解为，在当前编译平台下，编译出来的程序能运行在体系结构不同的另一种目标平台上，但是编译平台本身却不能运行该程序，譬如，在x86平台的PC电脑上编写程序并编译成能运行在ARM平台的程序，编译得到的程序在x86平台上不能运行，必须放到ARM平台上才能运行。</p>
<p>与交叉编译同理，在嵌入式平台上往往也无法运行完整的调试器，因此当运行于嵌入式平台上的程序出现问题时，需要借助主机PC平台上的调试器来对嵌入式平台进行调试。这种调试方式属于远程调试。</p>
<p>常见的交叉编译和远程调试工具是GCC和GDB。GCC不仅能作为本地编译器，还能作为交叉编译器；同理GDB不仅可以作为本地调试器，还可以作为远程调试器。</p>
<p>当作为交叉编译器之时，GCC通常有不同的命名，譬如：</p>
<ul>
<li>arm-none-eabi-gcc和arm-none-eabi-gdb是面向裸机（Bare-Metal）ARM平台的交叉编译器和远程调试器。
<ul>
<li>所谓裸机（Bare-Metal）是嵌入式领域的一个常见形态，表示不运行操作系统的系统</li>
</ul>
</li>
<li>而riscv-none-embed-gcc和riscv-none-embed-gdb是面向裸机RISC-V平台的交叉编译器和远程调试器。</li>
</ul>
<h3 id="移植newlib或newlib-nano作为c运行库"><a class="header" href="#移植newlib或newlib-nano作为c运行库">移植newlib或newlib-nano作为C运行库</a></h3>
<p>newlib是一个面向嵌入式系统的C运行库。相对于glibc，newlib实现了大部分的功能函数，但体积却小很多。newlib独特的体系结构将功能实现与具体的操作系统分层，使之能够很好地进行配置以满足嵌入式系统的要求。由于专为嵌入式系统设计，newlib具有可移植性强、轻量级、速度快、功能完备等特点，已广泛应用于各种嵌入式系统中。</p>
<p>由于嵌入式操作系统和底层硬件的多样性，为了能够将C/C++语言所需要的库函数实现与具体的操作系统和底层硬件进行分层，newlib的所有库函数都建立在20个桩函数的基础上，这20个桩函数完成具体操作系统和底层硬件相关的功能：</p>
<ul>
<li>I/O和文件系统访问（open、close、read、write、lseek、stat、fstat、fcntl、link、unlink、rename）；</li>
<li>扩大内存堆的需求（sbrk）；</li>
<li>获得当前系统的日期和时间（gettimeofday、times）；</li>
<li>各种类型的任务管理函数（execve、fork、getpid、kill、wait、_exit）；</li>
</ul>
<p>这20个桩函数在语义、语法上与POSIX（Portable Operating System Interface of UNIX）标准下对应的20个同名系统调用完全兼容。</p>
<p>所以，如果需要移植newlib至某个目标嵌入式平台，成功移植的关键是在目标平台下找到能够与newlib桩函数衔接的功能函数或者实现这些桩函数。</p>
<p>注意：newlib的一个特殊版本newlib-nano版本进一步为嵌入式平台减少了代码体积（Code Size），因为newlib-nano提供了更加精简版本的malloc和printf函数的实现，并且对库函数使用GCC的-Os（侧重代码体积的优化）选项进行编译优化。</p>
<h3 id="嵌入式引导程序和中断异常处理"><a class="header" href="#嵌入式引导程序和中断异常处理">嵌入式引导程序和中断异常处理</a></h3>
<p>前文介绍了如何在Linux系统的PC电脑上开发一个Hello  World程序，对其进行编译，然后运行在此电脑上。在这种方式下，程序员仅仅只需要关注Hello  World程序本身，程序的主体由main函数组织而成，程序员可以无需关注Linux操作系统在运行该程序的main函数之前和之后需要做什么。事实上，在Linux操作系统中运行应用程序（譬如简单的Hello   World）时，操作系统需要动态地创建一个进程、为其分配内存空间、创建并运行该进程的引导程序，然后才会开始执行该程序的main函数，待其运行结束之后，操作系统还要清除并释放其内存空间、注销该进程等。</p>
<p>从上述过程中可以看出，程序的引导和清除这些“脏活累活”都是由Linux这样的操作系统来负责进行。但是在嵌入式系统中，程序员除了开发以main函数为主体的功能程序之外，还需要关注如下两个方面：</p>
<ul>
<li>引导程序：
<ul>
<li>嵌入式系统上电后需要对系统硬件和软件运行环境进行初始化，这些工作往往由用汇编语言编写的引导程序完成。</li>
<li>引导程序是嵌入式系统上电后运行的第一段软件代码。引导程序对于嵌入式系统非常关键，引导程序所执行的操作依赖于所开发的嵌入式系统的软硬件特性，一般流程包括：初始化硬件、设置异常和中断向量表、把程序拷贝到片上SRAM中、完成代码的重映射等，最后跳转到main函数入口。</li>
</ul>
</li>
<li>中断异常处理
<ul>
<li>中断和异常是嵌入式系统非常重要的一个环节，因此，嵌入式系统软件还必须正确地配置中断和异常处理函数。</li>
</ul>
</li>
</ul>
<h3 id="嵌入式系统链接脚本"><a class="header" href="#嵌入式系统链接脚本">嵌入式系统链接脚本</a></h3>
<p>上文中介绍了如何在Linux系统的PC电脑上开发一个Hello World程序，对其进行编译，然后运行在此电脑上。在这种方式下，程序员也无需关心编译过程中的“链接”这一步骤所使用的链接脚本，无需为程序分配具体的内存空间。</p>
<p>但是在嵌入式系统中，程序员除了开发以main函数为主体的功能程序之外，还需要关注“链接脚本”为程序分配合适的存储器空间，譬如程序段放在什么区间、数据段放在什么区间等等。</p>
<h3 id="减小代码体积"><a class="header" href="#减小代码体积">减小代码体积</a></h3>
<p>嵌入式平台上往往存储器资源有限，嵌入式系统（譬如常见的ARM   MCU或8051单片机）的存储器容量通常只在几KB到几MB之间，且只有闪存而没有硬盘这种大容量存储设备，在这种资源有限的环境中，程序的代码体积（Code  Size）显得尤其重要，因此，有效地降低降低代码体积（Code Size）是嵌入式软件开发必须要考虑的问题，常见的方法如：</p>
<ul>
<li>使用newlib-nano作为C运行库以取得较小代码体积（Code Size）的C库函数。</li>
<li>尽量少使用C语言的大型库函数，譬如在正式发行版本的程序中避免使用printf和scanf等函数。</li>
<li>如果在开发的过程中一定需要使用printf函数，可以使用某些自己实现的阉割版printf函数（而不是C运行库中提供的printf函数）以生成较小的代码体积。</li>
<li>除此之外，在C/C++语言的语法和程序开发方面也有众多技巧以取得更小的代码体积（Code Size）。</li>
</ul>
<h3 id="支持printf函数"><a class="header" href="#支持printf函数">支持printf函数</a></h3>
<p>上文中介绍了如何在Linux系统的PC电脑上开发一个Hello World程序，程序中使用C语言的标准库函数printf打印了一个“Hello  World”字符串。该程序在Linux系统里面运行的时候字符串被成功的输出到了Linux的终端界面上。在这个过程中，程序员无需关心Linux系统到底是如何将printf函数的字符串输出到Linux终端上的。事实上，在Linux本地编译的程序会链接使用Linux系统的C运行库glibc，而glibc充当了应用程序和Linux操作系统之间的接口，glibc提供的  printf 函数就会调用如sys_write等操作系统的底层系统调用函数，从而能够将“字符串”输出到Linux终端上。</p>
<p>从上述过程中可以看出，由于有glibc的支持，所以printf函数能够在Linux系统中正确的进行输出。但是在嵌入式系统中，printf的输出却不那么容易了，基于如下几个原因：</p>
<ul>
<li>嵌入式系统使用newlib作为C运行库，而newlib的C运行库所提供的printf函数最终依赖于如本文中所介绍的newlib桩函数write，因此必须实现此write函数才能够正确的执行printf函数。</li>
<li>嵌入式系统往往没有“显示终端”存在，譬如常见的单片机其作为一个黑盒子一般的芯片，根本没有显示终端。因此，为了能够支持显示输出，通常需要借助单片机芯片的UART接口将printf函数的输出重新定向到主机PC的COM口上，然后借助主机PC的串口调试助手显示出输出信息。同理，对于scanf输入函数，也需要通过主机PC的串口调试助手获取输入然后通过主机PC的COM口发送给单片机芯片的UART接口。</li>
<li>从以上两点可以看出，嵌入式平台的UART接口非常重要，往往扮演了输出管道的角色，为了能够将printf函数的输出定向到UART接口，需要实现newlib的桩函数write，使其通过编程UART的相关寄存器将字符通过UART接口输出。</li>
</ul>
<h3 id="提供板级支持包"><a class="header" href="#提供板级支持包">提供板级支持包</a></h3>
<p>对于特定的嵌入式硬件平台，为了方便用户在硬件平台上开发嵌入式程序，硬件平台一般会提供板级支持包（Board Support Package，BSP）。板级支持包所包含的内容没有绝对的标准，通常说来，其必须包含如下内容：</p>
<ul>
<li>底层硬件设备的地址分配信息</li>
<li>底层硬件设备的驱动函数</li>
<li>系统的引导程序</li>
<li>中断和异常处理服务程序</li>
<li>系统的链接脚本</li>
<li>如果使用newlib作为C运行库，一般还提供newlib桩函数的实现。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openwrt-基础"><a class="header" href="#openwrt-基础">OpenWRT 基础</a></h1>
<h2 id="flash-分区"><a class="header" href="#flash-分区">Flash 分区</a></h2>
<p>Linux系统对闪存类存储器是采用MTD设备驱动实现的。</p>
<pre><code class="language-bash">[    0.290000] spi-mt7621 10000b00.spi: sys_freq: 193333333
[    0.300000] m25p80 spi32766.0: w25q256 (32768 Kbytes)
[    0.300000] m25p80 spi32766.0: using chunked io
[    0.310000] 4 ofpart partitions found on MTD device spi32766.0
[    0.310000] Creating 4 MTD partitions on &quot;spi32766.0&quot;:
[    0.320000] 0x000000000000-0x000000030000 : &quot;u-boot&quot;
[    0.320000] 0x000000030000-0x000000040000 : &quot;u-boot-env&quot;
[    0.330000] 0x000000040000-0x000000050000 : &quot;factory&quot;
[    0.340000] 0x000000050000-0x000002000000 : &quot;firmware&quot;
[    0.410000] 2 uimage-fw partitions found on MTD device firmware
[    0.410000] 0x000000050000-0x000000168da1 : &quot;kernel&quot;
[    0.420000] 0x000000168da1-0x000002000000 : &quot;rootfs&quot;
[    0.420000] mtd: device 5 (rootfs) set to be root filesystem
[    0.430000] 1 squashfs-split partitions found on MTD device rootfs
[    0.440000] 0x000000620000-0x000002000000 : &quot;rootfs_data&quot;
</code></pre>
<p>::: tip
系统在SPI设备上创建了4个MTD分区
:::</p>
<div class="table-wrapper"><table><thead><tr><th>分区名</th><th>分区作用</th></tr></thead><tbody>
<tr><td>u-boot</td><td>引导程序</td></tr>
<tr><td>u-boot-env</td><td>引导程序的配置数据</td></tr>
<tr><td>factory</td><td>路由器芯片的初始化参数</td></tr>
<tr><td>firmware</td><td>固件分区</td></tr>
<tr><td>kernel</td><td>固件分区<br />Linux 内核</td></tr>
<tr><td>rootfs</td><td>固件分区<br />文件系统子集</td></tr>
<tr><td>rootfs_rom</td><td>固件分区<br />文件系统子集<br />只读分区子集</td></tr>
<tr><td>rootfs_data</td><td>固件分区<br />文件系统子集<br />可写分区子集</td></tr>
</tbody></table>
</div>
<p>::: tip
分区存在子分区，kernel和rootfs就是firmware的子分区，rootfs_rom和rootfs_data就是rootfs的子分区。
:::</p>
<h3 id="查看系统-mtd-分配"><a class="header" href="#查看系统-mtd-分配">查看系统 MTD 分配</a></h3>
<pre><code class="language-bash">root@Widora:~# cat /proc/mtd
dev:    size   erasesize  name
mtd0: 00030000 00010000 &quot;u-boot&quot;
mtd1: 00010000 00010000 &quot;u-boot-env&quot;
mtd2: 00010000 00010000 &quot;factory&quot;
mtd3: 01fb0000 00010000 &quot;firmware&quot;
mtd4: 00118da1 00010000 &quot;kernel&quot;
mtd5: 01e9725f 00010000 &quot;rootfs&quot;
mtd6: 019e0000 00010000 &quot;rootfs_data&quot;
</code></pre>
<h3 id="查看系统-mtd-分配-1"><a class="header" href="#查看系统-mtd-分配-1">查看系统 MTD 分配</a></h3>
<pre><code class="language-bash">root@Widora:~# cat /proc/partitions
major   minor  #blocks    name
31       0        192   mtdblock0
31       1         64   mtdblock1
31       2         64   mtdblock2
31       3      32448   mtdblock3
31       4       1123   mtdblock4
31       5      31324   mtdblock5
31       6      26496   mtdblock6
</code></pre>
<h3 id="读取备份-factory-分区"><a class="header" href="#读取备份-factory-分区">读取/备份 factory 分区</a></h3>
<p>factory 分区（位于 /dev/mtd2）保存了重要的配置参数（如MAC地址，天线匹配参数等）。</p>
<h4 id="查看分区内容"><a class="header" href="#查看分区内容">查看分区内容</a></h4>
<pre><code class="language-bash">root@Widora:~# hexdump /dev/mtd2
0000000 7628 0001 ef0c d2af b8a9 0000 0000 0000
0000010 ffff ffff ffff ffff ffff ffff ffff ffff
0000020 0000 0000 0020 0000 ef0c d2af b8a9 ef0c
0000030 d2af b9a9 3422 2000 ffff 0100 0000 0000
0000040 0000 0022 0000 0000 0030 0000 0000 0000
0000050 0081 9400 b040 c640 c31a c2c3 c5c0 0027
0000060 ffff ffff ffff ffff ffff ffff ffff ffff
*
00000a0 c6c6 c4c4 c0c4 c4c0 c4c4 c0c4 c0c0 0000
00000b0 ffff ffff ffff ffff ffff ffff ffff ffff
*
00000f0 0000 0000 00d1 8800 0000 0000 0000 0000
0000100 ffff ffff ffff ffff ffff ffff ffff ffff
*
0000120 0000 0000 0000 0000 0000 0000 0000 0077
0000130 1d11 1d11 7f15 7f15 7f17 7f17 3b10 3b10
0000140 ffff ffff ffff ffff ffff ffff ffff ffff
*
0010000
</code></pre>
<h4 id="备份分区"><a class="header" href="#备份分区">备份分区</a></h4>
<p>使用 <code>dd</code> 命令将分区读到一个文件中，然后使用浏览器下载到本地。</p>
<pre><code class="language-bash">root@Widora:~# dd if=/dev/mtd2 of=/www/art.bin
128+0 records in
128+0 records out
root@Widora:~# ls -l /www/art.bin
-rw-r--r--    1 root     root         65536 Apr 27 18:26 /www/art.bin
</code></pre>
<h2 id="文件系统"><a class="header" href="#文件系统">文件系统</a></h2>
<pre><code class="language-bash">root@Widora:/# df
Filesystem           1K-blocks      Used Available Use% Mounted on
rootfs                   26496       752     25744   3% /
/dev/root                 4864      4864         0 100% /rom
tmpfs                    63232        84     63148   0% /tmp
/dev/mtdblock6           26496       752     25744   3% /overlay
overlayfs:/overlay       26496       752     25744   3% /
tmpfs                      512         0       512   0% /dev
</code></pre>
<ol>
<li>引导程序启动内核完成后，由内核加载 <code>rootfs_rom</code> 只读分区来完成系统的初步启动。<code>rootfs_rom</code> 只读分区采用的是 Linux 内核支持的 <strong>squashFS</strong> 文件系统，加载完毕后将其挂载到 <code>/rom</code> 目录，同时也挂载为 <code>/</code> 目录。</li>
<li>系统将使用 <strong>JFFS2</strong> 文件系统格式化的 <code>rootfs_data</code> 可写文件分区并将这部分挂载到 <code>/overlay</code> 目录。</li>
<li>系统再将 <code>/overlay</code> 透明挂载为 <code>/</code> 根目录。</li>
<li>最后将一部分内存挂载为<code>/tmp</code> 目录。</li>
</ol>
<h3 id="透明挂载根目录-"><a class="header" href="#透明挂载根目录-">透明挂载根目录 /</a></h3>
<p>::: tip</p>
<p>OpenWrt 设计的一个特点是：系统先将 <code>rootfs_rom</code> 挂载为 <code>/</code> 根目录，这样就具备了一个完整的系统，然后再将 <code>rootfs_data</code> 以透明方式挂载在 <code>/</code> 根目录上。</p>
<p>:::</p>
<ul>
<li>最终呈现的根文件系统是由 <code>rootfs_rom</code> 和 <code>rootfs_data</code> 两个分区组合在一起的效果。</li>
<li>对任何文件的修改（增、删、改）都会记录在 <code>rootfs_data</code> 分区中。</li>
<li>读取文件内容时，首先检测 <code>rootfs_data</code> 里的状态，再检测 <code>roots_rom</code> 里的内容，最后输出结果。</li>
</ul>
<p>::: warning</p>
<p>如果修改了一个名为 abc 的文件，那么在 <code>/rom</code> 里还会保留修改之前的那个 abc 文件，同时在 <code>/overlay</code> 里有修改后的 abc 文件，因此所占的空间将会倍增。这样带来的一个好处是，在任何时候，只要删除 <code>/overlay</code> 里所有的文件，就能达到恢复出厂的效果。</p>
<p>:::</p>
<h3 id="常用文件夹"><a class="header" href="#常用文件夹">常用文件夹</a></h3>
<div class="table-wrapper"><table><thead><tr><th>文件夹路径</th><th>作用</th></tr></thead><tbody>
<tr><td>/etc/</td><td>存放系统所有的配置文件</td></tr>
<tr><td>/etc/init.d/</td><td>存放启动的服务脚本</td></tr>
<tr><td>/etc/config/</td><td>存放 OpenWrt 的配置文件，包括网络</td></tr>
<tr><td>/tmp/</td><td>存放临时文件和动态的配置文件</td></tr>
<tr><td>/tmp/TZ</td><td>系统启动后所使用的时区参数</td></tr>
</tbody></table>
</div>
<h2 id="软件包管理器-opkg"><a class="header" href="#软件包管理器-opkg">软件包管理器 OPKG</a></h2>
<h3 id="配置-opkg"><a class="header" href="#配置-opkg">配置 OPKG</a></h3>
<p><code>/etc/opkg.conf</code> 文件保存 OPKG 相关设置：</p>
<pre><code class="language-bash">root@Widora:/# cat /etc/opkg.conf
dest root /
dest ram /tmp
lists_dir ext /var/opkg-lists
option overlay_root /overlay
option check_signature 1
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>配置选项</th><th>说明</th></tr></thead><tbody>
<tr><td>dest root</td><td>安装目标的跟路径</td></tr>
<tr><td>dest ram</td><td>内存临时文件路径</td></tr>
<tr><td>lists_dir ext</td><td>软件包列表文件</td></tr>
<tr><td>option overlay_root</td><td>可写分区挂载位置</td></tr>
</tbody></table>
</div>
<h3 id="常用命令搭配"><a class="header" href="#常用命令搭配">常用命令搭配</a></h3>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody>
<tr><td>opkg update</td><td>下载服务器上可用的软件包列表</td></tr>
<tr><td>opkg upgrade &lt;package&gt;</td><td>升级软件包</td></tr>
<tr><td>opkg install &lt;package&gt;</td><td>安装软件包</td></tr>
<tr><td>opkg configure &lt;package&gt;</td><td>配置某一个软件包</td></tr>
<tr><td>opkg remove &lt;package&gt;</td><td>卸载软件包</td></tr>
<tr><td>opkg list</td><td>列出全部可用的软件包</td></tr>
<tr><td>opkg list-installed</td><td>列出已安装的软件包</td></tr>
<tr><td>opkg list-upgradable</td><td>列出可以升级的软件包</td></tr>
<tr><td>opkg info [package|regexp]</td><td>显示指定软件包的信息</td></tr>
<tr><td>opkg status [package|regexp]</td><td>显示指定软件包的状态</td></tr>
<tr><td>opkg download &lt;package&gt;</td><td>下载一个软件包到当前目录，但不安装</td></tr>
</tbody></table>
</div>
<p>::: tip</p>
<p>软件包列表可能会比较大，因此并不保存在系统中，每次启动需要首先执行 <code>opkg update</code> 取得最新的软件包。</p>
<p>:::</p>
<pre><code class="language-bash">root@Widora:/# opkg update
Downloading http://downloads.openwrt.org/chaos_calmer/15.05.1/ramips/mt7688/packages/base/Packages.gz.
Updated list of available packages in /var/opkg-lists/chaos_calmer_base.
Downloading http://downloads.openwrt.org/chaos_calmer/15.05.1/ramips/mt7688/packages/base/Packages.sig.
Signature check passed.
Downloading http://downloads.openwrt.org/chaos_calmer/15.05.1/ramips/mt7688/packages/luci/Packages.gz.
Updated list of available packages in /var/opkg-lists/chaos_calmer_luci.
Downloading http://downloads.openwrt.org/chaos_calmer/15.05.1/ramips/mt7688/packages/luci/Packages.sig.
Signature check passed.
Downloading http://downloads.openwrt.org/chaos_calmer/15.05.1/ramips/mt7688/packages/management/Packages.gz.
Updated list of available packages in /var/opkg-lists/chaos_calmer_management.
Downloading http://downloads.openwrt.org/chaos_calmer/15.05.1/ramips/mt7688/packages/management/Packages.sig.
Signature check passed.
Downloading http://downloads.openwrt.org/chaos_calmer/15.05.1/ramips/mt7688/packages/packages/Packages.gz.
Updated list of available packages in /var/opkg-lists/chaos_calmer_packages.
Downloading http://downloads.openwrt.org/chaos_calmer/15.05.1/ramips/mt7688/packages/packages/Packages.sig.
Signature check passed.
Downloading http://downloads.openwrt.org/chaos_calmer/15.05.1/ramips/mt7688/packages/routing/Packages.gz.
Updated list of available packages in /var/opkg-lists/chaos_calmer_routing.
Downloading http://downloads.openwrt.org/chaos_calmer/15.05.1/ramips/mt7688/packages/routing/Packages.sig.
Signature check passed.
Downloading http://downloads.openwrt.org/chaos_calmer/15.05.1/ramips/mt7688/packages/telephony/Packages.gz.
Updated list of available packages in /var/opkg-lists/chaos_calmer_telephony.
Downloading http://downloads.openwrt.org/chaos_calmer/15.05.1/ramips/mt7688/packages/telephony/Packages.sig.
Signature check passed.
</code></pre>
<h2 id="uci-命令系统"><a class="header" href="#uci-命令系统">UCI 命令系统</a></h2>
<p>UCI (Unified Configuration Interface) 是 OpenWrt 中配置参数管理系统，UCI 中已经包含了网络配置、无线配置、系统信息配置等基本路由器所需的主要配置参数。</p>
<p>UCI 配置文件全部存储在 <code>/etc/config</code> 目录下：</p>
<pre><code class="language-bash">root@Widora:/# ls /etc/config/
dhcp           fstab          mountd         shairport      uhttpd
dropbear       luci           network        system         wireless
firewall       mjpg-streamer  rpcd           ucitrack
</code></pre>
<p>常见的 UCI 配置：</p>
<div class="table-wrapper"><table><thead><tr><th>配置文件</th><th>作用</th></tr></thead><tbody>
<tr><td>/etc/config/dhcp</td><td>面向 LAN 口提供的 IP 地址分配服务配置</td></tr>
<tr><td>/etc/config/dropbear</td><td>SSH 服务配置</td></tr>
<tr><td>/etc/config/firewall</td><td>路由转发，端口转发，防火墙规则</td></tr>
<tr><td>/etc/config/network</td><td>自身网络接口配置</td></tr>
<tr><td>/etc/config/system</td><td>时间服务器时区配置</td></tr>
<tr><td>/etc/config/wireless</td><td>无线网络配置</td></tr>
</tbody></table>
</div>
<p>支持 UCI 管理模式的软件包是这样完成启动的（以 <strong>samba</strong> 软件为例）：</p>
<ol>
<li>启动脚本 <code>/etc/init.d/samba</code></li>
<li>启动脚本通过 UCI 分析库从 <code>/etc/config/samba</code> 获得启动参数</li>
<li>启动脚本完成正常启动</li>
</ol>
<p>::: warning</p>
<p>UCI 配置文件既可以使用 UCI 命令进行修改，也可以使用文本编辑器直接修改。但如果两种方式都使用，需要注意 UCI 命令修改会产生缓存，每次修改好要尽快保存确认，以免出现冲突。</p>
<p>:::</p>
<h3 id="uci-文件格式"><a class="header" href="#uci-文件格式">UCI 文件格式</a></h3>
<pre><code>config 'section-type' 'section'
	option 'key' 'value'
	option 'list_key' 'list_value1'
	option 'list_key' 'list_value2'
</code></pre>
<p>::: tip</p>
<p>UCI 允许只有 <strong>section-type</strong> 的匿名配置节点。</p>
<p>:::</p>
<h3 id="uci-命令读写配置"><a class="header" href="#uci-命令读写配置">UCI 命令读写配置</a></h3>
<pre><code class="language-bash">uci [&lt;option&gt;] &lt;command&gt; [&lt;arguments&gt;]
</code></pre>
<h4 id="读取类语法"><a class="header" href="#读取类语法">读取类语法</a></h4>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody>
<tr><td>uci get &lt;config&gt;.&lt;section&gt;</td><td>获取节点类型</td></tr>
<tr><td>uci get &lt;config&gt;.&lt;section&gt;.&lt;option&gt;</td><td>获取取得一个值</td></tr>
<tr><td>uci show</td><td>显示全部 UCI 配置</td></tr>
<tr><td>uci show &lt;config&gt;</td><td>显示指定文件配置</td></tr>
<tr><td>uci show &lt;config&gt;.&lt;section&gt;</td><td>显示指定节点的配置</td></tr>
<tr><td>uci show &lt;config&gt;.&lt;section&gt;.&lt;option&gt;</td><td>显示指定选项配置</td></tr>
<tr><td>uci changes &lt;config&gt;</td><td>显示尚未生效的修改记录</td></tr>
<tr><td>uci show -X &lt;config&gt;.&lt;section&gt;.&lt;option&gt;</td><td>显示匿名节点</td></tr>
</tbody></table>
</div>
<h4 id="写入类语法"><a class="header" href="#写入类语法">写入类语法</a></h4>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody>
<tr><td>uci add &lt;config&gt; &lt;section-type&gt;</td><td>增加一个匿名节点</td></tr>
<tr><td>uci set &lt;config&gt;.&lt;section&gt; = &lt;section-type&gt;</td><td>增加一个节点/修改节点类型</td></tr>
<tr><td>uci set &lt;config&gt;.&lt;section&gt;.&lt;option&gt; = &lt;value&gt;</td><td>增加一个选项值/修改一个选项值</td></tr>
<tr><td>uci add_list &lt;config&gt;.&lt;section&gt;.&lt;option&gt; = &lt;value&gt;</td><td>在列表中增加一个值</td></tr>
<tr><td>uci delete &lt;config&gt;.&lt;section&gt;</td><td>删除指定节点</td></tr>
<tr><td>uci delete &lt;config&gt;.&lt;section&gt;.&lt;option&gt;</td><td>删除指定选项</td></tr>
<tr><td>uci delete &lt;config&gt;.&lt;section&gt;.&lt;list&gt;</td><td>删除列表</td></tr>
<tr><td>uci del_list &lt;config&gt;.&lt;section&gt;.&lt;option&gt; = &lt;string&gt;</td><td>删除列表中的一个值</td></tr>
<tr><td>uci commit &lt;config&gt;</td><td>使修改生效</td></tr>
</tbody></table>
</div>
<p>::: warning</p>
<p>UCI 读取总是先读取内存中的缓存，然后再读取文件中的。进行过增删改操作后要执行生效指令，否则所有的修改只留存在缓存中。</p>
<p>:::</p>
<h2 id="常用配置操作"><a class="header" href="#常用配置操作">常用配置操作</a></h2>
<h3 id="查看-system-配置"><a class="header" href="#查看-system-配置">查看 system 配置</a></h3>
<pre><code class="language-bash">root@Widora:/# cat /etc/config/system
config system
	option hostname	Widora
	option timezone	CST-8

config timeserver ntp
	list server	0.openwrt.pool.ntp.org
	list server	1.openwrt.pool.ntp.org
	list server	2.openwrt.pool.ntp.org
	list server	3.openwrt.pool.ntp.org
	option enabled 1
	option enable_server 0
root@Widora:/# uci show system
system.@system[0]=system
system.@system[0].hostname='Widora'
system.@system[0].timezone='CST-8'
system.ntp=timeserver
system.ntp.server='0.openwrt.pool.ntp.org' '1.openwrt.pool.ntp.org' '2.openwrt.pool.ntp.org' '3.openwrt.pool.ntp.org'
system.ntp.enabled='1'
system.ntp.enable_server='0'
</code></pre>
<h3 id="查看网络配置"><a class="header" href="#查看网络配置">查看网络配置</a></h3>
<pre><code class="language-bash">root@Widora:/# cat /etc/config/network

config interface 'loopback'
	option ifname 'lo'
	option proto 'static'
	option ipaddr '127.0.0.1'
	option netmask '255.0.0.0'

config globals 'globals'
	option ula_prefix 'fdff:c5b2:821c::/48'

config interface 'lan'
	option force_link '1'
	option macaddr '0c:ef:af:d2:a9:b9'
	option type 'bridge'
	option proto 'static'
	option ipaddr '192.168.8.1'
	option netmask '255.255.255.0'
	option ip6assign '60'
	option ifname 'eth0.1'

config interface 'wan'
	option force_link '1'
	option macaddr '0c:ef:af:d2:a9:b8'
	option proto 'dhcp'
	option ifname 'eth0.2'

config interface 'wan6'
	option proto 'dhcpv6'
	option ifname 'eth0.2'

config switch
	option name 'switch0'
	option reset '1'
	option enable_vlan '1'

config switch_vlan
	option device 'switch0'
	option vlan '1'
	option ports '1 2 3 4 6t'

config switch_vlan
	option device 'switch0'
	option vlan '2'
	option ports '0 6t'
</code></pre>
<h3 id="重启网络使配置生效"><a class="header" href="#重启网络使配置生效">重启网络使配置生效</a></h3>
<pre><code class="language-bash">root@Widora:~# /etc/init.d/network restart
</code></pre>
<h3 id="开启-wi-fi"><a class="header" href="#开启-wi-fi">开启 Wi-Fi</a></h3>
<pre><code class="language-bash">uci set wireless.radio0.disabled=0 # 使能 Wi-Fi
uci commit wireless # 使配置生效
wifi # 启动 Wi-Fi
</code></pre>
<h3 id="查看当前网络"><a class="header" href="#查看当前网络">查看当前网络</a></h3>
<pre><code class="language-bash">root@Widora:/# ifconfig
br-lan    Link encap:Ethernet  HWaddr 0C:EF:AF:D2:A9:B9
          inet addr:192.168.8.1  Bcast:192.168.8.255  Mask:255.255.255.0
          inet6 addr: fe80::eef:afff:fed2:a9b9/64 Scope:Link
          inet6 addr: fdff:c5b2:821c::1/60 Scope:Global
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:574264 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1217669 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:48102567 (45.8 MiB)  TX bytes:1634912136 (1.5 GiB)

eth0      Link encap:Ethernet  HWaddr 0C:EF:AF:D2:A9:B8
          inet6 addr: fe80::eef:afff:fed2:a9b8/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1225320 errors:0 dropped:0 overruns:0 frame:0
          TX packets:579507 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:1641989813 (1.5 GiB)  TX bytes:59132909 (56.3 MiB)
          Interrupt:5

eth0.1    Link encap:Ethernet  HWaddr 0C:EF:AF:D2:A9:B8
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1 errors:0 dropped:1 overruns:0 frame:0
          TX packets:3544 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:46 (46.0 B)  TX bytes:244206 (238.4 KiB)

eth0.2    Link encap:Ethernet  HWaddr 0C:EF:AF:D2:A9:B8
          inet addr:192.168.1.5  Bcast:192.168.1.255  Mask:255.255.255.0
          inet6 addr: fe80::eef:afff:fed2:a9b8/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1176423 errors:0 dropped:10706 overruns:0 frame:0
          TX packets:575928 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:1617670919 (1.5 GiB)  TX bytes:56565373 (53.9 MiB)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:294 errors:0 dropped:0 overruns:0 frame:0
          TX packets:294 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:41961 (40.9 KiB)  TX bytes:41961 (40.9 KiB)

ra0       Link encap:Ethernet  HWaddr 0C:EF:AF:D2:A9:B8
          inet6 addr: fe80::eef:afff:fed2:a9b8/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:641847 errors:830 dropped:0 overruns:0 frame:0
          TX packets:1228723 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:70965355 (67.6 MiB)  TX bytes:1630822247 (1.5 GiB)
          Interrupt:6
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>网络设备名</th><th>说明</th></tr></thead><tbody>
<tr><td>br-lan</td><td>虚拟设备，LAN 口桥接设备，包含通过 LAN 口和 WAN 口连入系统的设备统一桥接</td></tr>
<tr><td>eth0</td><td>真实设备，CPU 内部到交换机芯片之间只有一个接口</td></tr>
<tr><td>eth0.1</td><td>虚拟设备，由 VLAN 划分的有线的 LAN 口，VLAN 编号为 1</td></tr>
<tr><td>eth0.2</td><td>虚拟设备，由 VLAN 划分的有线的 LAN 口，VLAN编号为 2</td></tr>
<tr><td>lo</td><td>虚拟设备，回环设备</td></tr>
<tr><td>ra0</td><td>真实设备，启动 Wi-Fi 后将会产生此无线设备</td></tr>
<tr><td>pppoe-wan</td><td>虚拟设备，是 PPPoE 拨号上网成功后产生的</td></tr>
</tbody></table>
</div>
<h3 id="查看-br-lan-桥状态"><a class="header" href="#查看-br-lan-桥状态">查看 br-lan 桥状态</a></h3>
<pre><code class="language-bash">root@Widora:/# brctl show
bridge name	bridge id			STP enabled	interfaces
br-lan		7fff.0cefafd2a9b9	no			eth0.1
											ra0
</code></pre>
<h3 id="查看内核日志"><a class="header" href="#查看内核日志">查看内核日志</a></h3>
<pre><code class="language-bash">root@Widora:/# logread
</code></pre>
<h3 id="查看当前-vlan-划分"><a class="header" href="#查看当前-vlan-划分">查看当前 VLAN 划分</a></h3>
<pre><code class="language-bash">root@Widora:/# swconfig dev switch0 show
Global attributes:
	enable_vlan: 1
	alternate_vlan_disable: 0
	bc_storm_protect: 0
	led_frequency: 0
Port 0:
	disable: 0
	doubletag: 0
	untag: 1
	led: 5
	lan: 1
	recv_bad: 0
	recv_good: 2205
	tr_bad: 0
	tr_good: 52155
	pvid: 2
	link: port:0 link:up speed:100baseT full-duplex
Port 1:
	disable: 0
	doubletag: 0
	untag: 1
	led: 5
	lan: 1
	recv_bad: 0
	recv_good: 0
	tr_bad: 0
	tr_good: 0
	pvid: 1
	link: port:1 link:down
Port 2:
	disable: 0
	doubletag: 0
	untag: 1
	led: 5
	lan: 1
	recv_bad: 0
	recv_good: 0
	tr_bad: 0
	tr_good: 0
	pvid: 1
	link: port:2 link:down
Port 3:
	disable: 0
	doubletag: 0
	untag: 1
	led: 5
	lan: 1
	recv_bad: 0
	recv_good: 0
	tr_bad: 0
	tr_good: 0
	pvid: 1
	link: port:3 link:down
Port 4:
	disable: 0
	doubletag: 0
	untag: 1
	led: 5
	lan: 1
	recv_bad: 0
	recv_good: 0
	tr_bad: 0
	tr_good: 0
	pvid: 1
	link: port:4 link:down
Port 5:
	disable: 1
	doubletag: 0
	untag: 0
	led: ???
	lan: 1
	recv_bad: 0
	recv_good: 0
	tr_bad: 0
	tr_good: 0
	pvid: 0
	link: port:5 link:down
Port 6:
	disable: 0
	doubletag: 0
	untag: 0
	led: ???
	lan: ???
	recv_bad: ???
	recv_good: ???
	tr_bad: ???
	tr_good: ???
	pvid: 0
	link: port:6 link:up speed:1000baseT full-duplex
VLAN 1:
	ports: 1 2 3 4 6t
VLAN 2:
	ports: 0 6t
</code></pre>
<p>::: tip</p>
<p>哪个网口是 LAN， 哪个是 WAN， 是由 VLAN 划分的。VLAN1 为 LAN 口，包含 1、2、3、4 接口；VLAN2 为 WAN 口，包含了 0 接口。</p>
<p>:::</p>
<h3 id="配置-wan-口外网"><a class="header" href="#配置-wan-口外网">配置 WAN 口外网</a></h3>
<h4 id="查看-wan-口配置"><a class="header" href="#查看-wan-口配置">查看 WAN 口配置</a></h4>
<pre><code class="language-bash">root@Widora:/# uci show network.wan
network.wan=interface
network.wan.force_link='1'
network.wan.macaddr='0c:ef:af:d2:a9:b8'
network.wan.proto='dhcp'
network.wan.ifname='eth0.2'
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>选项</th><th>说明</th><th>可选值</th></tr></thead><tbody>
<tr><td>ifname</td><td>设备接口名</td><td>eth0.2</td></tr>
<tr><td>proto</td><td>协议类型</td><td>static：静态 IP 地址<br />dhcp：动态获取 IP 地址<br />pppoe：拨号上网<br />pptp：远程 VPN 服务器<br />3g：连接 3G/4G 无线电话网络</td></tr>
<tr><td>macaddr</td><td>WAN 口 MAC 地址，修改该地址即可实现 MAC 地址克隆</td><td>首次数据根据 factory 分区内参数自动生成</td></tr>
</tbody></table>
</div>
<h4 id="动态获取-ip-选项"><a class="header" href="#动态获取-ip-选项">动态获取 IP 选项</a></h4>
<div class="table-wrapper"><table><thead><tr><th>选项</th><th>说明</th><th>可选值及说明</th></tr></thead><tbody>
<tr><td>proto</td><td>协议类型</td><td>dhcp</td></tr>
<tr><td>ifname</td><td>设备名称</td><td>eth0.2</td></tr>
<tr><td>macaddr</td><td>MAC 地址</td><td>根据 factory 分区自动生成的值</td></tr>
<tr><td>mtu</td><td>最大数据包大小，默认不用设置</td><td>数值</td></tr>
<tr><td>reqopts</td><td>在向 DHCP 服务器发出请求时增加附加的 DHCP 信息</td><td>字符串</td></tr>
<tr><td>dns</td><td>使用指定的 DNS 服务器地址替代获得的 DNS</td><td>字符串</td></tr>
</tbody></table>
</div>
<h4 id="指定静态-ip-选项"><a class="header" href="#指定静态-ip-选项">指定静态 IP 选项</a></h4>
<div class="table-wrapper"><table><thead><tr><th>选项</th><th>说明</th><th>可选值及说明</th></tr></thead><tbody>
<tr><td>proto</td><td>协议类型</td><td>static</td></tr>
<tr><td>ifname</td><td>设备名称</td><td>eth0.2</td></tr>
<tr><td>macaddr</td><td>MAC 地址</td><td>根据 factory 分区自动生成的值</td></tr>
<tr><td>mtu</td><td>最大数据包大小，默认不用设置</td><td>数值</td></tr>
<tr><td>ipaddr</td><td>WAN 口的 IP 地址</td><td>字符串</td></tr>
<tr><td>netmask</td><td>WAN 口的子网掩码</td><td>字符串</td></tr>
<tr><td>gateway</td><td>默认网关</td><td>字符串</td></tr>
<tr><td>broadcast</td><td>广播地址</td><td>字符串</td></tr>
<tr><td>dns</td><td>使用指定的 DNS 服务器地址替代获得的 DNS</td><td>字符串</td></tr>
</tbody></table>
</div>
<h4 id="pppoe-拨号上网选项"><a class="header" href="#pppoe-拨号上网选项">PPPOE 拨号上网选项</a></h4>
<div class="table-wrapper"><table><thead><tr><th>选项</th><th>说明</th><th>可选值及说明</th></tr></thead><tbody>
<tr><td>proto</td><td>协议类型</td><td>pppoe</td></tr>
<tr><td>ifname</td><td>设备名称</td><td>eth0.2</td></tr>
<tr><td>macaddr</td><td>MAC 地址</td><td>根据 factory 分区自动生成的值</td></tr>
<tr><td>mtu</td><td>最大数据包大小，默认不用设置</td><td>数值</td></tr>
<tr><td>username</td><td>拨号使用的帐号</td><td>字符串</td></tr>
<tr><td>password</td><td>拨号使用的密码</td><td>字符串</td></tr>
<tr><td>ac</td><td>使用指定的访问集中器进行连接</td><td>字符串</td></tr>
<tr><td>service</td><td>连接的服务名称</td><td>字符串</td></tr>
<tr><td>connect</td><td>连接时候执行的外部脚本</td><td>字符串</td></tr>
<tr><td>disconnect</td><td>断开连接时执行的外部脚本</td><td>字符串</td></tr>
<tr><td>demand</td><td>等待多久没有活动就断开 PPPOE 连接</td><td>数字，单位秒</td></tr>
<tr><td>dns</td><td>DNS 服务器地址</td><td>字符串</td></tr>
<tr><td>pppd_options</td><td>用于 pppd 进程执行时候的附加参数</td><td>字符串</td></tr>
</tbody></table>
</div>
<h3 id="配置-lan-口服务"><a class="header" href="#配置-lan-口服务">配置 LAN 口服务</a></h3>
<p>::: tip</p>
<p>LAN 口下的设备可以通过 WAN 口接入网络，也可以直接访问设备上的各项功能（系统防火墙对 LAN 口默认不做任何拦截）。</p>
<p>:::</p>
<h4 id="查看-lan-口配置"><a class="header" href="#查看-lan-口配置">查看 LAN 口配置</a></h4>
<pre><code class="language-bash">root@Widora:~# uci show network.lan
network.lan=interface
network.lan.force_link='1'
network.lan.macaddr='0c:ef:af:d2:a9:b9'
network.lan.type='bridge'
network.lan.proto='static'
network.lan.ipaddr='192.168.8.1'
network.lan.netmask='255.255.255.0'
network.lan.ip6assign='60'
network.lan.ifname='eth0.1'
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>选项</th><th>说明</th><th>可选值及说明</th></tr></thead><tbody>
<tr><td>ifname</td><td>设备名称</td><td>eth0.1</td></tr>
<tr><td>proto</td><td>协议类型</td><td>static</td></tr>
<tr><td>macaddr</td><td>MAC 地址</td><td>根据 factory 分区自动生成的值</td></tr>
<tr><td>type</td><td>网络类型</td><td>bridge，桥模式（这样才有交换机功能）</td></tr>
<tr><td>ipaddr</td><td>LAN 口的 IP 地址，用于局域网内其它设备访问路由器</td><td>字符串</td></tr>
<tr><td>netmask</td><td>LAN 口的子网掩码</td><td>字符串</td></tr>
</tbody></table>
</div>
<p>::: warning</p>
<p>修改过 LAN 口的配置后要重启网络以及 DHCP 服务。</p>
<pre><code class="language-bash">root@Widora:~# /etc/init.d/network restart
root@Widora:~# /etc/odhcpd restart
</code></pre>
<p>:::</p>
<h3 id="配置无线网络"><a class="header" href="#配置无线网络">配置无线网络</a></h3>
<h4 id="查看无线网络配置"><a class="header" href="#查看无线网络配置">查看无线网络配置</a></h4>
<pre><code class="language-bash">root@Widora:~# cat /etc/config/wireless

config wifi-device 'radio0'
	option type 'ralink'
	option variant 'mt7628'
	option country 'CN'
	option hwmode '11bgn'
	option htmode 'HT40'
	option channel 'auto'
	option disabled '0'

config wifi-iface 'ap'
	option device 'radio0'
	option mode 'ap'
	option network 'lan'
	option ifname 'ra0'
	option ssid 'Widora-A9B8'
	option hidden '0'
	option encryption 'psk2'
	option key 'passworkd'

config wifi-iface 'sta'
	option device 'radio0'
	option disabled '1'
	option mode 'sta'
	option network 'wwan'
	option ifname 'apcli0'
	option ssid 'UplinkAp'
	option key 'SecretKey'
</code></pre>
<h4 id="wifi-device-选项参数"><a class="header" href="#wifi-device-选项参数">wifi-device 选项参数</a></h4>
<div class="table-wrapper"><table><thead><tr><th>选项</th><th>说明</th><th>可选值及说明</th></tr></thead><tbody>
<tr><td>type</td><td>设备类型</td><td>ralink</td></tr>
<tr><td>channel</td><td>无线信道，不同的国家支持的信道不同</td><td>auto 或 1～13</td></tr>
<tr><td>hwmode</td><td>无线协议类型</td><td>11bgn: IEEE802.11b + IEEE802.11g + IEEE802.11n</td></tr>
<tr><td>htmode</td><td>无线频宽</td><td>HT20、HT40</td></tr>
<tr><td>disable</td><td>关闭无线设备</td><td>0：启用；1：禁用</td></tr>
<tr><td>country</td><td>国家类型，跟支持的频道有关，中国为 CN，支持 1～13</td><td>CN：中国</td></tr>
</tbody></table>
</div>
<h4 id="wifi-iface-选项参数"><a class="header" href="#wifi-iface-选项参数">wifi-iface 选项参数</a></h4>
<div class="table-wrapper"><table><thead><tr><th>选项</th><th>说明</th><th>可选值及说明</th></tr></thead><tbody>
<tr><td>device</td><td>关联的无线设备</td><td>radio0</td></tr>
<tr><td>network</td><td>关联网络设备类型</td><td>lan：表示桥接到 LAN 网上<br />wwan：表示启用无线中继</td></tr>
<tr><td>mode</td><td>无线工作模式</td><td>ap：热点模式<br />sta：客户端模式</td></tr>
<tr><td>ssid</td><td>无线的名称</td><td>字符串</td></tr>
<tr><td>hidden</td><td>隐藏无线名称</td><td>0：显示名称<br />1：隐藏名称</td></tr>
<tr><td>encryption</td><td>无线加密方式</td><td>none：不加密<br />psk：WPA-PSK 模式<br />psk2：WPA-PSK2 模式<br />psk-mixed：WPA-PSK / WPA-PSK2 混合模式</td></tr>
<tr><td>key</td><td>无线密钥</td><td>字符串，长度为 8～64 个 ASCII 字符</td></tr>
</tbody></table>
</div>
<p>::: tip</p>
<p>修改过无线配置后需要使用命令 <code>wifi</code> 使之生效</p>
<p>:::</p>
<h4 id="查看无线网络状态"><a class="header" href="#查看无线网络状态">查看无线网络状态</a></h4>
<pre><code class="language-bash">root@Widora:~# iwinfo
ra0       ESSID: &quot;Widora-A9B8&quot;
          Access Point: 0C:EF:AF:D2:A9:B8
          Mode: Client  Channel: 7 (2.442 GHz)
          Tx-Power: 18 dBm  Link Quality: 10/100
          Signal: -256 dBm  Noise: -82 dBm
          Bit Rate: 150.0 MBit/s
          Encryption: unknown
          Type: wext  HW Mode(s): 802.11bg
          Hardware: unknown [Generic WEXT]
          TX power offset: unknown
          Frequency offset: unknown
          Supports VAPs: no  PHY name: ra0
</code></pre>
<h4 id="搜索范围内的其它无线设备"><a class="header" href="#搜索范围内的其它无线设备">搜索范围内的其它无线设备</a></h4>
<pre><code class="language-bash">root@Widora:~# iwinfo ra0 scan
Cell 01 - Address: 50:64:2B:4B:02:4E
          ESSID: &quot;Xiaomi_024D&quot;
          Mode: Master  Channel: 11
          Signal: -256 dBm  Quality: 55/100
          Encryption: WPA2 PSK (TKIP, AES-OCB)

Cell 02 - Address: 44:97:5A:EC:C5:14
          ESSID: &quot;FAST_C514&quot;
          Mode: Master  Channel: 1
          Signal: -256 dBm  Quality: 47/100
          Encryption: WPA2 PSK (AES-OCB)
</code></pre>
<h2 id="防火墙"><a class="header" href="#防火墙">防火墙</a></h2>
<p>防火墙、DMZ（独立隔离区）、NAT 转发在 OpenWrt 系统中都是由 /etc/config/firewall 配置文件管理的。</p>
<h3 id="防火墙命令"><a class="header" href="#防火墙命令">防火墙命令</a></h3>
<h4 id="重置防火墙"><a class="header" href="#重置防火墙">重置防火墙</a></h4>
<pre><code class="language-bash">root@Widora:~# /etc/init.d/firewall reload
</code></pre>
<h3 id="重启防火墙"><a class="header" href="#重启防火墙">重启防火墙</a></h3>
<pre><code class="language-bash">root@Widora:~# /etc/init.d/firewall restart
</code></pre>
<h4 id="查看防火墙完整策略"><a class="header" href="#查看防火墙完整策略">查看防火墙完整策略</a></h4>
<pre><code class="language-bash">root@Widora:~# iptables -L
</code></pre>
<h3 id="防火墙-defaults-配置"><a class="header" href="#防火墙-defaults-配置">防火墙 defaults 配置</a></h3>
<pre><code class="language-bash">config defaults
	option syn_flood	1			# 启用防洪水攻击
	option input		ACCEPT		# INPUT 链过滤策略
	option output		ACCEPT		# OUTPUT 链过滤策略
	option forward		REJECT		# FORWARD 链过滤策略
</code></pre>
<h3 id="防火墙-zone-域配置"><a class="header" href="#防火墙-zone-域配置">防火墙 zone 域配置</a></h3>
<p>系统将 LAN 和 WAN 分为两个不同的 zone，它们之间是隔离的。</p>
<pre><code class="language-bash">config zone
	option name			lan			# zone 节点名
	list   network		'lan'		# 指定绑定到该 zone 上的设备
	option input		ACCEPT
	option output		ACCEPT
	option forward		ACCEPT

config zone
	option name			wan
	list   network		'wan'
	list   network		'wan6'
	list   network		'wwan'
	option input		ACCEPT
	option output		ACCEPT
	option forward		REJECT
	option masq			1			# 传输伪装开关，WAN 必须设为 1
	option mtu_fix		1			# 数据输出时开启 MSS 钳制，WAN 必须设为 1
</code></pre>
<h3 id="防火墙-forwarding-转发配置"><a class="header" href="#防火墙-forwarding-转发配置">防火墙 forwarding 转发配置</a></h3>
<p>forwarding 配置可以实现两个不同 zone 域之间的数据发送</p>
<pre><code class="language-bash">config forwarding
	option src		lan			# 来源 zone
	option dest		wan			# 目标 zone
</code></pre>
<h3 id="防火墙-rule-规则"><a class="header" href="#防火墙-rule-规则">防火墙 rule 规则</a></h3>
<p>默认情况下，所有进入 WAN 口的请求都会被拒绝，如果希望有例外，那么要通过 rule 来实现许可。</p>
<pre><code class="language-bash"># Allow IPv4 ping
config rule
	option name			Allow-Ping
	option src			wan					# 数据源的 zone 域
	option proto		icmp				# 数据源的协议类型
	option icmp_type	echo-request
	option family		ipv4				# IP 协议类型
	option target		ACCEPT				# 规则动作

# 禁止 LAN 口的某个 IP 访问 WAN 口
config rule
	option src		lan						# 数据源的 zone 域
	option src_ip	192.168.45.2			# 数据源的 IP 地址
	option dest		wan						# 目的地的 zone 域
	option proto	tcp
	option target	REJECT

# 禁止某个 MAC 地址访问 WAN
config rule
	option dest		wan
	option src_mac	00:11:22:33:44:66		# 数据源的 MAC 地址
	option target	REJECT

# 阻塞某个 zone 上的 ICMP 流量
config rule
	option src		lan
	option proto	ICMP
	option target	DROP
</code></pre>
<h3 id="防火墙-redirect-端口转发"><a class="header" href="#防火墙-redirect-端口转发">防火墙 redirect 端口转发</a></h3>
<p>端口转发允许访问者通过 WAN 口访问 LAN 口中的一个特定端口，并将结果转发回给访问者。</p>
<pre><code class="language-bash"># 将 LAN 口的 80 端口开放到 WAN 口上
config redirect
	option src			wan				# 被转发来源 zone 域
	option src_dport	80				# 被转发的端口
	option dest			lan				# 转发到哪个 zone 域
	option dest_ip		192.168.16.235 	# 转发到哪个 IP 地址
	option dest_port	80				# 转发到哪个端口
	option proto		tcp				# 协议类型

# 将所有来自 WAN 口的 TCP 协议访问 22001 的请求都转发给 LAN 中的一台 80 端口的计算机
config redirect
	option src			wan
	option src_dport	22001
	option dest			lan
	option dest_port	22
	option proto		tcp

# 将 IP 地址 192.168.1.2 设置到 DMZ 隔离区
config redirect
	option src			wan
	option proto		all
	option dest_ip		192.168.1.2
</code></pre>
<h2 id="ntp"><a class="header" href="#ntp">NTP</a></h2>
<p>NTP 用来使网络中的各个计算机时间同步的一种协议，它的用途是把系统的时钟同步到 UTC 时区，其精度在局域网内可达到 0.1ms，在互联网上绝大多数情况其精度可以达到1～50ms。</p>
<p>配置内容如下：</p>
<pre><code class="language-bash">root@Widora:~# cat /etc/config/system
config system
	option hostname	Widora				# 主机名
	option timezone	CST-8				# 时区

config timeserver ntp
	list server	0.openwrt.pool.ntp.org	# NTP 服务器地址
	list server	1.openwrt.pool.ntp.org
	list server	2.openwrt.pool.ntp.org
	list server	3.openwrt.pool.ntp.org
	option enabled 1					# 开启 NTP 功能
	option enable_server 0
</code></pre>
<p>::: tip</p>
<p>阿里云提供了 NTP 服务功能：</p>
<p>ntp1.aliyun.com</p>
<p>ntp2.aliyun.com</p>
<p>ntp3.aliyun.com</p>
<p>:::</p>
<h2 id="服务管理"><a class="header" href="#服务管理">服务管理</a></h2>
<h3 id="查看系统服务命令"><a class="header" href="#查看系统服务命令">查看系统服务命令</a></h3>
<pre><code class="language-bash">root@Widora:~# ls /etc/init.d/
avahi-daemon   dbus           dropbear       led            mountd         rpcd           sysctl         system         umount
boot           dnsmasq        firewall       log            network        setnetmode     sysfixtime     telnet
cron           done           fstab          mjpg-streamer  odhcpd         shairport      sysntpd        uhttpd
</code></pre>
<h3 id="服务命令的语法格式"><a class="header" href="#服务命令的语法格式">服务命令的语法格式</a></h3>
<pre><code>服务的语法格式：/etc/init.d/服务名称 [命令]
可用命令：
		start	临时开启这个服务
		stop	临时关闭这个服务
		restart 重启当前已开启的服务，如果没有开启就开启它
		reload 	重新读取该服务的配置信息（如果服务支持的话）
		enable	设置该服务随系统一同启动
		disable	禁止该服务随系统一同启动
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="控制系统基础"><a class="header" href="#控制系统基础">控制系统基础</a></h1>
<h2 id="控制系统建模"><a class="header" href="#控制系统建模">控制系统建模</a></h2>
<p>对于一个输入为 \(u\)，输出为 \(y\) 的动态系统，当 \(t\) 时刻的输出 \(y(t)\) 由直到 \(t\) 时刻为止的输入和输出来决定的时候，这个系统可以用下面的微分方程来表示：</p>
<p>$$
\frac{d^n}{dt^n}y(t) + a_{n-1}\frac{d^{n-1}}{dt^{n-1}}y(t) + \cdots + a_1\frac{d}{dt}y(t) + a_0y(t) \\
= b_m\frac{d^m}{dt^m}u(t) + b_{m-1}\frac{d^{m-1}}{dt^{m-1}}u(t) + \cdots + b_1\frac{d}{dt}u(t) + b_0u(t)
$$</p>
<p>微分方程很难求解以及分析系统行为，所以通常会将微分方程转换成<strong>传递函数模型</strong>或者<strong>状态空间模型</strong>。</p>
<h3 id="传递函数"><a class="header" href="#传递函数">传递函数</a></h3>
<p>传递函数模型使用复变函数来表现系统模型，可以通过将微分方程两边进行初始值为0的拉普拉斯变换得到。</p>
<p>拉普拉斯变换的定义：\(g(s) = \mathcal{L}[g(t)] = \int_0^{\infty}g(\tau)e^{-s\tau}d\tau\)</p>
<hr />
<p>微分的拉普拉斯变换</p>
<p>$$
\begin{align}
\mathcal{L}[\dot y(t)] &amp;= \int_0^{\infty}\dot y(\tau)e^{-s\tau}d\tau \\
&amp;= [y(\tau)e^{-s\tau}]_0^{\infty} - \int_0^{\infty}-sy(\tau)e^{-s\tau}d\tau \\
&amp;= [y(\tau)e^{-s\tau}]_0^{\infty} + s\int_0^{\infty}y(\tau)e^{-s\tau}d\tau \\
&amp;= y(\infty) -y(0) + s\mathcal{L}[y(t)] \\
&amp;= sy(s) - y(0)
\end{align}
$$</p>
<p>令 \(y(0) = 0\)，则得到 \(\mathcal{L}[\dot y(t)] = sy(s)\)</p>
<hr />
<p>积分的拉普拉斯变换</p>
<p>令 \(f(t) = \int_0^ty(\tau)d\tau\), 则 \(\dot f(t) = y(t)\)</p>
<p>$$
\begin{align}
\mathcal{L}[\dot f(t)] &amp;= sf(s) - f(0) \\
&amp;= sf(s) - \int_0^0y(\tau)d\tau \\
&amp;= sf(s)
\end{align}
$$</p>
<p>$$
\mathcal{L}[\int_0^ty(\tau)d\tau] = \mathcal{L}[f(t)] = f(s) = \frac{1}{s}\mathcal{L}[\dot f(t)] = \frac{1}{s}\mathcal{L}[y(t)] = \frac{1}{s}y(s)
$$</p>
<h3 id="状态空间"><a class="header" href="#状态空间">状态空间</a></h3>
<p>状态空间模型通过矩阵的形式将多元高阶微分方程表示成一阶微分方程的形式。传递函数模型表达的是输入和输出的关系，而状态空间模型表达的是输入-&gt;状态-&gt;输出的关系。我们可以自由地选择状态变量。此外，状态空间模型也可以处理初始值不为0的情况。</p>
<p>$$
\mathcal{P}:
\begin{cases}
\mathbf{\dot x}(t) &amp;= \mathbf{A} \mathbf{x}(t) + \mathbf{B} \mathbf{u}(t) \\
\mathbf{y}(t)      &amp;= \mathbf{C} \mathbf{x}(t) + \mathbf{D} \mathbf{u}(t)
\end{cases}
$$</p>
<p>这里的\(\mathbf{x}\)为状态，\(\mathbf{u}\)为输入，\(\mathbf{y}\)为输出，\(\mathbf{A}\), \(\mathbf{B}\), \(\mathbf{C}\), \(\mathbf{D}\)为常数矩阵。</p>
<h3 id="rlc-电路"><a class="header" href="#rlc-电路">RLC 电路</a></h3>
<p><img src="ee/../images/control/RLC.jpg" alt="RLC电路" /></p>
<p>根据欧姆定律，
$$
v_{in}(t) = L\frac{d}{dt}i(t) + Ri(t) + \frac{1}{C}\int_{0}^{t}i(\tau) d\tau
$$</p>
<p>设定输出为 \(y(t) = v_{out}(t) = \frac{1}{C}\int_{0}^{t}i(\tau) d\tau\), 则 \(C\dot y(t) = i(t)\)</p>
<p>设定输入为 \(u(t) = v_{in}(t)\)</p>
<p>可以得到
$$
LC\ddot y(t) + RC\dot y(t) + y(t) = u(t)
$$</p>
<h4 id="传递函数模型"><a class="header" href="#传递函数模型">传递函数模型</a></h4>
<p>对微分方程两边做拉普拉斯变换，得到
$$
LCs^2y(s) + RCsy(s) + y(s) = u(s)
$$</p>
<p>于是传递函数模型等于
$$
\mathcal{P} = \frac{y(s)}{u(s)} = \frac{1}{LCs^2 + RCs + 1}
$$</p>
<h4 id="状态空间模型"><a class="header" href="#状态空间模型">状态空间模型</a></h4>
<p>设 \(\mathbf{x}(t) = \left[ \begin{matrix}
\int_0^t i(\tau)d\tau \\
i(t) \\
\end{matrix} \right] \)， \(u(t) = v_{in}\)，\(y(t) = \frac{1}{C}\int_0^t i(\tau)d\tau\)</p>
<p>则状态方程为
$$
\mathbf{\dot x}(t) = \left[ \begin{matrix}
0&amp; 1 \\
-\frac{1}{LC}&amp; -\frac{R}{L} \\
\end{matrix}\right] \mathbf{x}(t) + \left[ \begin{matrix}
0 \\
\frac{1}{L} \\
\end{matrix} \right] u(t)
$$</p>
<p>而输出方程为
$$
y(t) = \left[ \begin{matrix}
\frac{1}{C} \quad 0
\end{matrix}\right] \mathbf{x}(t)
$$</p>
<h3 id="运放电路"><a class="header" href="#运放电路">运放电路</a></h3>
<p><img src="ee/../images/control/Opamp.jpg" alt="运放电路" /></p>
<p>根据运放的&quot;虚短&quot;特性，可以得到 \(i_1(t) = \frac{v_{in}(t)}{R_1}\), \(i_2(t) = \frac{v_{out}(t)}{R_2}\)</p>
<p>以及 \(v_{out}(t) = \frac{1}{C}\int_{0}^{\tau}i_3(\tau) d\tau\)， 即 \(i_3(t) = C\dot v_{out}\)</p>
<p>根据运放的&quot;虚断&quot;特性，\(i_1(t) + i_2(t) + i_3(t) = 0\)</p>
<p>代入方程得到
$$
\frac{v_{in}(t)}{R_1} + \frac{v_{out}(t)}{R_2} + C\dot v_{out}(t) = 0
$$</p>
<p>设定输出 \(y(t)=v_{out}(t)\), 设定输入 \(u(t)=v_{in}(t)\)</p>
<p>因此可以得到
$$R_1R_2C\dot y(t) + R_1y(t) = -R_2u(t)$$</p>
<h4 id="传递函数模型-1"><a class="header" href="#传递函数模型-1">传递函数模型</a></h4>
<p>对微分方程两边做拉普拉斯变换，得到 \(R_1R_2Csy(s) + R_1y(s) = -R_2u(s)\), 于是传递函数模型等于
$$
\mathcal{P} = \frac{y(s)}{u(s)} = \frac{-R_2}{R_1R_2Cs + R_1}
$$</p>
<h4 id="状态空间模型-1"><a class="header" href="#状态空间模型-1">状态空间模型</a></h4>
<p>设 \(x(t) = v_{out}(t), u(t)=v_{in}(t),y(t)=v_{out}(t)\)，则可得到状态方程
$$
\dot x(t) = -\frac{1}{CR_2}x(t) - \frac{1}{CR_1}u(t)
$$
输出方程为
$$
y(t)=x(t)
$$</p>
<h2 id="一阶滞后系统的阶跃响应"><a class="header" href="#一阶滞后系统的阶跃响应">一阶滞后系统的阶跃响应</a></h2>
<p>一阶滞后系统的传递函数模型可以表示为：
$$
\mathcal{P}(s) = \frac{K}{Ts + 1}
$$
\(K\) 是滞后系统的<strong>增益</strong>，\(T\) 是滞后系统的<strong>时间常数</strong>。
时间常数指的是达到稳定值的 63.2% 时所需的时间，它决定了系统的响应速度。</p>
<p><img src="ee/../images/control/step-response-first-order-system.png" alt="一阶滞后系统的阶跃响应" /></p>
<h3 id="推导一阶滞后系统在时域上的阶跃响应"><a class="header" href="#推导一阶滞后系统在时域上的阶跃响应">推导一阶滞后系统在时域上的阶跃响应</a></h3>
<p>$$
y(s) = \frac{K}{Ts+1}\frac{1}{s} = K(\frac{1}{s} - \frac{T}{Ts+1}) = K(\frac{1}{s} - \frac{1}{s+\frac{1}{T}})
$$</p>
<p>对其进行拉普拉斯逆变换得到
$$
y(t) = K(1-e^{-\frac{1}{T}t})
$$</p>
<p>当 T &gt; 0 时，\(y(\infty)=K, y(T)=1-e^{-1}=0.632\)</p>
<h2 id="二阶滞后系统的阶跃响应"><a class="header" href="#二阶滞后系统的阶跃响应">二阶滞后系统的阶跃响应</a></h2>
<p>二阶滞后系统的传递函数模型可以表示为：
$$
\mathcal{P}(s) = \frac{K\omega_n^2}{s^2+2\zeta\omega_ns+\omega_n^2}
$$
\(\zeta\)称为<strong>阻尼系数</strong>，\(\omega_n\)称为<strong>无阻尼自然振荡频率</strong>。</p>
<p><img src="ee/../images/control/step-response-second-order-system.png" alt="二阶滞后系统的阶跃响应" /></p>
<p>阻尼系数是确定阻尼特性（稳定度）的参数:</p>
<ul>
<li>当\(\zeta\) 为负值时，输出会发散</li>
<li>当\(\zeta\) 为正值时，输出会收敛于稳定值:
<ul>
<li>当\(0&lt;\zeta&lt;1\)时，系统振荡而收敛，在 \(T_p = \frac{\pi}{\omega_n \sqrt{1-\zeta^2}}\)处取得最大值 \(y_{max}=K(1+e^{-\zeta\omega_nT_p})\)</li>
<li>当\(\zeta \geq 1\)时系统不振荡而收敛</li>
</ul>
</li>
</ul>
<p>无阻尼自然振荡频率\(\omega_n\)类似于一阶滞后系统中的时间常数T,决定了响应速度的快慢。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pytest-基础"><a class="header" href="#pytest-基础">pytest 基础</a></h1>
<h2 id="常用命令行选项"><a class="header" href="#常用命令行选项">常用命令行选项</a></h2>
<ul>
<li>
<p><code>--collect-only</code>：展示在给定的配置下哪些测试用例会被运行</p>
</li>
<li>
<p><code>-k</code>：使用表达式指定要运行的测试用例，表达式可以匹配测试名，且表达式中可以包含 <code>and</code>,<code>or</code>,<code>not</code> 关键字</p>
<pre><code class="language-text">➤ pytest -v --collect-only -k &quot;replace or asdict&quot;

&lt;Package tests&gt;
  &lt;Module test_named_tuple.py&gt;
    &lt;Function test_asdict&gt;
      _asdict() should return a dictionary.
    &lt;Function test_replace&gt;
      replace() should change passed in fields.
</code></pre>
</li>
<li>
<p><code>-m</code>：标记测试并分组，以便快速选中并运行，可以同时指定多个标记，标记之间可以使用 <code>and</code>,<code>or</code>,<code>not</code> 关键字</p>
</li>
<li>
<p><code>-s</code>：允许终端在测试运行时输出某些结果，包括任何符合标准的输出流信息，等价于 <code>--capture=no</code></p>
</li>
<li>
<p><code>--markers</code>：列出所有可用的 marker</p>
</li>
<li>
<p><code>--fixtures</code>：列出所有可用的 fixture</p>
</li>
<li>
<p><code>--setup-show</code>：显示测试用例的 setup 和 teardown 过程</p>
</li>
<li>
<p><code>--durations=0</code>：将所有阶段的耗时从长到短排序</p>
</li>
<li>
<p><code>-l</code>：显示失败的测试用例的局部变量</p>
</li>
<li>
<p><code>-x</code>：遇到失败的测试用例时停止运行</p>
</li>
<li>
<p><code>--lf, --last-failed</code>：只运行上次失败的测试用例，如果没有失败的测试用例，则运行所有测试用例</p>
</li>
<li>
<p><code>--ff, --failed-first</code>：先运行上次失败的测试用例，然后再运行其他测试用例</p>
</li>
<li>
<p><code>--cache-show</code>：显示缓存的内容（可用于多个测试会话之间共享）</p>
</li>
<li>
<p><code>--cache-clear</code>：清除缓存</p>
</li>
<li>
<p><code>--pdb</code>：遇到失败的测试用例时进入调试模式</p>
</li>
<li>
<p><code>--tb=[auto/long/short/line/native/no]</code>：指定发生错误时堆栈回溯信息的粒度</p>
</li>
<li>
<p><code>--junit-xml</code>：将测试结果输出为 junit 格式的 xml 文件</p>
</li>
</ul>
<h2 id="测试搜索"><a class="header" href="#测试搜索">测试搜索</a></h2>
<p>pytest 能自动搜索所有待执行的测试用例，你需要遵守以下几条命名规则：</p>
<ul>
<li>测试文件应该命名为 <code>test_*.py</code> 或者 <code>*_test.py</code></li>
<li>测试函数、测试类方法应当命名为 <code>test_&lt;something&gt;</code></li>
<li>测试类要命名为 <code>Test&lt;Something&gt;</code></li>
<li>默认的测试搜索规则可以在 <code>pytest.ini</code> 中进行修改</li>
</ul>
<h2 id="编写测试函数"><a class="header" href="#编写测试函数">编写测试函数</a></h2>
<ul>
<li>
<p>pytest 会截断对原生 <code>assert</code> 的调用，替换为 pytest 定义的 <code>assert</code></p>
</li>
<li>
<p>使用 <code>with pytest.raises(Exception):</code> 来断言异常</p>
<pre><code class="language-python">def test_start_tasks_db_raises():
  &quot;&quot;&quot;Make sure unsupported db raises an exception.&quot;&quot;&quot;
  with pytest.raises(ValueError) as exc_info:
      tasks.start_tasks_db(&quot;some/great/path&quot;, &quot;mysql&quot;)
  exception_msg = exc_info.value.args[0]
  assert exc_info.type == ValueError
  assert exception_msg == &quot;db_type must be a 'tiny' or 'mongo'&quot;
</code></pre>
</li>
<li>
<p>使用 <code>pytest.approx</code> 来断言浮点数</p>
<pre><code class="language-python">def test_approx():
  &quot;&quot;&quot;Using pytest.approx.&quot;&quot;&quot;
  v1 = 0.1 + 0.2
  v2 = 0.3
  assert v1 != v2
  assert v1 == pytest.approx(v2)
</code></pre>
</li>
<li>
<p>使用 <code>@pytest.mark.skip</code> 和 <code>@pytest.mark.skipif</code> 装时期来跳过不希望运行的测试</p>
</li>
<li>
<p>使用 <code>@pytest.mark.xfail</code> 装饰器来标记预期失败的测试</p>
<pre><code class="language-python">@pytest.mark.xfail(
    sys.platform == &quot;win32&quot;,
    reason=&quot;can't run on Windows&quot;
)
def test_unique_id_is_a_duck():
    &quot;&quot;&quot;Demonstrate xfail&quot;&quot;&quot;
    uid = tasks.unique_id()
    assert uid == &quot;a duck&quot;
</code></pre>
</li>
<li>
<p>使用 <code>@pytest.mark.parametrize(argnames, argvalues)</code> 装饰器来运行相同测试用例的不同参数组合, <code>parametrize()</code> 的第一个参数是<strong>用逗号分隔的字符串列表</strong>，第二个参数是<strong>值列表</strong></p>
<pre><code class="language-python">@pytest.mark.parametrize(
    &quot;summary, owner, done&quot;,
    [
        (&quot;sleep&quot;, None, False),
        (&quot;wake&quot;, &quot;brian&quot;, False),
        (&quot;breath&quot;, &quot;iris&quot;, True),
        (&quot;eat&quot;, &quot;bob&quot;, True),
    ],
)
def test_add_variety(summary, owner, done):
    &quot;&quot;&quot;Demonstrate parameterize with 3 parameters.&quot;&quot;&quot;
    new_task = Task(summary, owner, done)
    task_id = tasks.add(new_task)
    task_from_db = tasks.get(task_id)
    assert equivalent(new_task, task_from_db)
</code></pre>
</li>
<li>
<p><code>parametrize()</code> 还可以通过 <code>ids</code> 参数来指定每个参数组合的名字, <code>ids</code> 参数的值是一个字符串列表，长度必须和 <code>argvalues</code> 参数的长度一致</p>
<pre><code class="language-python">tasks_to_try = (
  Task(&quot;sleep&quot;, None, True),
  Task(&quot;wake&quot;, &quot;brian&quot;, False),
  Task(&quot;breathe&quot;, &quot;bob&quot;, True),
  Task(&quot;exercise&quot;, &quot;iris&quot;, False),
)
task_ids = [f&quot;Task({t.summary},{t.owner},{t.done})&quot; for t in tasks_to_try]


@pytest.mark.parametrize(&quot;task&quot;, tasks_to_try, ids=task_ids)
def test_add_variety(task):
    &quot;&quot;&quot;Demonstrate parameterize with 3 parameters.&quot;&quot;&quot;
    task_id = tasks.add(task)
    task_from_db = tasks.get(task_id)
    assert equivalent(task, task_from_db)
</code></pre>
</li>
<li>
<p>当 <code>ids</code> 不能被参数化批量生成时，需要自定义的时候，可以给每个参数值定义一个 <code>id</code> 来做标识: <code>pytest.param(&lt;value&gt;, id=&quot;something&quot;)</code></p>
<pre><code class="language-python">@pytest.mark.parametrize(
    &quot;task&quot;,
    [
        pytest.param(Task(&quot;sleep&quot;)),
        pytest.param(Task(&quot;wake&quot;, &quot;brian&quot;), id=&quot;summary/owner&quot;),
        pytest.param(Task(&quot;breathe&quot;, &quot;BRIAN&quot;, True), id=&quot;summary/owner/done&quot;),
    ],
)
def test_add_variety(task):
    &quot;&quot;&quot;Demonstrate parameterize with 3 parameters.&quot;&quot;&quot;
    task_id = tasks.add(task)
    task_from_db = tasks.get(task_id)
    assert equivalent(task, task_from_db)
</code></pre>
<p>运行结果:</p>
<pre><code class="language-bash">test_add.py::test_add_variety[task0] PASSED # 因为没有添加id标识，所以可读性不好
test_add.py::test_add_variety[summary/owner] PASSED
test_add.py::test_add_variety[summary/owner/done] PASSED
</code></pre>
</li>
</ul>
<h2 id="fixture"><a class="header" href="#fixture">Fixture</a></h2>
<ul>
<li>
<p>Fixture 是一种特殊的函数，在测试函数运行前后，由 pytest 执行的外壳函数，通常用来做一些准备工作，比如创建数据库连接，创建临时文件等。</p>
<pre><code class="language-python">@pytest.fixture()
def some_data():
    return 42


def test_some_data(some_data):
    assert some_data == 42
</code></pre>
</li>
<li>
<p>多个 fixture 之间可以相互依赖，比如一个 fixture 依赖另一个 fixture，这时可以在 fixture 函数的参数列表中添加依赖的 fixture 函数</p>
<pre><code class="language-python">@pytest.fixture()
def db_with_3_tasks(tasks_db, tasks_just_a_few):
    &quot;&quot;&quot;Connected db with 3 tasks, all unique&quot;&quot;&quot;
    for t in tasks_just_a_few:
        tasks.add(t)

def test_add_increases_count(db_with_3_tasks):
  tasks.add(Task(&quot;throw a party&quot;))
  assert tasks.count() == 4
</code></pre>
</li>
<li>
<p>使用 <code>usefixtures</code> 为测试类指定 fixture，这种方法<strong>不能</strong>够使用 fixture 函数的返回值</p>
<pre><code class="language-python">@pytest.mark.usefixtures(&quot;tasks_db&quot;)
class TestAdd:
    &quot;&quot;&quot;Using a fixture for setup and teardown.&quot;&quot;&quot;

    def test_add_increases_count(self):
        &quot;&quot;&quot;tasks.add() affect tasks.count().&quot;&quot;&quot;
        tasks.add(Task(&quot;throw a party&quot;))
        assert tasks.count() == 1
</code></pre>
</li>
<li>
<p>通过 <code>scope</code> 参数指定 fixture 的作用范围（也可以理解为控制 fixture 执行 setup 和 teardown 的频率），<code>scope</code> 参数的值可以是 <code>function</code>、<code>class</code>、<code>module</code>、<code>session</code>，默认值是 <code>function</code>。fixture 只能使用同级别的 fixture 或者比自己级别更高的 fixture。</p>
<pre><code class="language-python">@pytest.fixture(scope=&quot;session&quot;)
def tasks_db(tmpdir_factory):
    &quot;&quot;&quot;Connect to db before testing, disconnect after.&quot;&quot;&quot;
    tmp_dir = tmpdir_factory.mktemp(&quot;temp&quot;)
    tasks.start_tasks_db(str(tmp_dir), &quot;tiny&quot;)
    yield
    tasks.stop_tasks_db()
</code></pre>
</li>
<li>
<p>可以为常用 fixture 添加 <code>autouse=True</code> 选项，使得作用域内的测试函数自动运行该 fixture</p>
</li>
<li>
<p>可以设置 <code>name</code> 参数来重命名 fixture</p>
</li>
<li>
<p>对测试函数进行参数化，可以多次运行的只是该测试函数。而使用<strong>参数化</strong> fixture,每个使用该 fixture 的测试函数都可以被运行多次</p>
<pre><code class="language-python">tasks_to_try = [
    pytest.param(Task(&quot;sleep&quot;)),
    pytest.param(Task(&quot;wake&quot;, &quot;brian&quot;)),
    pytest.param(Task(&quot;breathe&quot;, &quot;BRIAN&quot;, True)),
]


def id_func(task: Task):
    &quot;&quot;&quot;Create a string representation for test report.&quot;&quot;&quot;
    return f&quot;({task.summary},{task.owner},{task.done})&quot;


@pytest.fixture(params=tasks_to_try, ids=id_func)
def a_task(request):
    &quot;&quot;&quot;Using a fixture to pass data to a test.&quot;&quot;&quot;
    return request.param


def test_add_variety(a_task):
    &quot;&quot;&quot;Demonstrate parameterize with 3 parameters.&quot;&quot;&quot;
    task_id = tasks.add(a_task)
    task_from_db = tasks.get(task_id)
    assert equivalent(a_task, task_from_db)
</code></pre>
<p><code>ids</code> 参数可以指定为一个函数，供 pytest 针对每个参数生成标识</p>
</li>
</ul>
<h3 id="内置-fixture"><a class="header" href="#内置-fixture">内置 Fixture</a></h3>
<h4 id="tmpdir-和-tmpdir_factory"><a class="header" href="#tmpdir-和-tmpdir_factory">tmpdir 和 tmpdir_factory</a></h4>
<pre><code class="language-python">def test_tmpdir(tmpdir):
    print(tmpdir.realpath)
    # tmpdir already has a path name associated with it
    # join() extends the path to include a filename
    # the file is created when it's written to
    # tmpdir is a py.path.local object
    a_file = tmpdir.join(&quot;something.txt&quot;)

    # you can create directories
    a_sub_dir = tmpdir.mkdir(&quot;anything&quot;)

    # you can create files in the directory (created when written)
    another_file = a_sub_dir.join(&quot;something_else.txt&quot;)

    # this write creates &quot;something.txt&quot;
    a_file.write(&quot;contents may settle during shipping&quot;)

    # this write creates &quot;anything/something_else.txt&quot;
    another_file.write(&quot;something different&quot;)

    assert a_file.read() == &quot;contents may settle during shipping&quot;
    assert another_file.read() == &quot;something different&quot;
</code></pre>
<pre><code class="language-python">def test_tmpdir_factor(tmpdir_factory):
    print(tmpdir_factory.getbasetemp())

    # you should start with making a directory
    # a_dir acts like the object returned from the tmpdir fixture
    a_dir = tmpdir_factory.mktemp(&quot;mydir&quot;)
    a_file = a_dir.join(&quot;something.txt&quot;)

    # you can create directories
    a_sub_dir = a_dir.mkdir(&quot;anything&quot;)

    # you can create files in the directory (created when written)
    another_file = a_sub_dir.join(&quot;something_else.txt&quot;)

    # this write creates &quot;something.txt&quot;
    a_file.write(&quot;contents may settle during shipping&quot;)

    # this write creates &quot;anything/something_else.txt&quot;
    another_file.write(&quot;something different&quot;)

    assert a_file.read() == &quot;contents may settle during shipping&quot;
    assert another_file.read() == &quot;something different&quot;
</code></pre>
<p><code>tmpdir_factory</code> 的作用范围是会话级别，<code>tmpdir</code> 的作用范围是函数级别。如果需要模块或者类级别作用范围的目录，可以利用 <code>tmpdir_factory</code> 再创建一个 fixture。</p>
<pre><code class="language-python">@pytest.fixture(scope=&quot;module&quot;)
def my_tmpdir(tmpdir_factory):
    pass
</code></pre>
<h4 id="pytestconfig"><a class="header" href="#pytestconfig">pytestconfig</a></h4>
<p><code>pytestconfig</code> 是 <code>request.config</code> 的快捷方式，可以通过 <code>pytestconfig.getoption()</code> 获取命令行选项。</p>
<pre><code class="language-python">def test_option(pytestconfig):
    print(f&quot;args: {pytestconfig.args}&quot;)
    print(f&quot;invocation_dir: {pytestconfig.invocation_dir}&quot;)
    print(f&quot;rootdir: {pytestconfig.rootdir}&quot;)
    print(f&quot;inifile: {pytestconfig.inifile}&quot;)
    print(f&quot;basetemp: {pytestconfig.getoption('basetemp')}&quot;)
    print(f&quot;-k EXPRESSION: {pytestconfig.getoption('keyword')}&quot;)
    print(f&quot;-v, --verbose: {pytestconfig.getoption('verbose')}&quot;)
    print(f&quot;--tb style: {pytestconfig.getoption('tbstyle')}&quot;)
</code></pre>
<p>也可以基于 <code>pytestconfig</code> 创建新的 fixture</p>
<pre><code class="language-python">@pytest.fixture()
def foo(pytestconfig):
    return pytestconfig.option.foo


def test_option(foo):
    print(&quot;foo: {}&quot;.format(foo))
</code></pre>
<h4 id="cache-1"><a class="header" href="#cache-1">cache</a></h4>
<p>cache 的作用是存储一段测试会话的信息，在下一段测试会话中使用。<code>cache</code>的接口主要有两个：<code>cache.get(key, default)</code> 和 <code>cache.set(key, value)</code>。</p>
<p>习惯上，键名以应用名字或插件名字开始，接着是<code>/</code>，然后是分隔开的键字符串。键值可以是任何可以转换成 JSON 的对象。</p>
<pre><code class="language-python">Duration = namedtuple(&quot;Duration&quot;, [&quot;current&quot;, &quot;last&quot;])


@pytest.fixture(scope=&quot;session&quot;)
def duration_cache(request):
    key = &quot;duration/test_durations&quot;
    d = Duration({}, request.config.cache.get(key, {}))
    yield d
    request.config.cache.set(key, d.current)


@pytest.fixture(autouse=True)
def check_duration(request, duration_cache):
    d = duration_cache
    nodeid = request.node.nodeid  # nodeid is a unique identifier for the test
    start_time = datetime.datetime.now()
    yield
    duration = (datetime.datetime.now() - start_time).total_seconds()
    d.current[nodeid] = duration
    if d.last.get(nodeid, None) is not None:
        errorstring = &quot;test duration over 2x last duration&quot;
        assert duration &lt;= (d.last[nodeid] * 2), errorstring


@pytest.mark.parametrize(&quot;i&quot;, range(5))
def test_slow_stuff(i):
    time.sleep(random.random())
</code></pre>
<pre><code class="language-text">➤ pytest --cache-show
================ test session starts ================
platform linux -- Python 3.10.7, pytest-7.1.2, pluggy-1.0.0
rootdir: /home/morris/tasks/tests
cachedir: /home/morris/tasks/tests/.pytest_cache
---------------- cache values for '*' ----------------
duration/test_durations contains:
  {'test_cache.py::test_slow_stuff[0]': 0.133439,
   'test_cache.py::test_slow_stuff[1]': 0.569769,
   'test_cache.py::test_slow_stuff[2]': 0.7625,
   'test_cache.py::test_slow_stuff[3]': 0.930151,
   'test_cache.py::test_slow_stuff[4]': 0.748842}
</code></pre>
<p>同时也能看到被 <code>cache</code> 的数据保存在 <code>.pytest_cache</code> 目录下。</p>
<h4 id="capsys"><a class="header" href="#capsys">capsys</a></h4>
<ul>
<li>
<p><code>capsys.readouterr()</code>：返回一个包含 <code>out</code> 和 <code>err</code> 的 <code>namedtuple</code>，分别是标准输出和标准错误的内容</p>
<pre><code class="language-python">def test_capsys(capsys):
    print(&quot;hello&quot;)
    print(&quot;world&quot;, file=sys.stderr)
    out, err = capsys.readouterr()
    assert out == &quot;hello\n&quot;
    assert err == &quot;world\n&quot;
</code></pre>
</li>
<li>
<p>临时让输出绕过默认的输出捕获机制，可以使用 <code>capsys.disabled()</code> 上下文管理器</p>
<pre><code class="language-python">def test_capsys_disabled(capsys):
    with capsys.disabled():
        print(&quot;always print this&quot;)
    print(&quot;normal print, usually captured&quot;)
</code></pre>
</li>
</ul>
<h4 id="monkeypatch"><a class="header" href="#monkeypatch">monkeypatch</a></h4>
<p>monkeypatch 可以在运行期间对类或模块进行同态修改，比如修改环境变量、修改类属性、修改模块属性等。</p>
<ul>
<li>
<p>setattr(target, name, value, raising=True)：修改对象的属性值</p>
<pre><code class="language-python">def test_setattr(monkeypatch):
    class A:
        a = 1

    monkeypatch.setattr(A, &quot;a&quot;, 2)
    assert A.a == 2
</code></pre>
</li>
<li>
<p>delattr(target, name, raising=True)：删除对象的属性</p>
<pre><code class="language-python">def test_delattr(monkeypatch):
    class A:
        a = 1

    monkeypatch.delattr(A, &quot;a&quot;)
    assert not hasattr(A, &quot;a&quot;)
</code></pre>
</li>
<li>
<p>setitem(mapping, name, value)：修改字典的值</p>
<pre><code class="language-python">def test_setitem(monkeypatch):
    d = {&quot;a&quot;: 1}
    monkeypatch.setitem(d, &quot;a&quot;, 2)
    assert d[&quot;a&quot;] == 2
</code></pre>
</li>
<li>
<p>delitem(obj, name, raising=True)：删除字典的值</p>
<pre><code class="language-python">def test_delitem(monkeypatch):
    d = {&quot;a&quot;: 1}
    monkeypatch.delitem(d, &quot;a&quot;)
    assert &quot;a&quot; not in d
</code></pre>
</li>
<li>
<p>setenv(name, value, prepend=False)：修改环境变量</p>
<pre><code class="language-python">def test_setenv(monkeypatch):
    monkeypatch.setenv(&quot;foo&quot;, &quot;bar&quot;)
    assert os.environ[&quot;foo&quot;] == &quot;bar&quot;
</code></pre>
</li>
<li>
<p>delenv(name, raising=True)：删除环境变量</p>
<pre><code class="language-python">def test_delenv(monkeypatch):
    monkeypatch.setenv(&quot;foo&quot;, &quot;bar&quot;)
    monkeypatch.delenv(&quot;foo&quot;)
    assert &quot;foo&quot; not in os.environ
</code></pre>
</li>
<li>
<p>syspath_prepend(path)：在 <code>sys.path</code> 的开头添加路径，<code>sys.path</code> 是 Python 模块的搜索路径</p>
<pre><code class="language-python">def test_syspath_prepend(monkeypatch):
    monkeypatch.syspath_prepend(&quot;/foo&quot;)
    assert sys.path[0] == &quot;/foo&quot;
</code></pre>
</li>
<li>
<p>chdir(path)：修改当前工作目录</p>
<pre><code class="language-python">def test_chdir(monkeypatch):
    monkeypatch.chdir(&quot;/tmp&quot;)
    assert os.getcwd() == &quot;/tmp&quot;
</code></pre>
</li>
</ul>
<h4 id="recwarn"><a class="header" href="#recwarn">recwarn</a></h4>
<p>recwarn 用来检查待测代码产生的警告信息。</p>
<pre><code class="language-python">def test_recwarn(recwarn):
    warnings.warn(&quot;Please stop using this function&quot;, DeprecationWarning)
    assert len(recwarn) == 1
    w = recwarn.pop()
    assert w.category == DeprecationWarning
    assert str(w.message) == &quot;Please stop using this function&quot;
</code></pre>
<p>pytest 还可以使用 <code>pytest.warns</code> 来检查警告信息。</p>
<pre><code class="language-python">def lame_function():
    warnings.warn(&quot;Please stop using this&quot;, DeprecationWarning)


def test_lame_function():
    with pytest.warns(DeprecationWarning) as warning_list:
        lame_function()

    assert len(warning_list) == 1
    w = warning_list.pop()
    assert w.category == DeprecationWarning
    assert str(w.message) == &quot;Please stop using this&quot;
</code></pre>
<h2 id="插件"><a class="header" href="#插件">插件</a></h2>
<h3 id="寻找插件"><a class="header" href="#寻找插件">寻找插件</a></h3>
<ul>
<li><a href="https://docs.pytest.org/en/latest/reference/plugin_list.html#plugin-list">https://docs.pytest.org/en/latest/reference/plugin_list.html#plugin-list</a></li>
</ul>
<h3 id="编写插件"><a class="header" href="#编写插件">编写插件</a></h3>
<ul>
<li>
<p>使用 <code>pytest_addoption</code> 可以给 pytest 添加额外的命令行选项</p>
<pre><code class="language-python">def pytest_addoption(parser):
    parser.addoption(
        &quot;--myopt&quot;,
        action=&quot;store_true&quot;,
        help=&quot;some boolean option&quot;,
    )
    parser.addoption(
        &quot;--foo&quot;,
        action=&quot;store&quot;,
        default=&quot;bar&quot;,
        help=&quot;foo: bar or baz&quot;,
    )
</code></pre>
<p>或者不通过命令行参数，使用 <code>pytest.ini</code> 文件做自定义的配置</p>
<pre><code class="language-python">def pytest_addoption(parser):
    parser.addini(
        &quot;myopt&quot;,
        type=&quot;bool&quot;,
        default=False,
        help=&quot;some boolean option&quot;,
    )
    parser.addini(
        &quot;foo&quot;,
        type=&quot;string&quot;,
        default=&quot;bar&quot;,
        help=&quot;foo: bar or baz&quot;,
</code></pre>
</li>
<li>
<p>使用 <code>pytest_report_header</code> 可以在测试报告的 header 中添加额外的信息</p>
<pre><code class="language-python">def pytest_report_header(config):
    return &quot;🍎🍎🍎🍎🍎🍎🍎🍎🍎&quot;
</code></pre>
</li>
<li>
<p>使用 <code>pytest_report_teststatus</code> 可以修改测试报告中的测试状态</p>
<pre><code class="language-python">def pytest_report_teststatus(report):
    if report.when == &quot;call&quot; and report.failed:
        return report.outcome, &quot;💥&quot;, &quot;💥&quot;
</code></pre>
</li>
</ul>
<h3 id="测试插件"><a class="header" href="#测试插件">测试插件</a></h3>
<ul>
<li>
<p>开启 <code>pytester</code> 插件，在 conftest.py 中添加 <code>pytest_plugins = [&quot;pytester&quot;]</code></p>
</li>
<li>
<p>使用 <code>pytester</code> 来测试插件</p>
<pre><code class="language-python">@pytest.fixture()
def sample_test(testdir):
    testdir.makepyfile(
        &quot;&quot;&quot;
        def test_sample():
            assert True
        &quot;&quot;&quot;
    )
    return testdir


def test_verbose(sample_test):
    result = sample_test.runpytest(&quot;-v&quot;)
    result.stdout.fnmatch_lines([&quot;*::test_sample PASSED*&quot;])
    result.assert_outcomes(passed=1)
</code></pre>
<p><code>testdir</code> 自动创建了一个临时目录用来存放测试文件</p>
</li>
</ul>
<h3 id="常用插件"><a class="header" href="#常用插件">常用插件</a></h3>
<h4 id="pytest-cov"><a class="header" href="#pytest-cov">pytest-cov</a></h4>
<p>报告测试覆盖率</p>
<ul>
<li>安装：<code>pip install pytest-cov</code></li>
<li>使用：<code>pytest --cov=src --cov-report=html tests</code></li>
</ul>
<h4 id="pytest-mock"><a class="header" href="#pytest-mock">pytest-mock</a></h4>
<p>替换系统的某个部分以隔离要测试的代码</p>
<ul>
<li>
<p>安装：<code>pip install pytest-mock</code></p>
</li>
<li>
<p>使用</p>
<pre><code class="language-python">def test_mock(mocker):
    mocker.patch(&quot;os.path.exists&quot;, return_value=True)
    assert os.path.exists(&quot;/tmp&quot;)
</code></pre>
</li>
</ul>
<h4 id="pytest-xdist"><a class="header" href="#pytest-xdist">pytest-xdist</a></h4>
<p>通常，测试都是依次执行的，因为有些资源一次只能被一个测试用例访问。如果你的测试不需要访问共享资源，可以通过并行运行来提速</p>
<ul>
<li>安装：<code>pip install pytest-xdist</code></li>
<li>使用：<code>pytest -n auto</code></li>
</ul>
<h4 id="pytest-benchmark"><a class="header" href="#pytest-benchmark">pytest-benchmark</a></h4>
<p>测试代码的性能</p>
<ul>
<li>
<p>安装：<code>pip install pytest-benchmark</code></p>
</li>
<li>
<p>使用</p>
<pre><code class="language-python">def test_benchmark(benchmark):
    benchmark.pedantic(lambda: 1 + 1, iterations=100, rounds=100)
</code></pre>
</li>
</ul>
<h4 id="pytest-repeat"><a class="header" href="#pytest-repeat">pytest-repeat</a></h4>
<p>重复运行测试</p>
<ul>
<li>安装：<code>pip install pytest-repeat</code></li>
<li>使用：<code>pytest --count=3</code></li>
</ul>
<h4 id="pytest-rerunfailures"><a class="header" href="#pytest-rerunfailures">pytest-rerunfailures</a></h4>
<p>失败的测试重跑</p>
<ul>
<li>安装：<code>pip install pytest-rerunfailures</code></li>
<li>使用：<code>pytest --reruns=3</code></li>
</ul>
<h4 id="pytest-timeout"><a class="header" href="#pytest-timeout">pytest-timeout</a></h4>
<p>设置测试的超时时间（正常情况下，pytest 里的测试是没有时间限制的）</p>
<ul>
<li>安装：<code>pip install pytest-timeout</code></li>
<li>使用：<code>pytest --timeout=10</code></li>
<li>或者在代码中使用 <code>@pytest.mark.timeout(10)</code> 来设置单个测试的超时时间</li>
</ul>
<h4 id="pytest-instafail"><a class="header" href="#pytest-instafail">pytest-instafail</a></h4>
<p>测试失败时立即输出堆栈回溯信息，而不是等到所有测试都执行完毕</p>
<ul>
<li>安装：<code>pip install pytest-instafail</code></li>
<li>使用：<code>pytest --instafail</code></li>
</ul>
<h4 id="pytest-sugar"><a class="header" href="#pytest-sugar">pytest-sugar</a></h4>
<p>显示彩色和进度条</p>
<ul>
<li>安装：<code>pip install pytest-sugar</code></li>
<li>使用：<code>pytest --sugar</code></li>
</ul>
<h4 id="pytest-emoji"><a class="header" href="#pytest-emoji">pytest-emoji</a></h4>
<p>显示 emoji</p>
<ul>
<li>安装：<code>pip install pytest-emoji</code></li>
<li>使用：<code>pytest --emoji</code></li>
</ul>
<h4 id="pytest-html"><a class="header" href="#pytest-html">pytest-html</a></h4>
<p>生成 html 报告</p>
<ul>
<li>安装：<code>pip install pytest-html</code></li>
<li>使用：<code>pytest --html=report.html</code></li>
</ul>
<h4 id="pytest-flake8"><a class="header" href="#pytest-flake8">pytest-flake8</a></h4>
<p>检查代码风格</p>
<ul>
<li>安装：<code>pip install pytest-flake8</code></li>
<li>使用：<code>pytest --flake8</code></li>
</ul>
<h4 id="pytest-selenium"><a class="header" href="#pytest-selenium">pytest-selenium</a></h4>
<p>借助浏览器完成自动化测试</p>
<ul>
<li>
<p>安装：<code>pip install pytest-selenium</code></p>
</li>
<li>
<p>使用</p>
<pre><code class="language-python">def test_selenium(selenium):
    selenium.get(&quot;https://www.baidu.com&quot;)
    selenium.find_element_by_id(&quot;kw&quot;).send_keys(&quot;pytest&quot;)
    selenium.find_element_by_id(&quot;su&quot;).click()
    assert &quot;pytest&quot; in selenium.title
</code></pre>
</li>
</ul>
<h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<h3 id="pytestini"><a class="header" href="#pytestini">pytest.ini</a></h3>
<p>它是 pytest 的主配置文件，可以在项目根目录下创建该文件，也可以在 <code>~/.config/pytest.ini</code> 中创建全局配置文件</p>
<h4 id="修改默认命令行选项"><a class="header" href="#修改默认命令行选项">修改默认命令行选项</a></h4>
<pre><code class="language-ini">[pytest]
addopts = -s --tb=short --strict-markers
</code></pre>
<h4 id="注册标记"><a class="header" href="#注册标记">注册标记</a></h4>
<pre><code class="language-ini">[pytest]
markers =
    smoke: smoke test
    regression: regression test
</code></pre>
<h4 id="忽略那些不需要递归搜索的目录"><a class="header" href="#忽略那些不需要递归搜索的目录">忽略那些不需要递归搜索的目录</a></h4>
<pre><code class="language-ini">[pytest]
norecursedirs = .* venv *.egg dist build
</code></pre>
<h4 id="指定测试目录"><a class="header" href="#指定测试目录">指定测试目录</a></h4>
<pre><code class="language-ini">[pytest]
testpaths = tests
</code></pre>
<h4 id="更改测试搜索的规则"><a class="header" href="#更改测试搜索的规则">更改测试搜索的规则</a></h4>
<pre><code class="language-ini">[pytest]
python_files = test_*.py *_test.py pytest_*.py check_*.py
python_classes = Tests* *Test *Suite
python_functions = test_* check_*
</code></pre>
<h4 id="禁用-xpass"><a class="header" href="#禁用-xpass">禁用 xpass</a></h4>
<p>那些被标记为 <code>@pytest.mark.xfail</code> 但实际通过的测试用例也被报告为失败</p>
<pre><code class="language-ini">[pytest]
xfail_strict = true
</code></pre>
<h3 id="conftestpy"><a class="header" href="#conftestpy">conftest.py</a></h3>
<p>它是本地插件库，其中的 hook 函数和 fixture 将作用于该文件所在的目录以及所有子目录</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="视频处理"><a class="header" href="#视频处理">视频处理</a></h1>
<p><img src="cs/../images/video-process/video-process-flow.jpg" alt="视频处理工作流程" /></p>
<h2 id="图像的基本概念"><a class="header" href="#图像的基本概念">图像的基本概念</a></h2>
<p><img src="cs/../images/video-process/image-basis.jpg" alt="视频图像基础" /></p>
<ul>
<li>存取一幅图像需要特别注意 Stride 这个参数，它跟分辨率中的 Width 是不一样的。为了快速存取，往往会选择以内存对齐的方式存储一行像素（比如 16 字节）。</li>
</ul>
<h3 id="color-range"><a class="header" href="#color-range">Color Range</a></h3>
<p>对于一个 8bit 的 RGB 图像，<strong>Full Range</strong> 的 R、G、B 取值范围是 0~255， 而 <strong>Limited Range</strong> 的 R、G、B 取值范围是 16~235。</p>
<h2 id="颜色空间"><a class="header" href="#颜色空间">颜色空间</a></h2>
<h3 id="rgb"><a class="header" href="#rgb">RGB</a></h3>
<p><img src="cs/../images/video-process/RGB-format.png" alt="RGB存储格式" /></p>
<ul>
<li>OpenCV 使用的是 BGR 格式，而不是 RGB。</li>
<li>RGB 三个颜色是有<strong>相关性</strong>的，所以不太方便做图像压缩编码。</li>
<li>RGB 颜色空间更适合图像采集和显示。</li>
</ul>
<h3 id="yuv"><a class="header" href="#yuv">YUV</a></h3>
<p>YUV 图像将亮度信息 Y 与色彩信息 U、V 分离开来。Y 表示亮度(Luma)，是图像的总体轮廓，U、V 表示色度(Chroma)，主要描绘图像的色彩等信息。YUV 颜色空间更适合于编码和存储。</p>
<p>根据采样方式的不同，YUV 主要分为 YUV 4:4:4、YUV 4:2:2、YUV 4:2:0 三种。</p>
<p>根据存储方式的不同，YUV 还可以分成三大类：<strong>Planar</strong>， <strong>Semi-Planar</strong> 和 <strong>Packed</strong>。Planar 格式的 YUV 是先连续存储所有像素点的 Y，然后存储所有像素点的 U（或者 V），之后再存储所有像素点的 V（或者 U）。Semi-planar 格式的 YUV 是先存储完所有像素的 Y，然后 U、V 连续地交错存储。packed 格式的 YUV 是连续交错存储的。</p>
<h4 id="yuv444"><a class="header" href="#yuv444">YUV444</a></h4>
<p><img src="cs/../images/video-process/yuv444-sample.jpg" alt="YUV444采样" /></p>
<p>Planar 存储格式:
<img src="cs/../images/video-process/yuv444-storage.jpg" alt="YUV444存储" /></p>
<h4 id="yuv422"><a class="header" href="#yuv422">YUV422</a></h4>
<p><img src="cs/../images/video-process/yuv422-sample.jpg" alt="YUV422采样" /></p>
<p>Planar 存储格式:
<img src="cs/../images/video-process/yuv422-storage-planar.jpg" alt="YUV422P存储" /></p>
<p>Semi-Planar 存储格式:
<img src="cs/../images/video-process/yuv422-storage-semiplanar.jpg" alt="YUV422SP存储" /></p>
<h4 id="yuv420-最常用"><a class="header" href="#yuv420-最常用">YUV420 (最常用)</a></h4>
<p><img src="cs/../images/video-process/yuv420-sample.jpg" alt="YUV420采样" /></p>
<p>Planar 存储格式:
<img src="cs/../images/video-process/yuv420-storage-planar.jpg" alt="YUV420P存储" /></p>
<p>Semi-Planar 存储格式:
<img src="cs/../images/video-process/yuv420-storage-semiplanar.jpg" alt="YUV420SP存储" /></p>
<h3 id="rgb-与-yuv-转换"><a class="header" href="#rgb-与-yuv-转换">RGB 与 YUV 转换</a></h3>
<p><strong>RGB 和 YUV 格式转换需要双方确定好转换标准和 Color Range</strong>。</p>
<h4 id="bt601-标准标清"><a class="header" href="#bt601-标准标清">BT601 标准（标清）</a></h4>
<p><strong>Limited Range</strong>:</p>
<p>RGB-&gt;YUV 转换公式</p>
<p>$$
\begin{cases}
Y &amp;= 0.299 * R + 0.587 * G + 0.114 * B \\
U &amp;= -0.172 * R - 0.339 * G + 0.511 * B + 128 \\
V &amp;= 0.511 * R - 0.428 * G - 0.083 * B + 128
\end{cases}
$$</p>
<p>YUV-&gt;RGB 转换公式</p>
<p>$$
\begin{cases}
R &amp;= Y + 1.371 * (V - 128) \\
G &amp;= Y - 0.336 * (U - 128) - 0.698 * (V - 128) \\
B &amp;= Y + 1.732 * (U - 128)
\end{cases}
$$</p>
<p><strong>Full Range</strong>:</p>
<p>RGB-&gt;YUV 转换公式</p>
<p>$$
\begin{cases}
Y &amp;= 16 + 0.257 * R + 0.504 * G + 0.098 * B \\
U &amp;= 128 - 0.148 * R - 0.291 * G + 0.439 * B \\
V &amp;= 128 + 0.439 * R - 0.368 * G - 0.071 * B
\end{cases}
$$</p>
<p>YUV-&gt;RGB 转换公式</p>
<p>$$
\begin{cases}
R &amp;= 1.164 * (Y - 16) + 1.596 * (V - 128) \\
G &amp;= 1.164 * (Y - 16) - 0.392 * (U - 128) - 0.812 * (V - 128) \\
B &amp;= 1.164 * (Y - 16) + 2.016 * (U - 128)
\end{cases}
$$</p>
<h4 id="bt709-标准高清"><a class="header" href="#bt709-标准高清">BT709 标准（高清）</a></h4>
<p><strong>Limited Range</strong>:</p>
<p>RGB-&gt;YUV 转换公式</p>
<p>$$
\begin{cases}
Y &amp;= 0.213 * R + 0.715 * G + 0.072 * B \\
U &amp;= -0.117 * R - 0.394 * G + 0.511 * B + 128 \\
V &amp;= 0.511 * R - 0.464 * G - 0.047 * B + 128
\end{cases}
$$</p>
<p>YUV-&gt;RGB 转换公式</p>
<p>$$
\begin{cases}
R &amp;= Y + 1.540 * (V - 128) \\
G &amp;= Y - 0.183 * (U - 128) - 0.459 * (V - 128) \\
B &amp;= Y + 1.816 * (U - 128)
\end{cases}
$$</p>
<p><strong>Full Range</strong>:</p>
<p>RGB-&gt;YUV 转换公式</p>
<p>$$
\begin{cases}
Y &amp;= 16 + 0.183 * R + 0.614 * G + 0.062 * B \\
U &amp;= 128 - 0.101 * R - 0.339 * G + 0.439 * B \\
V &amp;= 128 + 0.439 * R - 0.339 * G - 0.040 * B
\end{cases}
$$</p>
<p>YUV-&gt;RGB 转换公式</p>
<p>$$
\begin{cases}
R &amp;= 1.164 * (Y - 16) + 1.792 * (V - 128) \\
G &amp;= 1.164 * (Y - 16) - 0.213 * (U - 128) - 0.534 * (V - 128) \\
B &amp;= 1.164 * (Y - 16) + 2.114 * (U - 128)
\end{cases}
$$</p>
<h3 id="使用-ffmpeg-将-png-图片转成-yuv-格式"><a class="header" href="#使用-ffmpeg-将-png-图片转成-yuv-格式">使用 ffmpeg 将 png 图片转成 YUV 格式</a></h3>
<p><a href="https://fakeimg.pl/320x320/448aff/fff/?text=hello&amp;font=lobster">获取 png 图片</a></p>
<pre><code class="language-bash">ffmpeg -i hello.png -pix_fmt yuv420p hello-yuv420p.yuv
</code></pre>
<p>转换得到的 yuv 图像可以使用 <a href="https://github.com/IENT/YUView">YUView</a> 软件打开（注意，需要自行设置图片的分辨率等参数，否则不能正确显示）。</p>
<p>由于 yuv 图片除了原始的像素数据，没有保存额外的数据，因此转换得到的图像大小为：320*320*3/2 = 153600 字节。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usb-基础"><a class="header" href="#usb-基础">USB 基础</a></h1>
<h2 id="usb-基本概念"><a class="header" href="#usb-基本概念">USB 基本概念</a></h2>
<h3 id="usb-协议标准"><a class="header" href="#usb-协议标准">USB 协议标准</a></h3>
<div class="table-wrapper"><table><thead><tr><th>USB 协议标准</th><th>主要特点</th><th>速度等级</th></tr></thead><tbody>
<tr><td>USB 2.0 Full Speed<br />（旧称 USB 1.1）</td><td>规范了 USB 低全速传输</td><td>1.5 Mbps~12 Mbps</td></tr>
<tr><td>USB 2.0 High Speed<br />（旧称 USB 2.0）</td><td>规范了 USB 高速传输</td><td>480 Mbps</td></tr>
<tr><td>USB 3.2 gen1<br />（旧称 USB 3.0）</td><td>采用 8b/10b 编码，增加一对超高速差分线，供电 5V/0.9A</td><td>5 Gbps</td></tr>
<tr><td>USB 3.2 gen2<br />（旧称 USB 3.1）</td><td>采用 128b/132b 编码，速度提高 1 倍，供电 20V/5A，同时增加了 A/V 影音传输标准</td><td>10 Gbps</td></tr>
<tr><td>USB 3.2 gen2*2<br />（旧称 USB 3.2）</td><td>增加一对超高速传输通道，速度再次翻倍，只能在 C 型接口上运行</td><td>20 Gbps</td></tr>
</tbody></table>
</div>
<h3 id="通讯接口"><a class="header" href="#通讯接口">通讯接口</a></h3>
<p><img src="ee/../images/usb/USB_slot_interface.png" alt="USB 通讯接口" /></p>
<h3 id="编码方式"><a class="header" href="#编码方式">编码方式</a></h3>
<p><img src="ee/../images/usb/USB_encoding.png" alt="USB 编码方式" /></p>
<p>这种编码方式也称为<strong>反向不归零编码（NRZI）</strong></p>
<p><strong>位填充</strong>：在数据进行 NRZI 编码前，每 6 个连续的 <strong>1</strong> 信号之后都会插入 1 个 <strong>0</strong> 信号，以避免长时间电平保持不变带来的同步漂移。</p>
<h3 id="信号传输状态"><a class="header" href="#信号传输状态">信号传输状态</a></h3>
<p><img src="ee/../images/usb/USB_signal_state.png" alt="USB 信号传输状态" /></p>
<h3 id="帧"><a class="header" href="#帧">帧</a></h3>
<p>帧是一个时间单位，固定为<strong>1ms</strong>（低/全速），高速-微帧为 <strong>125us</strong></p>
<h3 id="通讯过程划分"><a class="header" href="#通讯过程划分">通讯过程划分</a></h3>
<p><img src="ee/../images/usb/USB_field_package_transaction_transfer.png" alt="USB 通讯过程划分" /></p>
<p><strong>事务</strong>是最基本的传输单位。</p>
<h3 id="四种传输"><a class="header" href="#四种传输">四种传输</a></h3>
<p>::: tip 控制传输
主机获取设备信息、状态，选择设备配置等一系列命令式工作。
:::</p>
<p>::: tip 中断传输</p>
<p>收发数据量少、周期性传输。</p>
<p>:::</p>
<p>::: tip 批量传输</p>
<p>利用任何可获得的总线带宽进行数据传输。</p>
<p>:::</p>
<p>::: tip 等时传输</p>
<p>恒定速率、没有差错控制的传输。</p>
<p>:::</p>
<h3 id="其他术语"><a class="header" href="#其他术语">其他术语</a></h3>
<h4 id="上传下传"><a class="header" href="#上传下传">上传/下传</a></h4>
<p>USB 主机接收 USB 设备的数据称为上传，USB 主机发送数据给 USB 设备称为下传。</p>
<h4 id="地址"><a class="header" href="#地址">地址</a></h4>
<p>主机管理设备，而为每一个连接的设备分配一个地址，主机最多可以分配 127 个地址。</p>
<h4 id="端点"><a class="header" href="#端点">端点</a></h4>
<p>USB 设备中实际的物理单元，端点和地址决定了主机和设备之间通讯的物理通道。</p>
<h4 id="usb-传输特点"><a class="header" href="#usb-传输特点">USB 传输特点</a></h4>
<p>物理传输双方角色一定是主机和设备，一问一答传输方式，永远是主机先发起包请求。</p>
<h2 id="主设备和从设备"><a class="header" href="#主设备和从设备">主设备和从设备</a></h2>
<h3 id="主设备"><a class="header" href="#主设备">主设备</a></h3>
<ul>
<li>检测 USB 设备的插拔动作</li>
<li>管理主从通讯之间的控制流</li>
<li>管理主从通讯之间的数据流</li>
<li>记录主机状态和设备动作信息</li>
<li>控制主控制器和 USB 设备间的电气接口</li>
</ul>
<h3 id="集线器"><a class="header" href="#集线器">集线器</a></h3>
<ul>
<li>扩展 USB 主机和 USB 端口</li>
<li>结构上有一个上行端口，多个下行端口</li>
<li>支持级联，系统中最多 5 个集线器（不包括主机的根集线器）</li>
<li>支持速度切换</li>
</ul>
<h3 id="功能设备"><a class="header" href="#功能设备">功能设备</a></h3>
<ul>
<li>一个独立的外围设备，可以是单一功能，也可以是多功能的合成设备</li>
<li>内部包含有描述自身功能和资源需求的配置信息</li>
</ul>
<p><img src="ee/../images/usb/USB_device_structure.png" alt="USB 设备结构图" /></p>
<h2 id="usb-系统分层"><a class="header" href="#usb-系统分层">USB 系统分层</a></h2>
<p><img src="ee/../images/usb/USB_system_tier.png" alt="USB 系统分层" /></p>
<h2 id="连接与检测"><a class="header" href="#连接与检测">连接与检测</a></h2>
<p><img src="ee/../images/usb/USB_connection_detection.png" alt="USB 连接检测" /></p>
<p><img src="ee/../images/usb/USB_fs_device_connection.png" alt="USB 全速设备连接" /></p>
<p><img src="ee/../images/usb/USB_hs_device_connection.png" alt="USB 高速设备连接" /></p>
<h3 id="总线的状态"><a class="header" href="#总线的状态">总线的状态</a></h3>
<div class="table-wrapper"><table><thead><tr><th>常见的总线状态</th><th>描述</th></tr></thead><tbody>
<tr><td>正常工作</td><td>总线上存在周期性 SOF 包</td></tr>
<tr><td>总线复位</td><td>总线维持 SE0 状态  &gt; 10ms</td></tr>
<tr><td>总线挂起</td><td>总线无活动 &gt; 3ms</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>常见的几种变化</th><th>触发点</th></tr></thead><tbody>
<tr><td>无连接 -&gt; 连接</td><td>D+/D- 上出现高电平 &gt; 2ms</td></tr>
<tr><td>正常 -&gt; 挂起</td><td>J 状态保持 &gt; 3ms</td></tr>
<tr><td>挂起 -&gt; 正常（唤醒）</td><td>出现 K 状态信号并持续一段时间</td></tr>
</tbody></table>
</div>
<h2 id="枚举"><a class="header" href="#枚举">枚举</a></h2>
<p>:::tip 枚举的定义</p>
<p>USB 主设备向 USB 从设备通过获取各种描述符，从而了解设备属性，知道是什么样的设备，并加载对应的 USB 类、功能驱动程序，然后进行后续一系列的数据通信。</p>
<p>:::</p>
<ul>
<li>主设备连接识别从设备必须的过程</li>
<li>由多个控制传输构成</li>
<li>经过地址0 （缺省地址）到其他地址（主设备分配地址）的通讯</li>
<li>对于挂载多个 USB 从设备的系统，主设备是逐一进行枚举操作</li>
</ul>
<p><img src="ee/../images/usb/USB_enumeration.png" alt="USB 枚举" /></p>
<h3 id="设备描述符"><a class="header" href="#设备描述符">设备描述符</a></h3>
<p>第一个需要获取的描述符，长度固定 18 字节。</p>
<h3 id="配置描述符"><a class="header" href="#配置描述符">配置描述符</a></h3>
<p>描述了设备特定的配置，提供了当前配置下设备的功能接口，供电方式，耗电等信息。是一个配置的集合，集合长度不固定，包含了配置描述符、接口描述符、类定义描述符、端点描述符。</p>
<h2 id="控制传输"><a class="header" href="#控制传输">控制传输</a></h2>
<p><img src="ee/../images/usb/USB_control_transfer.png" alt="USB 控制传输" /></p>
<p><img src="ee/../images/usb/USB_control_transfer_transactions.png" alt="USB 控制传输涉及到的事务" /></p>
<h3 id="建立阶段"><a class="header" href="#建立阶段">建立阶段</a></h3>
<p><img src="ee/../images/usb/USB_control_transfer_setup_stage.png" alt="USB 控制传输建立阶段" /></p>
<h2 id="usb-键盘"><a class="header" href="#usb-键盘">USB 键盘</a></h2>
<p><img src="ee/../images/usb/USB_keyboard_design.png" alt="USB 键盘设计思路" /></p>
<p><img src="ee/../images/usb/USB_keyboard_sw.png" alt="USB 软件设计" /></p>
<h2 id="参考文献"><a class="header" href="#参考文献">参考文献</a></h2>
<ul>
<li><a href="https://www.usb.org">USB 协会官网</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="can-基础"><a class="header" href="#can-基础">CAN 基础</a></h1>
<h2 id="拓扑结构"><a class="header" href="#拓扑结构">拓扑结构</a></h2>
<p><img src="ee/../images/can/can-topology.png" alt="CAN 拓扑结构" /></p>
<p>CAN总线有两个 ISO 国际标准：ISO11898 和 ISO11519。</p>
<ul>
<li>ISO11898 定义了通信速率为 125 Kbps～1 Mbps 的高速 CAN 通信标准，属于闭环总线，总线长度 ≤ 40 米。</li>
<li>ISO11519 定义了通信速率为 10～125 Kbps 的低速 CAN 通信标准，属于开环总线，总线长度可达 1000 米。</li>
<li>在同一条总线上，所有节点的通信速度必须相同；如果两条不同通信速度的总线上的节点想要实现信息交互，必须通过网关或者中继器转发信息。</li>
</ul>
<h2 id="信号表示"><a class="header" href="#信号表示">信号表示</a></h2>
<p><img src="ee/../images/can/can-signal.png" alt="CAN 信号表示" /></p>
<h2 id="通信特点"><a class="header" href="#通信特点">通信特点</a></h2>
<h3 id="多主多从结构"><a class="header" href="#多主多从结构">多主多从结构</a></h3>
<ul>
<li>CAN 总线上的所有节点没有主从之分，在总线空闲状态，任意节点都可以向总线上发送消息</li>
<li>当总线上出现连续的 11 位隐形电平，那么总线就处于空闲状态</li>
<li>最先向总线发送消息的节点获得总线的发送权，当多个节点同时向总线发送消息时，所发送消息的优先级高的那个节点获得总线的发送权</li>
<li>依赖于<strong>硬件</strong>的验收滤波技术，CAN 总线可以实现一对一，一对多以及广播的数据传输方式。</li>
</ul>
<h3 id="非破坏性位仲裁机制"><a class="header" href="#非破坏性位仲裁机制">非破坏性位仲裁机制</a></h3>
<p>当多个节点同时向总线发送消息时，对各个消息的标识符（即ID号）进行逐位仲裁，如果某个节点发送的消息仲裁获胜，那么这个节点将获取总线的发送权，仲裁失败的节点则立即停止发送并转变为监听（接收）状态。</p>
<p>这种仲裁机制既不会造成已发送数据的延迟，也不会破坏已经发送的数据。</p>
<h3 id="报文过滤"><a class="header" href="#报文过滤">报文过滤</a></h3>
<p>CAN 总线中没有地址的概念，CAN 总线是通过报文 ID 来实现收发数据的。每个节点上都会有一个验收滤波 ID 表，其位于 CAN 节点的验收滤波器中，如果总线上的报文的 ID 号在某个节点的验收滤波 ID 表中，那么这一帧报文就能通过该节点验收滤波器的验收，该节点就会接收这一帧报文。</p>
<h3 id="远程数据请求"><a class="header" href="#远程数据请求">远程数据请求</a></h3>
<p>某个节点 Node_A 可以通过发送<code>遥控帧</code>到总线上的方式，请求某个节点 Node_B 来发送由该遥控帧所指定的报文。</p>
<h3 id="出错处理"><a class="header" href="#出错处理">出错处理</a></h3>
<ul>
<li>所有的节点都可以检测出错误</li>
<li>检测出错误的节点会立即通知总线上其它所有的节点</li>
<li>正在发送消息的节点，如果检测到错误，会立即停止当前的发送，同时不断地重复发送此消息，直到该消息发送成功为止</li>
</ul>
<h3 id="故障封闭"><a class="header" href="#故障封闭">故障封闭</a></h3>
<p>节点能够判断错误的类型，判断是暂时性的数据错误（如噪声干扰）还是持续性的数据错误（如节点内部故障），如果判断是严重的持续性错误，那么节点就会切断自己与总线的联系，从而避免影响总线上其他节点的正常工作。</p>
<h3 id="位填充"><a class="header" href="#位填充">位填充</a></h3>
<p><img src="ee/../images/can/can-bit-fill.png" alt="CAN 位填充原则" /></p>
<p>CAN 协议中规定，当相同极性的电平持续五位时，则添加一个极性相反的位。</p>
<h2 id="网络分层架构"><a class="header" href="#网络分层架构">网络分层架构</a></h2>
<p><img src="ee/../images/can/can-net-stack.jpeg" alt="CAN 网络层次结构" /></p>
<h2 id="帧结构"><a class="header" href="#帧结构">帧结构</a></h2>
<h3 id="数据帧和遥控帧"><a class="header" href="#数据帧和遥控帧">数据帧和遥控帧</a></h3>
<p><img src="ee/../images/can/can-data-frame.png" alt="CAN 数据帧" /></p>
<p><img src="ee/../images/can/can-remote-frame.png" alt="CAN 遥控帧" /></p>
<ul>
<li>RTR(Remote Transmission Request) 位保证了数据帧的优先级高于遥控帧</li>
<li>SRR(Substitutes Remote Requests) 位保证了标准数据帧的优先级高于扩展数据帧</li>
<li>IDE(Identifier Extension) 位保证了标准遥控帧的优先级高于扩展遥控帧</li>
<li>DLC(Data Length Code) 位指示了数据段中的字节数，对于遥控帧而言，DLC 表示该遥控帧对应的数据帧的数据段的字节数</li>
<li>数据段从 MSB 开始输出</li>
<li>CRC 校验序列(15bit)的计算范围包括：SOF,仲裁段，控制段和数据段</li>
<li>ACK 包括 ACK 槽和 ACK 分界符：
<ul>
<li>发送节点发出的报文中 ACK 槽为<code>隐性1</code></li>
<li>接收节点在接收到正确的报文之后会在 ACK 槽发送<code>显性0</code>，通知发送节点正常接收结束</li>
</ul>
</li>
<li>EOF(End Of Frame) 表示该帧报文的结束，由7个隐性位构成</li>
</ul>
<h3 id="错误帧"><a class="header" href="#错误帧">错误帧</a></h3>
<p>在 CAN 总线通信中，一共有五种错误，分别是：位错误、ACK错误、填充错误、CRC错误、格式错误。</p>
<p><img src="ee/../images/can/can-error-frame.png" alt="CAN 错误帧" /></p>
<ul>
<li>主动错误标志：6个连续的显性位0</li>
<li>被动错误标志：6个连续的隐性位1</li>
<li>错误分界符：8个连续的隐性位1</li>
</ul>
<h3 id="过载帧"><a class="header" href="#过载帧">过载帧</a></h3>
<p><img src="ee/../images/can/can-overload-frame.png" alt="CAN 过载帧" /></p>
<ul>
<li>接受单元会发从此帧来通知总线自己还没有做好接收准备</li>
</ul>
<h3 id="帧间隔"><a class="header" href="#帧间隔">帧间隔</a></h3>
<p><img src="ee/../images/can/can-inter-frame.png" alt="CAN 帧间隔" /></p>
<ul>
<li>数据帧和遥控帧可通过插入帧间隔将本帧与前面的任何帧（数据帧、遥控帧、错误帧、过载帧）分开，过载帧和错误帧前不能插入帧间隔</li>
</ul>
<h2 id="错误通知"><a class="header" href="#错误通知">错误通知</a></h2>
<h3 id="节点错误状态"><a class="header" href="#节点错误状态">节点错误状态</a></h3>
<p>按照 CAN 协议的规定，CAN 总线上的节点始终处于以下三种状态之一：</p>
<ul>
<li>
<p>主动错误状态</p>
<ul>
<li>可以正常通信</li>
<li>在检测出错误时，发出主动错误标志</li>
</ul>
</li>
<li>
<p>被动错误状态</p>
<ul>
<li>可以正常通信</li>
<li>在检测出错误时，发出被动错误标志</li>
</ul>
</li>
<li>
<p>总线关闭状态</p>
<ul>
<li>节点不能收发报文</li>
<li>在满足一定条件的时候，再次进入到主动错误状态</li>
</ul>
</li>
</ul>
<h3 id="错误状态的转换"><a class="header" href="#错误状态的转换">错误状态的转换</a></h3>
<p>在 CAN 节点内，有两个计数器：发送错误计数器（TEC）和接收错误计数器（REC）。TEC 和 REC 计数值的变化，是根据下表的规定来进行的</p>
<p><img src="ee/../images/can/can-tec-rec.png" alt="TEC/REC" /></p>
<p>CAN节点错误状态的转换，就是基于这两个计数器来进行的</p>
<p><img src="ee/../images/can/can-error-state.png" alt="错误状态转换" /></p>
<h3 id="错误帧的发送"><a class="header" href="#错误帧的发送">错误帧的发送</a></h3>
<p><img src="ee/../images/can/can-error-recovery.png" alt="错误帧的发送" /></p>
<ol>
<li>发送节点 Node_A 发送一个显性位，但是却从总线上听到一个隐形位，于是 Node_A 节点就会检测到一个位错误</li>
<li>Node_A 检测到位错误之后，立即在下一位开始发送主动错误帧：6个连续显性位的主动错误标志+8个连续隐性位的错误界定符</li>
<li>对应 Node_A 发出的主动错误标志，总线上电平为6个连续显性位</li>
<li>接收节点 Node_B 和 Node_C 从总线上听到连续6个显性位，那么就会检测到一个<strong>填充错误</strong>，于是这两个节点都会发送主动错误帧</li>
<li>对应 Node_B 和 Node_C 发出的主动错误标志，总线电平又有6个连续显性电平，对应 Node_B 和 Node_C 发出的错误界定符，总线电平有8个连续的隐性电平</li>
<li>在间歇域之后，Node_A 节点重新发送刚刚出错的报文</li>
</ol>
<h2 id="socket-can"><a class="header" href="#socket-can">Socket CAN</a></h2>
<h3 id="命令行工具"><a class="header" href="#命令行工具">命令行工具</a></h3>
<h4 id="ip-命令"><a class="header" href="#ip-命令">ip 命令</a></h4>
<pre><code class="language-bash">ip link set can0 type can help
</code></pre>
<h5 id="设置-can-设备的波特率"><a class="header" href="#设置-can-设备的波特率">设置 CAN 设备的波特率</a></h5>
<pre><code class="language-bash">ip link set can0 type can bitrate 500000
ip link set can0 type can bitrate 500000 dbitrate 2000000 fd on
ip link set can0 type can bitrate 500000 sample-point 0.875
</code></pre>
<h5 id="启动关闭-can-设备"><a class="header" href="#启动关闭-can-设备">启动/关闭 CAN 设备</a></h5>
<pre><code class="language-bash">ip link set can0 up
ip link set can0 down
</code></pre>
<h5 id="设置-can-设备的模式"><a class="header" href="#设置-can-设备的模式">设置 CAN 设备的模式</a></h5>
<pre><code class="language-bash">ip link set can0 type can loopback on
ip link set can0 type can listen-only on
</code></pre>
<h5 id="查看详细的配置信息"><a class="header" href="#查看详细的配置信息">查看详细的配置信息</a></h5>
<pre><code class="language-bash">ip -details link show can0
</code></pre>
<h4 id="can-utils-程序"><a class="header" href="#can-utils-程序">can-utils 程序</a></h4>
<h5 id="candump"><a class="header" href="#candump">candump</a></h5>
<pre><code class="language-bash">candump can0,0x123:0x7FF # 仅显示can0上收到的ID为0x123的消息
</code></pre>
<h5 id="cansend"><a class="header" href="#cansend">cansend</a></h5>
<pre><code class="language-bash">cansend can0 123#1122334455667788 # 发送一个ID为0x123的报文
</code></pre>
<h5 id="cangen"><a class="header" href="#cangen">cangen</a></h5>
<pre><code class="language-bash">cangen can0 -g 0x123 -I 1000 -L 8 -D 0x1122334455667788 # 每1000ms发送一个ID为0x123的报文
</code></pre>
<h5 id="cansniffer"><a class="header" href="#cansniffer">cansniffer</a></h5>
<pre><code class="language-bash">cansniffer can0 # 抓取can0上的所有报文，可以过滤掉数据不变的帧
</code></pre>
<h2 id="python-can"><a class="header" href="#python-can">python-can</a></h2>
<h3 id="安装"><a class="header" href="#安装">安装</a></h3>
<pre><code class="language-bash">pip install python-can
</code></pre>
<h3 id="使用"><a class="header" href="#使用">使用</a></h3>
<pre><code class="language-python"># import the library
import can

# create a bus instance
# many other interfaces are supported as well (see documentation)
bus = can.Bus(interface='socketcan',
              channel='vcan0',
              receive_own_messages=True)

# send a message
message = can.Message(arbitration_id=123, is_extended_id=True,
                      data=[0x11, 0x22, 0x33])
bus.send(message, timeout=0.2)

# iterate over received messages
for msg in bus:
    print(f&quot;{msg.arbitration_id:X}: {msg.data}&quot;)

# or use an asynchronous notifier
notifier = can.Notifier(bus, [can.Logger(&quot;recorded.log&quot;), can.Printer()])
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yosys-基础"><a class="header" href="#yosys-基础">Yosys 基础</a></h1>
<blockquote>
<p>建议使用 pip 安装 WebAssembly 打包后的 Yosys 开源工具链： <a href="https://yowasp.org/">https://yowasp.org/</a></p>
</blockquote>
<h2 id="测试用例代码"><a class="header" href="#测试用例代码">测试用例代码</a></h2>
<pre><code class="language-verilog">module alu(a, b, cin, sel, y);
  input [7:0] a, b;
  input cin;
  input [3:0] sel;
  output [7:0] y;

  reg [7:0] y;
  reg [7:0] arithval;
  reg [7:0] logicval;

  // 算术执行单元
  always @(a or b or cin or sel) begin
    case (sel[2:0])
      3'b000  : arithval = a;
      3'b001  : arithval = a + 1;
      3'b010  : arithval = a - 1;
      3'b011  : arithval = b;
      3'b100  : arithval = b + 1;
      3'b101  : arithval = b - 1;
      3'b110  : arithval = a + b;
      default : arithval = a + b + cin;
    endcase
  end

  // 逻辑处理单元
  always @(a or b or sel) begin
    case (sel[2:0])
      3'b000  : logicval =  ~a;
      3'b001  : logicval =  ~b;
      3'b010  : logicval = a &amp; b;
      3'b011  : logicval = a | b;
      3'b100  : logicval =  ~((a &amp; b));
      3'b101  : logicval =  ~((a | b));
      3'b110  : logicval = a ^ b;
      default : logicval =  ~(a ^ b);
    endcase
  end

  // 输出选择单元
  always @(arithval or logicval or sel) begin
    case (sel[3])
      1'b0    : y = arithval;
      default : y = logicval;
    endcase
  end

endmodule
</code></pre>
<h2 id="使用-yosys-进行综合"><a class="header" href="#使用-yosys-进行综合">使用 Yosys 进行综合</a></h2>
<ol>
<li>启动 Yosys：<code>yosys</code></li>
<li>读取 Verilog 文件： <code>read_verilog alu.v</code></li>
<li>检查模块例化结构： <code>hierarchy -check</code></li>
<li>逻辑综合于优化：<code>proc; opt; opt; fsm; memory; opt</code></li>
<li>生成网表文件：<code>write_verilog alu_synth.v</code></li>
<li>输出综合后的逻辑图：<code>show -format dot -prefix ./alu</code></li>
</ol>
<p><img src="ee/../images/yosys/alu.svg" alt="alu" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git-基础"><a class="header" href="#git-基础">Git 基础</a></h1>
<h2 id="演示文稿"><a class="header" href="#演示文稿">演示文稿</a></h2>
<p><a href="https://suda-morris.github.io/git_workflow_lecture/">Git 工作流介绍</a></p>
<h2 id="视频演示"><a class="header" href="#视频演示">视频演示</a></h2>
<p><a href="https://www.bilibili.com/video/BV1zv411i7ce/">Git 工作流介绍</a></p>
<h2 id="gitconfig-文件模板"><a class="header" href="#gitconfig-文件模板">.gitconfig 文件模板</a></h2>
<pre><code class="language-bash">[user]
    name = suda-morris
    email = 362953310@qq.com
[branch]
    autosetuprebase = always

[core]
    editor = vim
    quotepath = false
    autocrlf = false
    pager = less -+$LESS -FRX

[color]
    status = auto
    branch = auto
    diff = auto
    ui = true
    pager = true

[color &quot;branch&quot;]
    current = green reverse
    local = white
    remote = red

[color &quot;diff&quot;]
    meta = yellow bold
    frag = magenta bold
    old = red bold
    new = green bold

[color &quot;status&quot;]
    added = yellow
    changed = red
    untracked = cyan

[diff]
    tool = git_diff_wrapper

[difftool &quot;git_diff_wrapper&quot;]
    cmd = vimdiff -n   +2  $LOCAL $REMOTE

[pager]
    diff =

[difftool]
    prompt = no

[alias]
    glf  = log -n 10 --name-only --format=\&quot;%Cgreen%h %Cred[%ci] %Creset&lt;%an&gt; %Creset %Cgreen%s %Creset \&quot;
    gl  = log -n 30 --date-order --format=\&quot;%Cgreen%h %Cred[%ci] %Creset &lt;%an&gt;%C(yellow)%d%Creset %Creset %Cgreen%s %Creset \&quot;
    gll  = log -n 30  --format=\&quot;%Cgreen%H %Cred[%ci] %Creset&lt;%an&gt; %Creset %Cgreen%s %Creset \&quot;
    gl3 = log -n 20  --format=\&quot;%Cgreen%h %Cred[%ci] %Creset&lt;%an&gt; %Creset %Cgreen%s %Creset \&quot; --graph
    gl2 = log --format=\&quot;%Cgreen%h %Cred[%ci] %Creset&lt;%an&gt; %Creset %Cgreen%s %Creset \&quot;
    glc = log --format=\&quot;%Cgreen%h %Cred[%cd] %Creset&lt;committer:%cn&gt; : %Cred[%ad] %Creset&lt;author:%cn&gt; %Creset \&quot;
    glc2 = log --format=\&quot;%Cgreen%h %Cred[%ci] %Creset&lt;committer:%cn&gt; : %Cred[%ai] %Creset&lt;author:%cn&gt; %Creset \&quot;
    glc3 = log --format=\&quot;%Cgreen%h %Cred[%ci] %Creset&lt;committer:%cn&gt; : %Cred[%ai] %Creset&lt;author:%cn&gt; %n %Cgreen%s %Creset \&quot;
    glt = log --format=\&quot;%Cgreen%h :: %ad :: %aD :: %ar :: %at :: %ai %Creset \&quot;
    glw = log  -n 20  --format=\&quot;%Cgreen%h %Cred[%ci] %Creset&lt;%an&gt; %Creset %n%Cgreen%s%Creset%n%b  \&quot;
    gldetail = log --format=\&quot;%h `[%cd] `&lt;committer:%cn&gt; `[%ad] `&lt;author:%an&gt; ` %s \&quot;
    hist = log --pretty=format:\&quot;%C(yellow)%h %C(red)%d %C(reset)%s %C(green)[%an] %C(blue)%ad\&quot; --topo-order --graph
    latest = for-each-ref --sort=-committerdate --format=\&quot;%(committername)@%(refname:short) [%(committerdate:short)] %(contents)\&quot;
    st = status -uno -s
    st2 = status -s
    co = checkout
    bl = blame --date=short
    ci = commit
    dt = difftool
    dif = diff --word-diff
    di = diff --no-ext-diff

[log]
    date = short

[commit]
    template = /home/morris/.gitmessage
</code></pre>
<h2 id="gitmessage-文件模板"><a class="header" href="#gitmessage-文件模板">.gitmessage 文件模板</a></h2>
<pre><code>vfs/fatfs: fix stat call failing when called for mount point

FATFS does not support f_stat call for drive root. When handling stat
for drive root, don't call f_stat and just return struct st with S_IFDIR
flag set.

Closes https://github.com/espressif/esp-idf/issues/xxx
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="终端演示工具"><a class="header" href="#终端演示工具">终端演示工具</a></h1>
<h2 id="slides"><a class="header" href="#slides"><a href="https://github.com/maaslalani/slides">Slides</a></a></h2>
<h3 id="安装与使用"><a class="header" href="#安装与使用">安装与使用</a></h3>
<pre><code class="language-bash"># 安装 slides 软件
yay -S slides
# 使用 slides 软件
slides path/to/markdown/file.md
</code></pre>
<h3 id="模板"><a class="header" href="#模板">模板</a></h3>
<pre><code class="language-markdown">---
theme: https://github.com/maaslalani/slides/raw/main/styles/theme.json
---

# Welcome to Slides

A terminal based presentation tool

---

# Code blocks

Slides allows you to execute code blocks directly inside your slides!

Just press `ctrl+e` and the result of the code block will be displayed as virtual
text in your slides.

---

### Bash

```bash
ls
```

---

### Go

```go
package main

import &quot;fmt&quot;

func main() {
  fmt.Println(&quot;Hello, world!&quot;)
}
```

---

### Javascript

```javascript
console.log(&quot;Hello, world!&quot;)
```

---

### Python

```python
print(&quot;Hello, world!&quot;)
```

---

# h1
## h2
### h3
#### h4
##### h5
###### h6

---

# Markdown components

You can use everything in markdown!

* Like bulleted list
* You know the deal

1. Numbered lists too

* [x] ToDo

---

# Tables

| Tables | Too    |
| ------ | ------ |
| Even   | Tables |

---

# Graphs

```
digraph {
    rankdir = LR;
    a -&gt; b;
    b -&gt; c;
}
```
```
┌───┐     ┌───┐     ┌───┐
│ a │ ──▶ │ b │ ──▶ │ c │
└───┘     └───┘     └───┘
```
---

~~~uname -a
This will be replaced by command `uname -a`
~~~

---

SEE YOU!

[Blog](https://suda-mottis.github.io/blog)

![ME](/home/morris/blog/docs/.vuepress/public/author.jpg)

</code></pre>
<h2 id="mdp"><a class="header" href="#mdp"><a href="https://github.com/visit1985/mdp">mdp</a></a></h2>
<h3 id="安装与使用-1"><a class="header" href="#安装与使用-1">安装与使用</a></h3>
<pre><code class="language-bash"># 安装 mdp 软件
sudo pacman -S mdp
# 使用 mdp 软件
mdp path/to/markdown/file.md
</code></pre>
<h3 id="模板-1"><a class="header" href="#模板-1">模板</a></h3>
<pre><code class="language-markdown">%title: Markdown Presentation 演示文稿 🥳
%author: suda-morris
%date: 2019-11-11

-&gt; # 一级标题，居中 &lt;-

-&gt; ## 二级标题，居中 &lt;-

-&gt; 文本内容，居中 &lt;-

_基本控制:_

下一页      *Enter*, *Space*, *Page Down*, *j*, *l*,
            *Down Arrow*, *Right Arrow*

前一页      *Backspace*, *Page Up*, *h*, *k*,
            *Up Arrow*, *Left Arrow*

退出        *q*
重载        *r*
第 N 页     *1..9*
首页        *Home*, *g*
末页        *End*, *G*

-------------------------------------------------


-&gt; # 代码展示 &lt;-

行内代码 `main()`

代码块

​```
int main(int argc, char *argv[]) {
    printf(&quot;%s\n&quot;, &quot;Hello world!&quot;);
}
​```

-------------------------------------------------

-&gt; # 引用 &lt;-

&gt; 引用
&gt;&gt; 嵌套引用 1
&gt;&gt;&gt; 嵌套引用 2

-------------------------------------------------

-&gt; # 下划线与高亮 &lt;-

_仅下划线_ *高亮* _*下划线且高亮*_

-------------------------------------------------

-&gt; # 列表 &lt;-

list
* major
    - minor
        - *important*
          detail
    - minor

-------------------------------------------------

-&gt; # 逐行显示 &lt;-

Agenda
^
* major
^
    * minor
^
* major
  ^
    * minor
      ^
        * detail

-------------------------------------------------

-&gt; # URL 链接 &lt;-

[blog](https://suda-morris.github.io/blog)

-------------------------------------------------

-&gt; # UTF-8 特殊字符 &lt;-

ae = ä, oe = ö, ue = ü, ss = ß
upsilon = Ʊ, phi = ɸ

▛▀▀▀▀▀▀▀▀▀▜
▌rectangle▐
▙▄▄▄▄▄▄▄▄▄▟


-------------------------------------------------

-&gt; # 演示的暂停与恢复 &lt;-

按下 *Ctrl + z* 可以暂停当前演示，回到终端

在终端输入 *fg* 可以恢复之前的演示

-------------------------------------------------

-&gt; # 导出到 PDF 文件 &lt;-

需要安装额外的工具：

\- *markdown* 将 Markdown 文件导出为 HTML
\- *wkhtmltopdf* 将 HTML 转换为 PDF

`$ markdown sample.md | wkhtmltopdf - sample.pdf`
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>

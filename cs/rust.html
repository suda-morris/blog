<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust - 🐏🐒 suda-morris 个人博客 🐇</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Personal Blog">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../about-me.html">关于我</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">体系结构</li><li class="chapter-item expanded "><a href="../cs/riscv.html"><strong aria-hidden="true">1.</strong> RISC-V</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">编译系统</li><li class="chapter-item expanded "><a href="../cs/gcc-toolchains.html"><strong aria-hidden="true">2.</strong> GCC</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">操作系统</li><li class="chapter-item expanded "><a href="../cs/openwrt.html"><strong aria-hidden="true">3.</strong> OpenWRT</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">编程语言</li><li class="chapter-item expanded "><a href="../cs/rust.html" class="active"><strong aria-hidden="true">4.</strong> Rust</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">控制系统</li><li class="chapter-item expanded "><a href="../ee/control-system.html"><strong aria-hidden="true">5.</strong> 控制系统基础</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">测试框架</li><li class="chapter-item expanded "><a href="../cs/pytest.html"><strong aria-hidden="true">6.</strong> pytest</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">多媒体</li><li class="chapter-item expanded "><a href="../cs/video-process.html"><strong aria-hidden="true">7.</strong> 视频处理</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">通信协议</li><li class="chapter-item expanded "><a href="../ee/usb.html"><strong aria-hidden="true">8.</strong> USB 协议基础</a></li><li class="chapter-item expanded "><a href="../ee/can.html"><strong aria-hidden="true">9.</strong> CAN 协议基础</a></li><li class="chapter-item expanded "><a href="../ee/mipi.html"><strong aria-hidden="true">10.</strong> MIPI 协议基础</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">电路设计</li><li class="chapter-item expanded "><a href="../ee/yosys.html"><strong aria-hidden="true">11.</strong> Yosys</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">前端</li><li class="chapter-item expanded "><a href="../cs/tauri.html"><strong aria-hidden="true">12.</strong> Tauri</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">管理</li><li class="chapter-item expanded "><a href="../cs/git.html"><strong aria-hidden="true">13.</strong> git</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">演示</li><li class="chapter-item expanded "><a href="../ux/slides-tool.html"><strong aria-hidden="true">14.</strong> slides 工具</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">🐏🐒 suda-morris 个人博客 🐇</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/suda-morris/blog" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/suda-morris/blog/edit/master/src/cs/rust.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-知识碎片"><a class="header" href="#rust-知识碎片">Rust 知识碎片</a></h1>
<h2 id="编译过程"><a class="header" href="#编译过程">编译过程</a></h2>
<p><img src="../images/rust/compile-process.png" alt="Rust 编译过程" /></p>
<ol>
<li>分词：把词法结构处理成词条流</li>
<li>词条流经过语法解析形成抽象语法树</li>
<li>抽象语法树简化成高级中间语言 (HIR)，编译器对 HIR 进行类型检查、方法查找等工作</li>
<li>HIR 进一步简化形成中级中间语言 (MIR)，编译器对 MIR 进行借用检查、优化等工作，在 MIR 中已经看不到 Rust 各版次的差异了</li>
<li>产生 LLVM 中间语言</li>
<li>LLVM 后端会对 LLVM 中间语言进行优化，最终生成机器代码</li>
</ol>
<h2 id="值放堆上还是栈上"><a class="header" href="#值放堆上还是栈上">值放堆上还是栈上</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello world&quot;.to_string();
println!(&quot;'hello world': {:p}, s: {:p}, len: {}, capacity: {}, size: {}&quot;,
        &amp;&quot;hello world&quot;, &amp;s, s.len(), s.capacity(), std::mem::size_of_val(&amp;s));
<span class="boring">}</span></code></pre></pre>
<p><img src="../images/rust/string-in-memory.webp" alt="string的内存布局" /></p>
<blockquote>
<p>栈上存放的数据是静态的，固定大小，固定生命周期；堆上存放的数据是动态的，不固定大小，不固定生命周期。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static MAX: u32 = 0;
fn foo() {}
let hello = &quot;hello world&quot;.to_string();
let data = Box::new(1);

// string literals 指向 RODATA 地址
println!(&quot;RODATA: {:p}&quot;, &quot;hello world!&quot;);
// static 变量在 DATA section
println!(&quot;DATA (static var): {:p}&quot;, &amp;MAX);
// function 在 TEXT
println!(&quot;TEXT (function): {:p}&quot;, foo as *const ());
// String 结构体分配在栈上，所以其引用指向一个栈地址
println!(&quot;STACK (&amp;hello): {:p}&quot;, &amp;hello);
// 需要通过解引用获取其堆上数据，然后取其引用
println!(&quot;HEAP (&amp;*hello): {:p}&quot;, &amp;*hello);
// Box 实现了 Pointer trait 无需额外解引用
println!(&quot;HEAP (box impl Pointer) {:p} {:p}&quot;, data, &amp;*data);
<span class="boring">}</span></code></pre></pre>
<h2 id="move-copy-borrow"><a class="header" href="#move-copy-borrow">move, copy, borrow</a></h2>
<p><img src="../images/rust/move-copy-borrow.jpg" alt="move, copy, borrow" /></p>
<p>其实 Copy 和 Move 在内部实现上，都是浅层的<strong>按位</strong>做内存复制，只不过 Copy 允许你访问之前的变量，而 Move 不允许。</p>
<h3 id="关于内存复制上的误区"><a class="header" href="#关于内存复制上的误区">关于内存复制上的误区</a></h3>
<p>如果代码的关键路径中的每次都要复制几百 k 的数据（比如一个大数组），这是很低效的。但是，如果要复制的只是原生类型（Copy）或者栈上的胖指针（Move），不涉及堆内存的复制（即没有做深拷贝（deep copy）），那这个效率是非常高的，不必担心每次赋值或者每次传参带来的性能损失。</p>
<p>Rust 的集合类型会在使用过程中自动扩展。以一个 Vec 为例，当使用完堆内存当前容量后，还继续添加新的内容，就会触发堆内存的自动增长。有时候，集合类型里的数据不断进进出出，导致集合一直增长，但实际只使用了很小部分的容量，导致内存的使用效率很低，这时可以考虑使用 <code>shrink_to_fit</code> 方法来节约对内存的使用。</p>
<h2 id="所有权"><a class="header" href="#所有权">所有权</a></h2>
<p><img src="../images/rust/ownership.webp" alt="ownership" /></p>
<h3 id="所有权的静态检查和动态检查"><a class="header" href="#所有权的静态检查和动态检查">所有权的静态检查和动态检查</a></h3>
<p>在所有权模型下，堆内存的生命周期，和创建它的栈内存的生命周期保持一致。编译器可以保证代码符合所有权规则（静态检查）。</p>
<p>动态检查，通过 <code>Box::leak()</code> 让堆内存拥有不受限制的生命周期，然后在运行过程中，通过对引用计数的检查，保证这样的堆内存最终会得到释放。</p>
<h3 id="外部可变性与内部可变性"><a class="header" href="#外部可变性与内部可变性">外部可变性与内部可变性</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th>使用方法</th><th>所有权检查</th></tr></thead><tbody>
<tr><td>外部可变性</td><td><code>let mut</code> 或者 <code>&amp;mut</code></td><td>编译时，如果不符合规则，产生编译错误</td></tr>
<tr><td>内部可变性</td><td>使用 Cell/RefCell</td><td>运行时，如果不符合规则，产生 panic</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust edition2021">use std::cell::RefCell;

fn main() {
    let data = RefCell::new(1);
    // 根据所有权规则，在同一个作用域下，不能同时有活跃的可变借用和不可变借用
    // 通过这对花括号，我们缩小了可变借用的生命周期
    {
        // 获得 RefCell 内部数据的可变借用
        let mut v = data.borrow_mut();
        *v += 1;
    }
    println!(&quot;data: {:?}&quot;, data.borrow());
}</code></pre></pre>
<h2 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">pub fn strtok&lt;'a&gt;(s: &amp;mut &amp;'a str, delimiter: char) -&gt; &amp;'a str {
    if let Some(i) = s.find(delimiter) {
        let prefix = &amp;s[..i];
        // 由于 delimiter 可以是 utf8，所以我们需要获得其 utf8 长度，
        // 直接使用 len 返回的是字节长度，会有问题
        let suffix = &amp;s[(i + delimiter.len_utf8())..];
        *s = suffix;
        prefix
    } else {
        // 如果没找到，返回整个字符串，把原字符串指针 s 指向空串
        let prefix = *s;
        *s = &quot;&quot;;
        prefix
    }
}

fn main() {
    let s = String::from(&quot;hello world&quot;);
    let mut s1 = s.as_str();
    let hello = strtok(&amp;mut s1, ' ');
    println!(&quot;hello is: {}, s1: {}, s: {}&quot;, hello, s1, s);
}</code></pre></pre>
<p><img src="../images/rust/lifetime-example.webp" alt="lifetime" /></p>
<blockquote>
<p>注意：当你要返回在函数执行过程中，创建的或者得到的数据，和参数无关，那么无论它是一个有所有权的数据，还是一个引用，你只能返回带所有权的数据。对于引用，这就意味着调用 <code>clone()</code> 或者 <code>to_owned()</code> 来从引用中得到所有权。</p>
</blockquote>
<h2 id="结构体成员自动重排"><a class="header" href="#结构体成员自动重排">结构体成员自动重排</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use std::mem::{align_of, size_of};

struct S1 {
    a: u8,
    b: u16,
    c: u8,
}

struct S2 {
    a: u8,
    c: u8,
    b: u16,
}

#[repr(C)]
struct S3 {
    a: u8,
    b: u16,
    c: u8,
}

fn main() {
    println!(
        &quot;sizeof S1: {}, S2: {}, S3: {}&quot;,
        size_of::&lt;S1&gt;(),
        size_of::&lt;S2&gt;(),
        size_of::&lt;S3&gt;()
    );
    println!(
        &quot;alignof S1: {}, S2: {}, S3: {}&quot;,
        align_of::&lt;S1&gt;(),
        align_of::&lt;S2&gt;(),
        align_of::&lt;S3&gt;()
    );
}</code></pre></pre>
<p>Rust 编译器默会优化结构体的排列，但我们也可以使用 <code>#[repr]</code> 宏，强制让 Rust 编译器不做优化，和 C 的行为一致，这样，Rust 代码可以方便地和 C 代码无缝交互。</p>
<h2 id="enum-的内存布局"><a class="header" href="#enum-的内存布局">enum 的内存布局</a></h2>
<p><img src="../images/rust/enum-memory-layout.webp" alt="enum" /></p>
<p>enum 是一个标签联合体（tagged union），它的大小是标签的大小，加上最大类型的长度。所以对于 <code>Option&lt;u8&gt;</code>，其长度是 1 + 1 = 2 字节，而 <code>Option&lt;f64&gt;</code>，长度是 8 + 8 =16 字节。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::HashMap;
use std::mem::size_of;

enum MyEnum {
    A(f64),
    B(HashMap&lt;String, String&gt;),
    C(Result&lt;Vec&lt;u8&gt;, String&gt;),
}

// 这是一个声明宏，它会打印各种数据结构本身的大小，在 Option 中的大小，以及在 Result 中的大小
macro_rules! show_size {
    (header) =&gt; {
        println!(
            &quot;{:&lt;24} {:&gt;4}    {}    {}&quot;,
            &quot;Type&quot;, &quot;T&quot;, &quot;Option&lt;T&gt;&quot;, &quot;Result&lt;T, io::Error&gt;&quot;
        );
        println!(&quot;{}&quot;, &quot;-&quot;.repeat(64));
    };
    ($t:ty) =&gt; {
        println!(
            &quot;{:&lt;24} {:4} {:8} {:12}&quot;,
            stringify!($t),
            size_of::&lt;$t&gt;(),
            size_of::&lt;Option&lt;$t&gt;&gt;(),
            size_of::&lt;Result&lt;$t, std::io::Error&gt;&gt;(),
        )
    };
}

fn main() {
    show_size!(header);
    show_size!(u8);
    show_size!(f64);
    show_size!(&amp;u8);
    show_size!(Box&lt;u8&gt;);
    show_size!(&amp;[u8]);

    show_size!(String);
    show_size!(Vec&lt;u8&gt;);
    show_size!(HashMap&lt;String, String&gt;);
    show_size!(MyEnum);
}</code></pre></pre>
<p>但是 Rust 编译器会对 enum 做一些额外的优化，让某些常用结构的内存布局更紧凑。Option 配合带有引用类型的数据结构，比如 &amp;u8、Box、Vec、HashMap ，没有额外占用空间。引用类型的第一个域是个指针，而指针是不可能等于 0 的，通过复用这个指针：当其为 0 时，表示 None，否则是 Some，减少了内存占用。</p>
<h2 id="线程安全的全局变量-lazy_static"><a class="header" href="#线程安全的全局变量-lazy_static">线程安全的全局变量 (lazy_static)</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use lazy_static::lazy_static;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

lazy_static! {
    static ref HASHMAP: Arc&lt;Mutex&lt;HashMap&lt;u32, &amp;'static str&gt;&gt;&gt; = {
        let mut m = HashMap::new();
        m.insert(0, &quot;foo&quot;);
        m.insert(1, &quot;bar&quot;);
        m.insert(2, &quot;baz&quot;);
        Arc::new(Mutex::new(m))
    };
}

fn main() {
    let mut map = HASHMAP.lock().unwrap();
    map.insert(3, &quot;waz&quot;);

    println!(&quot;map: {:?}&quot;, map);
}</code></pre></pre>
<h2 id="带关联类型的-trait"><a class="header" href="#带关联类型的-trait">带关联类型的 trait</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use std::str::FromStr;

use lazy_static::lazy_static;
use regex::Regex;

pub trait ParseFromStr {
    type Error;
    fn parse_from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Error&gt;
    where
        Self: Sized;
}

impl&lt;T&gt; ParseFromStr for T
where
    T: FromStr,
{
    // 定义关联类型 Error 为 String
    type Error = String;

    fn parse_from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Error&gt; {
        // ensure that regular expressions are compiled exactly once.
        lazy_static! {
            static ref RE: Regex = Regex::new(r&quot;^\d+(\.\d+)?&quot;).unwrap();
        };
        if let Some(captures) = RE.captures(s) {
            captures
                .get(0)
                .map_or(Err(&quot;failed to capture&quot;.to_string()), |s| {
                    s.as_str()
                        .parse()
                        .map_err(|_e| &quot;failed to parse captured string&quot;.to_string())
                })
        } else {
            Err(&quot;failed to parse string&quot;.to_string())
        }
    }
}

fn main() {
    println!(&quot;result: {}&quot;, u8::parse_from_str(&quot;255 hello&quot;).unwrap());
    println!(&quot;result: {}&quot;, u8::parse_from_str(&quot;001 world&quot;).unwrap());
    println!(&quot;result: {}&quot;, u8::parse_from_str(&quot;!&quot;).unwrap_or_default());
    println!(&quot;result: {}&quot;, f64::parse_from_str(&quot;123.45abc&quot;).unwrap());
}</code></pre></pre>
<h2 id="trait-object-的实现机制"><a class="header" href="#trait-object-的实现机制">trait object 的实现机制</a></h2>
<p><img src="../images/rust/trait-object.webp" alt="trait object 的内存布局" /></p>
<p>trait object 的底层逻辑就是旁指针，其中一个指针指向数据本身，另一个则指向虚函数表（vtable）。vtable 是一张静态的表，Rust 在编译时会为使用了 trait object 的类型的 trait 实现生成一张表，放在可执行文件中（一般在text或rodata段）。</p>
<p>如果 trait <strong>所有</strong>的方法，返回值是 Self 或者携带泛型参数，那么这个 trait 就不能产生 trait object。trait object 在产生时，原来的类型会被抹去，所以 Self 究竟是谁不知道。Rust 里带泛型的类型在编译时会做<strong>单态化</strong>，而 trait object 是运行时的产物，两者不能兼容。<strong>如果一个 trait 只有部分方法返回 Self 或者携带泛型参数，那么这部分方法在 trait object 中不能被调用</strong>。</p>
<h2 id="常用-trait-介绍"><a class="header" href="#常用-trait-介绍">常用 trait 介绍</a></h2>
<h3 id="clone"><a class="header" href="#clone">Clone</a></h3>
<p>Clone 是深度拷贝，栈内存和堆内存一起拷贝。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Clone {
    // 在 clone 一个数据时只需要有已有数据的只读引用
    fn clone(&amp;self) -&gt; Self;

    fn clone_from(&amp;mut self, source: &amp;Self) {
        *self = source.clone()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="copy"><a class="header" href="#copy">Copy</a></h3>
<p>Copy trait 没有任何额外的方法，它只是一个标记 trait，可以用作 trait bound 来进行类型安全检查。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 如果要实现 Copy trait 的话，必须实现 Clone trait。
pub trait Copy: Clone {}
<span class="boring">}</span></code></pre></pre>
<h3 id="drop"><a class="header" href="#drop">Drop</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Drop {
    fn drop(&amp;mut self);
}
<span class="boring">}</span></code></pre></pre>
<p>大部分场景无需为数据结构提供 Drop trait，系统默认会依次对数据结构的每个域做 drop。但有两种情况需要手动实现 Drop:</p>
<ol>
<li>希望在数据结束生命周期的时候做一些事情，比如记录日志</li>
<li>需要对资源进行回收，比如锁资源的释放</li>
</ol>
<p><strong>Copy trait 和 Drop trait 是互斥的，两者不能共存</strong>。因为 Copy 是按位做浅拷贝，它拷贝的数据没有需要释放的资源，而 Drop 恰恰是为了释放额外的资源而生的。</p>
<h3 id="sized"><a class="header" href="#sized">Sized</a></h3>
<p>Sized trait 用于标记有具体大小的类型。在使用泛型参数时，Rust 编译器会自动为泛型参数加上 Sized 约束。如果开发者显式定义了T: ?Sized，那么 T 就可以是任意大小。</p>
<h3 id="send--sync-用于并发安全"><a class="header" href="#send--sync-用于并发安全">Send / Sync 用于并发安全</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe auto trait Send {}
pub unsafe auto trait Sync {}
<span class="boring">}</span></code></pre></pre>
<p>这里的 <code>auto</code> 意味着编译器会在合适的场合，自动为数据结构添加它们的实现。</p>
<p>如果一个类型 T 实现了 Send trait,意味着 T 可以安全地从一个线程移动到另一个线程，即所有权可以在线程间移动。
如果一个类型 T 实现了 Sync trait,意味着 &amp;T 可以安全地在多个线程间共享。</p>
<p>对于 Send/Sync 在线程安全中的作用：如果一个类型 <code>T: Send</code>，那么 T 在某个线程中的<strong>独占访问</strong>是线程安全的；如果一个类型 <code>T: Sync</code>，那么 T 在线程间的<strong>只读共享</strong>是安全的。</p>
<p>引用计数 <code>Rc&lt;T&gt;</code> 不支持 Send 也不支持 Sync。所以 <code>Rc&lt;T&gt;</code> 无法跨线程。
<code>RefCell&lt;T&gt;</code> 实现了 Send，所以可以在线程间转移所有权。但没有实现 Sync，因此无法跨线程使用 <code>Arc&lt;RefCell&lt;T&gt;&gt;</code> 这样的数据（因为 Arc 内部的数据是共享的，需要支持 Sync 的数据结构）。</p>
<h3 id="fromt--intot-用于从值到值的转换"><a class="header" href="#fromt--intot-用于从值到值的转换">From&lt;T&gt; / Into&lt;T&gt; 用于从值到值的转换</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait From&lt;T&gt; {
    fn from(t: T) -&gt; Self;
}

pub trait Into&lt;T&gt; {
    fn into(self) -&gt; T;
}

// 实现 From 会自动实现 Into
impl&lt;T, U&gt; Into&lt;U&gt; for T where U: From&lt;T&gt; {
    fn into(self) -&gt; U {
        U::from(self)
    }
}

// From（以及 Into）是自反的：把类型 T 的值转换成类型 T,会直接返回
impl&lt;T&gt; From&lt;T&gt; for T {
    fn from(t: T) -&gt; T {
        t
    }
}
<span class="boring">}</span></code></pre></pre>
<p>有了这两个 trait,函数的接口就可以变得灵活，比如函数如果接受一个 IpAddr 为参数，那就可以使用 <code>Into&lt;IpAddr&gt;</code> 让更多的类型可以被这个函数使用。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};

fn print(v: impl Into&lt;IpAddr&gt;) {
    println!(&quot;{:?}&quot;, v.into());
}

fn main() {
    let v4: Ipv4Addr = &quot;2.2.2.2&quot;.parse().unwrap();
    let v6: Ipv6Addr = &quot;::1&quot;.parse().unwrap();

    // IPAddr 实现了 From&lt;[u8; 4]，转换 IPv4 地址
    print([1, 1, 1, 1]);
    // IPAddr 实现了 From&lt;[u16; 8]，转换 IPv6 地址
    print([0xfe80, 0, 0, 0, 0xaede, 0x48ff, 0xfe00, 0x1122]);
    // IPAddr 实现了 From&lt;Ipv4Addr&gt;
    print(v4);
    // IPAddr 实现了 From&lt;Ipv6Addr&gt;
    print(v6);
}</code></pre></pre>
<p>如果数据类型在转换过程中有可能出现错误，就需要使用 TryFrom&lt;T&gt; 和 TryInto&lt;T&gt;。</p>
<h3 id="asreft--asmutt-用于从引用到引用的转换"><a class="header" href="#asreft--asmutt-用于从引用到引用的转换">AsRef&lt;T&gt; / AsMut&lt;T&gt; 用于从引用到引用的转换</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// T 使用大小可变的类型，如 str、[u8] 等
pub trait AsRef&lt;T&gt; where T: ?Sized {
    fn as_ref(&amp;self) -&gt; &amp;T;
}

pub trait AsMut&lt;T&gt; where T: ?Sized {
    fn as_mut(&amp;mut self) -&gt; &amp;mut T;
}
<span class="boring">}</span></code></pre></pre>
<p>标准库中打开文件的接口 <code>std::fs::File::open</code></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn open&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;File&gt;
<span class="boring">}</span></code></pre></pre>
<p>意味着我们可以为这个参数传入 String、&amp;str、PathBuf、Path 等类型，当使用 <code>path.as_ref()</code> 时，就能得到一个 <code>&amp;Path</code>。</p>
<h3 id="deref--derefmut"><a class="header" href="#deref--derefmut">Deref / DerefMut</a></h3>
<p>Rust 为所有的运算符都提供了 trait，我们可以给自定义类型重载某些操作符。</p>
<p><img src="../images/rust/operators.webp" alt="操作运算符" /></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Deref {
    // 解引用出来的结果类型
    type Target: ?Sized;
    fn deref(&amp;self) -&gt; &amp;Self::Target;
}

// DerefMut “继承”了 Deref
pub trait DerefMut: Deref {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Deref 和 DerefMut 是自动调用的，<code>*b</code> 会被展开为 <code>*(b.deref())</code></strong>。</p>
<p><img src="../images/rust/deref.webp" alt="deref" /></p>
<h3 id="debug--display"><a class="header" href="#debug--display">Debug / Display</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Debug {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}

pub trait Display {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Debug 是为开发者调试打印数据结构所设计的，而 Display 是给用户显示数据结构所设计的。Debug trait 的实现可以通过派生宏直接生成，而 <strong>Display 必须手工实现</strong>。在使用的时候，Debug 用 {:?} 来打印，Display 用 {} 打印。</p>
<h3 id="default-为类型提供缺省值"><a class="header" href="#default-为类型提供缺省值">Default 为类型提供缺省值</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Default {
    fn default() -&gt; Self;
}
<span class="boring">}</span></code></pre></pre>
<p>可以通过 derive 宏 #[derive(Default)] 来生成实现，前提是类型中的每个字段都实现了 Default trait。注意，enum 不能通过 derive 宏来实现 Default，因为 enum 的每个变体都可能有不同的字段，所以需要手动实现。</p>
<p>在初始化一个数据结构时，我们可以部分初始化，然后剩余的部分使用 <code>..Default::default()</code>。</p>
<h2 id="智能指针"><a class="header" href="#智能指针">智能指针</a></h2>
<h3 id="智能指针-vs-胖指针"><a class="header" href="#智能指针-vs-胖指针">智能指针 vs 胖指针</a></h3>
<p>智能指针一定是胖指针（比如 <code>String</code>），但是胖指针不一定是一个智能指针（比如 <code>&amp;str</code>），因为 String 对堆上的值有所有权，而 &amp;str 没有所有权。</p>
<h3 id="智能指针-vs-结构体"><a class="header" href="#智能指针-vs-结构体">智能指针 vs 结构体</a></h3>
<p>凡是需要做资源回收的数据结构，且实现了 <code>Deref/DerefMut/Drop</code>，都是智能指针。</p>
<h2 id="替换默认的内存分配器"><a class="header" href="#替换默认的内存分配器">替换默认的内存分配器</a></h2>
<p>堆上分配内存的 <code>Box&lt;T&gt;</code> 有一个缺省的泛型参数 <code>A</code>，需要满足 <code>Allocator</code>，并且默认是 <code>Global</code>，这个 <code>Global</code> 就是默认的内存分配器。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use jemallocator::Jemalloc;

#[global_allocator]
static GLOBAL: Jemalloc = Jemalloc;

fn main() {}</code></pre></pre>
<p>如果想要编写一个全局分配器，可以实现 <code>GlobalAlloc</code> trait，它和 <code>Allocator</code> trait 的主要区别在于是否允许分配长度为0的内存。</p>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<ul>
<li><a href="https://cheats.rs/">cheats.rs</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../cs/openwrt.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../ee/control-system.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../cs/openwrt.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../ee/control-system.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>

<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust - 🐏🐒 suda-morris 个人博客 🐇</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Personal Blog">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../about-me.html">关于我</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">体系结构</li><li class="chapter-item expanded "><a href="../cs/riscv.html"><strong aria-hidden="true">1.</strong> RISC-V</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">编译系统</li><li class="chapter-item expanded "><a href="../cs/gcc-toolchains.html"><strong aria-hidden="true">2.</strong> GCC</a></li><li class="chapter-item expanded "><a href="../cs/cmake.html"><strong aria-hidden="true">3.</strong> CMake</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">操作系统</li><li class="chapter-item expanded "><a href="../cs/openwrt.html"><strong aria-hidden="true">4.</strong> OpenWRT</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">编程语言</li><li class="chapter-item expanded "><a href="../cs/rust.html" class="active"><strong aria-hidden="true">5.</strong> Rust</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">控制系统</li><li class="chapter-item expanded "><a href="../ee/control-system.html"><strong aria-hidden="true">6.</strong> 控制系统基础</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">测试框架</li><li class="chapter-item expanded "><a href="../cs/pytest.html"><strong aria-hidden="true">7.</strong> pytest</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">多媒体</li><li class="chapter-item expanded "><a href="../cs/video-process.html"><strong aria-hidden="true">8.</strong> 视频处理</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">通信协议</li><li class="chapter-item expanded "><a href="../ee/usb.html"><strong aria-hidden="true">9.</strong> USB 协议基础</a></li><li class="chapter-item expanded "><a href="../ee/can.html"><strong aria-hidden="true">10.</strong> CAN 协议基础</a></li><li class="chapter-item expanded "><a href="../ee/mipi.html"><strong aria-hidden="true">11.</strong> MIPI 协议基础</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">电路设计</li><li class="chapter-item expanded "><a href="../ee/yosys.html"><strong aria-hidden="true">12.</strong> Yosys</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">前端</li><li class="chapter-item expanded "><a href="../cs/tauri.html"><strong aria-hidden="true">13.</strong> Tauri</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">管理</li><li class="chapter-item expanded "><a href="../cs/git.html"><strong aria-hidden="true">14.</strong> git</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">演示</li><li class="chapter-item expanded "><a href="../ux/slides-tool.html"><strong aria-hidden="true">15.</strong> slides 工具</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">🐏🐒 suda-morris 个人博客 🐇</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/suda-morris/blog" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/suda-morris/blog/edit/master/src/cs/rust.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-知识碎片"><a class="header" href="#rust-知识碎片">Rust 知识碎片</a></h1>
<h2 id="编译过程"><a class="header" href="#编译过程">编译过程</a></h2>
<p><img src="../images/rust/compile-process.png" alt="Rust 编译过程" /></p>
<ol>
<li>分词：把词法结构处理成词条流</li>
<li>词条流经过语法解析形成抽象语法树</li>
<li>抽象语法树简化成高级中间语言 (HIR)，编译器对 HIR 进行类型检查、方法查找等工作</li>
<li>HIR 进一步简化形成中级中间语言 (MIR)，编译器对 MIR 进行借用检查、优化等工作，在 MIR 中已经看不到 Rust 各版次的差异了</li>
<li>产生 LLVM 中间语言</li>
<li>LLVM 后端会对 LLVM 中间语言进行优化，最终生成机器代码</li>
</ol>
<h2 id="常用数据结构"><a class="header" href="#常用数据结构">常用数据结构</a></h2>
<p><img src="../images/rust/data-structure.webp" alt="数据结构" /></p>
<h2 id="值放堆上还是栈上"><a class="header" href="#值放堆上还是栈上">值放堆上还是栈上</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello world&quot;.to_string();
println!(&quot;'hello world': {:p}, s: {:p}, len: {}, capacity: {}, size: {}&quot;,
        &amp;&quot;hello world&quot;, &amp;s, s.len(), s.capacity(), std::mem::size_of_val(&amp;s));
<span class="boring">}</span></code></pre></pre>
<p><img src="../images/rust/string-in-memory.webp" alt="string的内存布局" /></p>
<blockquote>
<p>栈上存放的数据是静态的，固定大小，固定生命周期；堆上存放的数据是动态的，不固定大小，不固定生命周期。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static MAX: u32 = 0;
fn foo() {}
let hello = &quot;hello world&quot;.to_string();
let data = Box::new(1);

// string literals 指向 RODATA 地址
println!(&quot;RODATA: {:p}&quot;, &quot;hello world!&quot;);
// static 变量在 DATA section
println!(&quot;DATA (static var): {:p}&quot;, &amp;MAX);
// function 在 TEXT
println!(&quot;TEXT (function): {:p}&quot;, foo as *const ());
// String 结构体分配在栈上，所以其引用指向一个栈地址
println!(&quot;STACK (&amp;hello): {:p}&quot;, &amp;hello);
// 需要通过解引用获取其堆上数据，然后取其引用
println!(&quot;HEAP (&amp;*hello): {:p}&quot;, &amp;*hello);
// Box 实现了 Pointer trait 无需额外解引用
println!(&quot;HEAP (box impl Pointer) {:p} {:p}&quot;, data, &amp;*data);
<span class="boring">}</span></code></pre></pre>
<h2 id="move-copy-borrow"><a class="header" href="#move-copy-borrow">move, copy, borrow</a></h2>
<p><img src="../images/rust/move-copy-borrow.jpg" alt="move, copy, borrow" /></p>
<p>其实 Copy 和 Move 在内部实现上，都是浅层的<strong>按位</strong>做内存复制，只不过 Copy 允许你访问之前的变量，而 Move 不允许。</p>
<h3 id="关于内存复制上的误区"><a class="header" href="#关于内存复制上的误区">关于内存复制上的误区</a></h3>
<p>如果代码的关键路径中的每次都要复制几百 k 的数据（比如一个大数组），这是很低效的。但是，如果要复制的只是原生类型（Copy）或者栈上的胖指针（Move），不涉及堆内存的复制（即没有做深拷贝（deep copy）），那这个效率是非常高的，不必担心每次赋值或者每次传参带来的性能损失。</p>
<p>Rust 的集合类型会在使用过程中自动扩展。以一个 Vec 为例，当使用完堆内存当前容量后，还继续添加新的内容，就会触发堆内存的自动增长。有时候，集合类型里的数据不断进进出出，导致集合一直增长，但实际只使用了很小部分的容量，导致内存的使用效率很低，这时可以考虑使用 <code>shrink_to_fit</code> 方法来节约对内存的使用。</p>
<h2 id="所有权"><a class="header" href="#所有权">所有权</a></h2>
<p><img src="../images/rust/ownership.webp" alt="ownership" /></p>
<h3 id="所有权的静态检查和动态检查"><a class="header" href="#所有权的静态检查和动态检查">所有权的静态检查和动态检查</a></h3>
<p>在所有权模型下，堆内存的生命周期，和创建它的栈内存的生命周期保持一致。编译器可以保证代码符合所有权规则（静态检查）。</p>
<p>动态检查，通过 <code>Box::leak()</code> 让堆内存拥有不受限制的生命周期，然后在运行过程中，通过对引用计数的检查，保证这样的堆内存最终会得到释放。</p>
<h3 id="外部可变性与内部可变性"><a class="header" href="#外部可变性与内部可变性">外部可变性与内部可变性</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th>使用方法</th><th>所有权检查</th></tr></thead><tbody>
<tr><td>外部可变性</td><td><code>let mut</code> 或者 <code>&amp;mut</code></td><td>编译时，如果不符合规则，产生编译错误</td></tr>
<tr><td>内部可变性</td><td>使用 Cell/RefCell</td><td>运行时，如果不符合规则，产生 panic</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust edition2021">use std::cell::RefCell;

fn main() {
    let data = RefCell::new(1);
    // 根据所有权规则，在同一个作用域下，不能同时有活跃的可变借用和不可变借用
    // 通过这对花括号，我们缩小了可变借用的生命周期
    {
        // 获得 RefCell 内部数据的可变借用
        let mut v = data.borrow_mut();
        *v += 1;
    }
    println!(&quot;data: {:?}&quot;, data.borrow());
}</code></pre></pre>
<h2 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">pub fn strtok&lt;'a&gt;(s: &amp;mut &amp;'a str, delimiter: char) -&gt; &amp;'a str {
    if let Some(i) = s.find(delimiter) {
        let prefix = &amp;s[..i];
        // 由于 delimiter 可以是 utf8，所以我们需要获得其 utf8 长度，
        // 直接使用 len 返回的是字节长度，会有问题
        let suffix = &amp;s[(i + delimiter.len_utf8())..];
        *s = suffix;
        prefix
    } else {
        // 如果没找到，返回整个字符串，把原字符串指针 s 指向空串
        let prefix = *s;
        *s = &quot;&quot;;
        prefix
    }
}

fn main() {
    let s = String::from(&quot;hello world&quot;);
    let mut s1 = s.as_str();
    let hello = strtok(&amp;mut s1, ' ');
    println!(&quot;hello is: {}, s1: {}, s: {}&quot;, hello, s1, s);
}</code></pre></pre>
<p><img src="../images/rust/lifetime-example.webp" alt="lifetime" /></p>
<blockquote>
<p>注意：当你要返回在函数执行过程中，创建的或者得到的数据，和参数无关，那么无论它是一个有所有权的数据，还是一个引用，你只能返回带所有权的数据。对于引用，这就意味着调用 <code>clone()</code> 或者 <code>to_owned()</code> 来从引用中得到所有权。</p>
</blockquote>
<h2 id="结构体成员自动重排"><a class="header" href="#结构体成员自动重排">结构体成员自动重排</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use std::mem::{align_of, size_of};

struct S1 {
    a: u8,
    b: u16,
    c: u8,
}

struct S2 {
    a: u8,
    c: u8,
    b: u16,
}

#[repr(C)]
struct S3 {
    a: u8,
    b: u16,
    c: u8,
}

fn main() {
    println!(
        &quot;sizeof S1: {}, S2: {}, S3: {}&quot;,
        size_of::&lt;S1&gt;(),
        size_of::&lt;S2&gt;(),
        size_of::&lt;S3&gt;()
    );
    println!(
        &quot;alignof S1: {}, S2: {}, S3: {}&quot;,
        align_of::&lt;S1&gt;(),
        align_of::&lt;S2&gt;(),
        align_of::&lt;S3&gt;()
    );
}</code></pre></pre>
<p>Rust 编译器默会优化结构体的排列，但我们也可以使用 <code>#[repr]</code> 宏，强制让 Rust 编译器不做优化，和 C 的行为一致，这样，Rust 代码可以方便地和 C 代码无缝交互。</p>
<h2 id="enum-的内存布局"><a class="header" href="#enum-的内存布局">enum 的内存布局</a></h2>
<p><img src="../images/rust/enum-memory-layout.webp" alt="enum" /></p>
<p>enum 是一个标签联合体（tagged union），它的大小是标签的大小，加上最大类型的长度。所以对于 <code>Option&lt;u8&gt;</code>，其长度是 1 + 1 = 2 字节，而 <code>Option&lt;f64&gt;</code>，长度是 8 + 8 =16 字节。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::HashMap;
use std::mem::size_of;

enum MyEnum {
    A(f64),
    B(HashMap&lt;String, String&gt;),
    C(Result&lt;Vec&lt;u8&gt;, String&gt;),
}

// 这是一个声明宏，它会打印各种数据结构本身的大小，在 Option 中的大小，以及在 Result 中的大小
macro_rules! show_size {
    (header) =&gt; {
        println!(
            &quot;{:&lt;24} {:&gt;4}    {}    {}&quot;,
            &quot;Type&quot;, &quot;T&quot;, &quot;Option&lt;T&gt;&quot;, &quot;Result&lt;T, io::Error&gt;&quot;
        );
        println!(&quot;{}&quot;, &quot;-&quot;.repeat(64));
    };
    ($t:ty) =&gt; {
        println!(
            &quot;{:&lt;24} {:4} {:8} {:12}&quot;,
            stringify!($t),
            size_of::&lt;$t&gt;(),
            size_of::&lt;Option&lt;$t&gt;&gt;(),
            size_of::&lt;Result&lt;$t, std::io::Error&gt;&gt;(),
        )
    };
}

fn main() {
    show_size!(header);
    show_size!(u8);
    show_size!(f64);
    show_size!(&amp;u8);
    show_size!(Box&lt;u8&gt;);
    show_size!(&amp;[u8]);

    show_size!(String);
    show_size!(Vec&lt;u8&gt;);
    show_size!(HashMap&lt;String, String&gt;);
    show_size!(MyEnum);
}</code></pre></pre>
<p>但是 Rust 编译器会对 enum 做一些额外的优化，让某些常用结构的内存布局更紧凑。Option 配合带有引用类型的数据结构，比如 &amp;u8、Box、Vec、HashMap ，没有额外占用空间。引用类型的第一个域是个指针，而指针是不可能等于 0 的，通过复用这个指针：当其为 0 时，表示 None，否则是 Some，减少了内存占用。</p>
<h2 id="线程安全的全局变量-lazy_static"><a class="header" href="#线程安全的全局变量-lazy_static">线程安全的全局变量 (lazy_static)</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use lazy_static::lazy_static;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

lazy_static! {
    static ref HASHMAP: Arc&lt;Mutex&lt;HashMap&lt;u32, &amp;'static str&gt;&gt;&gt; = {
        let mut m = HashMap::new();
        m.insert(0, &quot;foo&quot;);
        m.insert(1, &quot;bar&quot;);
        m.insert(2, &quot;baz&quot;);
        Arc::new(Mutex::new(m))
    };
}

fn main() {
    let mut map = HASHMAP.lock().unwrap();
    map.insert(3, &quot;waz&quot;);

    println!(&quot;map: {:?}&quot;, map);
}</code></pre></pre>
<h2 id="带关联类型的-trait"><a class="header" href="#带关联类型的-trait">带关联类型的 trait</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use std::str::FromStr;

use lazy_static::lazy_static;
use regex::Regex;

pub trait ParseFromStr {
    type Error;
    fn parse_from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Error&gt;
    where
        Self: Sized;
}

impl&lt;T&gt; ParseFromStr for T
where
    T: FromStr,
{
    // 定义关联类型 Error 为 String
    type Error = String;

    fn parse_from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Error&gt; {
        // ensure that regular expressions are compiled exactly once.
        lazy_static! {
            static ref RE: Regex = Regex::new(r&quot;^\d+(\.\d+)?&quot;).unwrap();
        };
        if let Some(captures) = RE.captures(s) {
            captures
                .get(0)
                .map_or(Err(&quot;failed to capture&quot;.to_string()), |s| {
                    s.as_str()
                        .parse()
                        .map_err(|_e| &quot;failed to parse captured string&quot;.to_string())
                })
        } else {
            Err(&quot;failed to parse string&quot;.to_string())
        }
    }
}

fn main() {
    println!(&quot;result: {}&quot;, u8::parse_from_str(&quot;255 hello&quot;).unwrap());
    println!(&quot;result: {}&quot;, u8::parse_from_str(&quot;001 world&quot;).unwrap());
    println!(&quot;result: {}&quot;, u8::parse_from_str(&quot;!&quot;).unwrap_or_default());
    println!(&quot;result: {}&quot;, f64::parse_from_str(&quot;123.45abc&quot;).unwrap());
}</code></pre></pre>
<h2 id="trait-object-的实现机制"><a class="header" href="#trait-object-的实现机制">trait object 的实现机制</a></h2>
<p><img src="../images/rust/trait-object.webp" alt="trait object 的内存布局" /></p>
<p>trait object 的底层逻辑就是旁指针，其中一个指针指向数据本身，另一个则指向虚函数表（vtable）。vtable 是一张静态的表，Rust 在编译时会为使用了 trait object 的类型的 trait 实现生成一张表，放在可执行文件中（一般在text或rodata段）。</p>
<p>如果 trait <strong>所有</strong>的方法，返回值是 Self 或者携带泛型参数，那么这个 trait 就不能产生 trait object。trait object 在产生时，原来的类型会被抹去，所以 Self 究竟是谁不知道。Rust 里带泛型的类型在编译时会做<strong>单态化</strong>，而 trait object 是运行时的产物，两者不能兼容。<strong>如果一个 trait 只有部分方法返回 Self 或者携带泛型参数，那么这部分方法在 trait object 中不能被调用</strong>。</p>
<h2 id="常用-trait-介绍"><a class="header" href="#常用-trait-介绍">常用 trait 介绍</a></h2>
<h3 id="clone"><a class="header" href="#clone">Clone</a></h3>
<p>Clone 是深度拷贝，栈内存和堆内存一起拷贝。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Clone {
    // 在 clone 一个数据时只需要有已有数据的只读引用
    fn clone(&amp;self) -&gt; Self;

    fn clone_from(&amp;mut self, source: &amp;Self) {
        *self = source.clone()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="copy"><a class="header" href="#copy">Copy</a></h3>
<p>Copy trait 没有任何额外的方法，它只是一个标记 trait，可以用作 trait bound 来进行类型安全检查。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 如果要实现 Copy trait 的话，必须实现 Clone trait。
pub trait Copy: Clone {}
<span class="boring">}</span></code></pre></pre>
<h3 id="drop"><a class="header" href="#drop">Drop</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Drop {
    fn drop(&amp;mut self);
}
<span class="boring">}</span></code></pre></pre>
<p>大部分场景无需为数据结构提供 Drop trait，系统默认会依次对数据结构的每个域做 drop。但有两种情况需要手动实现 Drop:</p>
<ol>
<li>希望在数据结束生命周期的时候做一些事情，比如记录日志</li>
<li>需要对资源进行回收，比如锁资源的释放</li>
</ol>
<p><strong>Copy trait 和 Drop trait 是互斥的，两者不能共存</strong>。因为 Copy 是按位做浅拷贝，它拷贝的数据没有需要释放的资源，而 Drop 恰恰是为了释放额外的资源而生的。</p>
<h3 id="sized"><a class="header" href="#sized">Sized</a></h3>
<p>Sized trait 用于标记有具体大小的类型。在使用泛型参数时，Rust 编译器会自动为泛型参数加上 Sized 约束。如果开发者显式定义了T: ?Sized，那么 T 就可以是任意大小。</p>
<h3 id="send--sync-用于并发安全"><a class="header" href="#send--sync-用于并发安全">Send / Sync 用于并发安全</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe auto trait Send {}
pub unsafe auto trait Sync {}
<span class="boring">}</span></code></pre></pre>
<p>这里的 <code>auto</code> 意味着编译器会在合适的场合，自动为数据结构添加它们的实现。</p>
<p>如果一个类型 T 实现了 Send trait,意味着 T 可以安全地从一个线程移动到另一个线程，即所有权可以在线程间移动。
如果一个类型 T 实现了 Sync trait,意味着 &amp;T 可以安全地在多个线程间共享。</p>
<p>对于 Send/Sync 在线程安全中的作用：如果一个类型 <code>T: Send</code>，那么 T 在某个线程中的<strong>独占访问</strong>是线程安全的；如果一个类型 <code>T: Sync</code>，那么 T 在线程间的<strong>只读共享</strong>是安全的。</p>
<p>引用计数 <code>Rc&lt;T&gt;</code> 不支持 Send 也不支持 Sync。所以 <code>Rc&lt;T&gt;</code> 无法跨线程。
<code>RefCell&lt;T&gt;</code> 实现了 Send，所以可以在线程间转移所有权。但没有实现 Sync，因此无法跨线程使用 <code>Arc&lt;RefCell&lt;T&gt;&gt;</code> 这样的数据（因为 Arc 内部的数据是共享的，需要支持 Sync 的数据结构）。</p>
<h3 id="fromt--intot-用于从值到值的转换"><a class="header" href="#fromt--intot-用于从值到值的转换">From&lt;T&gt; / Into&lt;T&gt; 用于从值到值的转换</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait From&lt;T&gt; {
    fn from(t: T) -&gt; Self;
}

pub trait Into&lt;T&gt; {
    fn into(self) -&gt; T;
}

// 实现 From 会自动实现 Into
impl&lt;T, U&gt; Into&lt;U&gt; for T where U: From&lt;T&gt; {
    fn into(self) -&gt; U {
        U::from(self)
    }
}

// From（以及 Into）是自反的：把类型 T 的值转换成类型 T,会直接返回
impl&lt;T&gt; From&lt;T&gt; for T {
    fn from(t: T) -&gt; T {
        t
    }
}
<span class="boring">}</span></code></pre></pre>
<p>有了这两个 trait,函数的接口就可以变得灵活，比如函数如果接受一个 IpAddr 为参数，那就可以使用 <code>Into&lt;IpAddr&gt;</code> 让更多的类型可以被这个函数使用。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};

fn print(v: impl Into&lt;IpAddr&gt;) {
    println!(&quot;{:?}&quot;, v.into());
}

fn main() {
    let v4: Ipv4Addr = &quot;2.2.2.2&quot;.parse().unwrap();
    let v6: Ipv6Addr = &quot;::1&quot;.parse().unwrap();

    // IPAddr 实现了 From&lt;[u8; 4]，转换 IPv4 地址
    print([1, 1, 1, 1]);
    // IPAddr 实现了 From&lt;[u16; 8]，转换 IPv6 地址
    print([0xfe80, 0, 0, 0, 0xaede, 0x48ff, 0xfe00, 0x1122]);
    // IPAddr 实现了 From&lt;Ipv4Addr&gt;
    print(v4);
    // IPAddr 实现了 From&lt;Ipv6Addr&gt;
    print(v6);
}</code></pre></pre>
<p>如果数据类型在转换过程中有可能出现错误，就需要使用 TryFrom&lt;T&gt; 和 TryInto&lt;T&gt;。</p>
<h3 id="asreft--asmutt-用于从引用到引用的转换"><a class="header" href="#asreft--asmutt-用于从引用到引用的转换">AsRef&lt;T&gt; / AsMut&lt;T&gt; 用于从引用到引用的转换</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// T 使用大小可变的类型，如 str、[u8] 等
pub trait AsRef&lt;T&gt; where T: ?Sized {
    fn as_ref(&amp;self) -&gt; &amp;T;
}

pub trait AsMut&lt;T&gt; where T: ?Sized {
    fn as_mut(&amp;mut self) -&gt; &amp;mut T;
}
<span class="boring">}</span></code></pre></pre>
<p>标准库中打开文件的接口 <code>std::fs::File::open</code></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn open&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;File&gt;
<span class="boring">}</span></code></pre></pre>
<p>意味着我们可以为这个参数传入 String、&amp;str、PathBuf、Path 等类型，当使用 <code>path.as_ref()</code> 时，就能得到一个 <code>&amp;Path</code>。</p>
<h3 id="deref--derefmut"><a class="header" href="#deref--derefmut">Deref / DerefMut</a></h3>
<p>Rust 为所有的运算符都提供了 trait，我们可以给自定义类型重载某些操作符。</p>
<p><img src="../images/rust/operators.webp" alt="操作运算符" /></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Deref {
    // 解引用出来的结果类型
    type Target: ?Sized;
    fn deref(&amp;self) -&gt; &amp;Self::Target;
}

// DerefMut “继承”了 Deref
pub trait DerefMut: Deref {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Deref 和 DerefMut 是自动调用的，<code>*b</code> 会被展开为 <code>*(b.deref())</code></strong>。</p>
<p><img src="../images/rust/deref.webp" alt="deref" /></p>
<h3 id="debug--display"><a class="header" href="#debug--display">Debug / Display</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Debug {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}

pub trait Display {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Debug 是为开发者调试打印数据结构所设计的，而 Display 是给用户显示数据结构所设计的。Debug trait 的实现可以通过派生宏直接生成，而 <strong>Display 必须手工实现</strong>。在使用的时候，Debug 用 {:?} 来打印，Display 用 {} 打印。</p>
<h3 id="default-为类型提供缺省值"><a class="header" href="#default-为类型提供缺省值">Default 为类型提供缺省值</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Default {
    fn default() -&gt; Self;
}
<span class="boring">}</span></code></pre></pre>
<p>可以通过 derive 宏 #[derive(Default)] 来生成实现，前提是类型中的每个字段都实现了 Default trait。注意，enum 不能通过 derive 宏来实现 Default，因为 enum 的每个变体都可能有不同的字段，所以需要手动实现。</p>
<p>在初始化一个数据结构时，我们可以部分初始化，然后剩余的部分使用 <code>..Default::default()</code>。</p>
<h2 id="智能指针"><a class="header" href="#智能指针">智能指针</a></h2>
<h3 id="智能指针-vs-胖指针"><a class="header" href="#智能指针-vs-胖指针">智能指针 vs 胖指针</a></h3>
<p>智能指针一定是胖指针（比如 <code>String</code>），但是胖指针不一定是一个智能指针（比如 <code>&amp;str</code>），因为 String 对堆上的值有所有权，而 &amp;str 没有所有权。</p>
<h3 id="智能指针-vs-结构体"><a class="header" href="#智能指针-vs-结构体">智能指针 vs 结构体</a></h3>
<p>凡是需要做资源回收的数据结构，且实现了 <code>Deref/DerefMut/Drop</code>，都是智能指针。</p>
<h3 id="boxt"><a class="header" href="#boxt">Box&lt;T&gt;</a></h3>
<h4 id="new-方法"><a class="header" href="#new-方法"><code>new</code> 方法</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[cfg(not(no_global_oom_handling))]
#[inline(always)]
pub fn new(x: T) -&gt; Self {
    // box 是 Rust 的内部关键字，在编译时，会使用内存分配器来分配内存
    box x
}
<span class="boring">}</span></code></pre></pre>
<p>Box::new() 是一个函数，在 debug 模式下，传入它的数据会出现在栈上，再移动到堆上，有可能会引起栈溢出。在 release 模式下，该函数调用会被<strong>inline</strong>优化。</p>
<h4 id="实现-drop-trait"><a class="header" href="#实现-drop-trait">实现 <code>Drop</code> trait</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe impl&lt;#[may_dangle] T: ?Sized, A: Allocator&gt; Drop for Box&lt;T, A&gt; {
    fn drop(&amp;mut self) {
        // Do nothing, drop is currently performed by compiler.
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="cowa-b"><a class="header" href="#cowa-b">Cow&lt;'a, B&gt;</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Cow&lt;'a, B&gt; where B: 'a + ToOwned + ?Sized {
  Borrowed(&amp;'a B),
  Owned(&lt;B as ToOwned&gt;::Owned),
}
<span class="boring">}</span></code></pre></pre>
<p>Cow 包裹了一个只读借用，但如果调用者需要所有权或者需要修改内容，那么它会 clone 借用的数据。这种数据结构可以减少不必要的堆内存分配，提升系统效率。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ToOwned {
    type Owned: Borrow&lt;Self&gt;;
    #[must_use = &quot;cloning is often expensive and is not expected to have side effects&quot;]
    fn to_owned(&amp;self) -&gt; Self::Owned;

    fn clone_into(&amp;self, target: &amp;mut Self::Owned) { ... }
}

// Borrow 是个泛型 trait，表明一个类型可以被借用成不同的引用
// 比如 String 可以被借用为 &amp;String 或者 &amp;str
pub trait Borrow&lt;Borrowed&gt; where Borrowed: ?Sized {
    fn borrow(&amp;self) -&gt; &amp;Borrowed;
}
<span class="boring">}</span></code></pre></pre>
<p>str 对 <code>ToOwned</code> trait 的实现：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ToOwned for str {
    type Owned = String;
    #[inline]
    fn to_owned(&amp;self) -&gt; String {
        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }
    }

    fn clone_into(&amp;self, target: &amp;mut String) {
        let mut b = mem::take(target).into_bytes();
        self.as_bytes().clone_into(&amp;mut b);
        *target = unsafe { String::from_utf8_unchecked(b) }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>同时 String 必须要实现 <code>Borrow&lt;str&gt;</code> trait，这样能符合 ToOwned 的要求。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Borrow&lt;str&gt; for String {
    #[inline]
    fn borrow(&amp;self) -&gt; &amp;str {
        &amp;self[..]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>给 Cow 实现 Deref</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: ?Sized + ToOwned&gt; Deref for Cow&lt;'_, B&gt; {
    type Target = B;

    fn deref(&amp;self) -&gt; &amp;B {
        // 我们分别取其内容，生成引用
        match *self {
            Borrowed(borrowed) =&gt; borrowed, // 对于 Borrowed，直接就是取出当中的引用
            Owned(ref owned) =&gt; owned.borrow(), // 对于 Owned，调用其 borrow() 方法，获得引用
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="应用案例"><a class="header" href="#应用案例">应用案例</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">use std::borrow::Cow;
use url::Url;

fn main() {
    let url = Url::parse(&quot;https://tyr.com/rust?page=1024&amp;sort=desc&amp;extra=hello%20world&quot;).unwrap();
    let mut pairs = url.query_pairs();

    assert_eq!(pairs.count(), 3);

    let (mut k, v) = pairs.next().unwrap();
    // 因为 k, v 都是 Cow&lt;str&gt; 他们用起来感觉和 &amp;str 或者 String 一样
    // 此刻，他们都是 Borrowed
    println!(&quot;key: {}, v: {}&quot;, k, v);
    // 当修改发生时，k 变成 Owned
    k.to_mut().push_str(&quot;_lala&quot;);

    print_pairs((k, v));

    print_pairs(pairs.next().unwrap());
    // 在处理 extra=hello%20world 时，value 被处理成 &quot;hello world&quot;
    // 所以这里 value 是 Owned
    print_pairs(pairs.next().unwrap());
}

fn print_pairs(pair: (Cow&lt;str&gt;, Cow&lt;str&gt;)) {
    println!(&quot;key: {}, value: {}&quot;, show_cow(pair.0), show_cow(pair.1));
}

fn show_cow(cow: Cow&lt;str&gt;) -&gt; String {
    match cow {
        Cow::Borrowed(v) =&gt; format!(&quot;Borrowed {}&quot;, v),
        Cow::Owned(v) =&gt; format!(&quot;Owned {}&quot;, v),
    }
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">use serde::Deserialize;
use std::borrow::Cow;

#[derive(Debug, Deserialize)]
struct User&lt;'input&gt; {
    #[serde(borrow)]
    name: Cow&lt;'input, str&gt;,
    age: u8,
}

fn main() {
    let input = r#&quot;{ &quot;name&quot;: &quot;Tyr&quot;, &quot;age&quot;: 18 }&quot;#;
    let user: User = serde_json::from_str(input).unwrap();

    match user.name {
        Cow::Borrowed(x) =&gt; println!(&quot;borrowed {}&quot;, x),
        Cow::Owned(x) =&gt; println!(&quot;owned {}&quot;, x),
    }
}</code></pre></pre>
<h3 id="mutexguardt"><a class="header" href="#mutexguardt">MutexGuard&lt;T&gt;</a></h3>
<p>MutexGuard 通过 Drop trait 来确保退出时释放互斥锁，这样用户在使用 Mutex 时，可以不必关心何时释放这个互斥锁。因为无论你在调用栈上怎样传递 MutexGuard ，哪怕在错误处理流程上提前退出，Rust 的所有权机制可以确保只要 MutexGuard 离开作用域，锁就会被释放。</p>
<p>MutexGuard 不允许 Send，只允许 Sync，也就是说，你可以把 MutexGuard 的引用传给另一个线程使用，但你无法把 MutexGuard 整个移动到另一个线程。这样可以避免因加锁和解锁在不同的线程下带来的死锁风险。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::borrow::Cow;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

fn main() {
    // 用 Arc 来提供并发环境下的共享所有权（使用引用计数）
    let metrics: Arc&lt;Mutex&lt;HashMap&lt;Cow&lt;'static, str&gt;, usize&gt;&gt;&gt; =
        Arc::new(Mutex::new(HashMap::new()));
    for _ in 0..32 {
        let m = metrics.clone();
        thread::spawn(move || {
            let mut g = m.lock().unwrap();
            // 此时只有拿到 MutexGuard 的线程可以访问 HashMap
            let data = &amp;mut *g;
            // Cow 实现了很多数据结构的 From trait，
            // 所以我们可以用 &quot;hello&quot;.into() 生成 Cow
            let entry = data.entry(&quot;hello&quot;.into()).or_insert(0);
            *entry += 1;
            // MutexGuard 被 Drop，锁被释放
        });
    }

    thread::sleep(Duration::from_millis(100));

    println!(&quot;metrics: {:?}&quot;, metrics.lock().unwrap());
}</code></pre></pre>
<h2 id="内存分配器"><a class="header" href="#内存分配器">内存分配器</a></h2>
<h3 id="替换默认的内存分配器"><a class="header" href="#替换默认的内存分配器">替换默认的内存分配器</a></h3>
<p>堆上分配内存的 <code>Box&lt;T&gt;</code> 有一个缺省的泛型参数 <code>A</code>，需要满足 <code>Allocator</code>，并且默认是 <code>Global</code>，这个 <code>Global</code> 就是默认的内存分配器。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use jemallocator::Jemalloc;

#[global_allocator]
static GLOBAL: Jemalloc = Jemalloc;

fn main() {}</code></pre></pre>
<h3 id="自定义内存分配器"><a class="header" href="#自定义内存分配器">自定义内存分配器</a></h3>
<p>如果想要编写一个全局分配器，可以实现 <code>GlobalAlloc</code> trait，它和 <code>Allocator</code> trait 的主要区别在于是否允许分配长度为0的内存。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::alloc::{GlobalAlloc, Layout, System};

struct MyAllocator;

unsafe impl GlobalAlloc for MyAllocator {
    unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8 {
        let data = System.alloc(layout);
        // 这里不能使用 println!()
        // stdout 会打印到一个由 Mutex 互斥锁保护的共享全局 buffer 中，这个过程中会涉及内存的分配
        // 分配的内存又会触发 println!()，最终造成程序崩溃
        // eprintln! 直接打印到 stderr，不会 buffer
        eprintln!(&quot;ALLOC: {:p}, size {}&quot;, data, layout.size());
        data
    }

    unsafe fn dealloc(&amp;self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout);
        eprintln!(&quot;FREE: {:p}, size {}&quot;, ptr, layout.size());
    }
}

#[global_allocator]
static GLOBAL: MyAllocator = MyAllocator;

#[allow(dead_code)]
struct Matrix {
    // 使用不规则的数字如 505 可以让 dbg! 的打印很容易分辨出来
    data: [u8; 505],
}

impl Default for Matrix {
    fn default() -&gt; Self {
        Self { data: [0; 505] }
    }
}

fn main() {
    // 在这句执行之前已经有好多内存分配
    let data = Box::new(Matrix::default());

    // 输出中有一个 1024 大小的内存分配，是 println! 导致的
    println!(
        &quot;!!! allocated memory: {:p}, len: {}&quot;,
        &amp;*data,
        std::mem::size_of::&lt;Matrix&gt;()
    );

    // data 在这里 drop，可以在打印中看到 FREE
    // 之后还有很多其它内存被释放
}</code></pre></pre>
<p>Standard Error 中输出的结果如下：</p>
<pre><code class="language-plain">ALLOC: 0x55c63eb5b940, size 5
ALLOC: 0x55c63eb5b960, size 48
ALLOC: 0x55c63eb5b9d0, size 505
ALLOC: 0x55c63eb5b500, size 1024
FREE: 0x55c63eb5b9d0, size 505
FREE: 0x55c63eb5b500, size 1024
FREE: 0x55c63eb5b940, size 5
FREE: 0x55c63eb5b960, size 48
</code></pre>
<h2 id="切片"><a class="header" href="#切片">切片</a></h2>
<blockquote>
<p>当我们构建自己的数据结构时，如果它内部也有连续排列的等长的数据结构，可以考虑 AsRef 或者 Deref 到切片。</p>
</blockquote>
<p>切片是描述一组属于同一类型、长度不确定的、在内存中连续存放的数据结构，用 [T] 来表述。因为长度不确定，所以切片是个 DST（Dynamically Sized Type）。在使用中主要用以下形式：</p>
<ul>
<li>&amp;[T]：表示一个只读的切片引用</li>
<li>&amp;mut [T]：表示一个可写的切片引用</li>
<li>Box&lt;[T]&gt;：一个在堆上分配的切片。</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let arr = [1, 2, 3, 4, 5];
    let vec = vec![1, 2, 3, 4, 5];
    let s1 = &amp;arr[..2];
    let s2 = &amp;vec[..2];
    println!(&quot;s1: {:?}, s2: {:?}&quot;, s1, s2);

    // &amp;[T] 和 &amp;[T] 是否相等取决于长度和内容是否相等
    assert_eq!(s1, s2);
    // &amp;[T] 可以和 Vec&lt;T&gt;/[T;n] 比较，也会看长度和内容
    // 这是因为它们之间实现了 PartialEq trait
    assert_eq!(&amp;arr[..], vec);
    assert_eq!(&amp;vec[..], arr);
}</code></pre></pre>
<p>在使用的时候，支持切片的具体数据类型，可以根据需要，解引用转换成切片类型。比如 Vec 和 [T; n] 会转化成为 &amp;[T]，这是因为 Vec 实现了 Deref trait，而 array 内建了到 &amp;[T] 的解引用。这也就意味着，通过解引用，这几个和切片有关的数据结构都会获得切片的所有能力，包括：<code>binary_search</code>、<code>chunks</code>、<code>concat</code>、<code>contains</code>、<code>start_with</code>、<code>end_with</code>、<code>group_by</code>、<code>iter</code>、<code>join</code>、<code>sort</code>、<code>split</code>、<code>swap</code> 等一系列丰富的功能。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fmt;
fn main() {
    let v = vec![1, 2, 3, 4];

    // Vec 实现了 Deref，&amp;Vec&lt;T&gt; 会被自动解引用为 &amp;[T]，符合接口定义
    print_slice(&amp;v);
    // 直接是 &amp;[T]，符合接口定义
    print_slice(&amp;v[..]);

    // &amp;Vec&lt;T&gt; 支持 AsRef&lt;[T]&gt;
    print_slice1(&amp;v);
    // &amp;[T] 支持 AsRef&lt;[T]&gt;
    print_slice1(&amp;v[..]);
    // Vec&lt;T&gt; 也支持 AsRef&lt;[T]&gt;
    print_slice1(v);

    let arr = [1, 2, 3, 4];
    // 数组虽没有实现 Deref，但它的解引用就是 &amp;[T]
    print_slice(&amp;arr);
    print_slice(&amp;arr[..]);
    print_slice1(&amp;arr);
    print_slice1(&amp;arr[..]);
    print_slice1(arr);
}

fn print_slice&lt;T: fmt::Debug&gt;(s: &amp;[T]) {
    println!(&quot;{:?}&quot;, s);
}

fn print_slice1&lt;T, U&gt;(s: T)
where
    T: AsRef&lt;[U]&gt;,
    U: fmt::Debug,
{
    println!(&quot;{:?}&quot;, s.as_ref());
}</code></pre></pre>
<h3 id="将-slice-转化成迭代器"><a class="header" href="#将-slice-转化成迭代器">将 slice 转化成迭代器</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // 这里 Vec 在调用 iter() 时被解引用成 &amp;[T]，所以可以访问 iter()
    let result: Vec&lt;i32&gt; = vec![1, 2, 3, 4]
        .iter()
        .map(|v| v * v)
        .filter(|v| *v &lt; 16)
        .collect();

    println!(&quot;{:?}&quot;, result);
}</code></pre></pre>
<p>Rust 下的迭代器是个<code>懒接口（lazy interface）</code>，也就是说这段代码直到运行到 <code>collect</code> 时才真正开始执行，之前的部分不过是在不断地生成新的结构，来累积处理逻辑而已。Rust 大量使用了 inline 等优化技巧，使得迭代器的性能和 C 语言的 for 循环差别不大。</p>
<p>此外，<code>itertools</code> crate 还提供了额外的，标准库中没有提供的迭代器。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use itertools::Itertools;

fn main() {
    let err_str = &quot;bad happened&quot;;
    let input = vec![Ok(21), Err(err_str), Ok(7)];
    let it = input
        .into_iter()
        // 对成功的结果进一步做 filter/map 操作
        .filter_map_ok(|i| if i &gt; 10 { Some(i * 2) } else { None });
    // 结果应该是：vec![Ok(42), Err(err_str)]
    println!(&quot;{:?}&quot;, it.collect::&lt;Vec&lt;_&gt;&gt;());
}</code></pre></pre>
<h3 id="特殊的切片-str"><a class="header" href="#特殊的切片-str">特殊的切片 &amp;str</a></h3>
<p><img src="../images/rust/string-slice-vs-vector-slice.webp" alt="字符列表和字符串的区别" /></p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::iter::FromIterator;

fn main() {
    let arr = ['h', 'e', 'l', 'l', 'o'];
    let vec = vec!['h', 'e', 'l', 'l', 'o'];
    let s = String::from(&quot;hello&quot;);
    let s1 = &amp;arr[1..3];
    let s2 = &amp;vec[1..3];
    // &amp;str 本身就是一个特殊的 slice
    let s3 = &amp;s[1..3];
    println!(&quot;s1: {:?}, s2: {:?}, s3: {:?}&quot;, s1, s2, s3);

    // &amp;[char] 和 &amp;[char] 是否相等取决于长度和内容是否相等
    assert_eq!(s1, s2);
    // &amp;[char] 和 &amp;str 不能直接对比，我们把 s3 变成 Vec&lt;char&gt;
    assert_eq!(s2, s3.chars().collect::&lt;Vec&lt;_&gt;&gt;());
    // &amp;[char] 可以通过迭代器转换成 String，String 和 &amp;str 可以直接对比
    assert_eq!(String::from_iter(s2), s3);
}</code></pre></pre>
<p>字符列表可以通过迭代器转换成 String，String 也可以通过 chars() 函数转换成字符列表，如果不转换，二者不能比较。</p>
<h3 id="boxt-堆上的切片"><a class="header" href="#boxt-堆上的切片">Box&lt;[T]&gt; 堆上的切片</a></h3>
<p><code>Box&lt;[T]&gt;</code> 和切片的引用 <code>&amp;[T]</code> 很类似：它们都是在栈上有一个包含长度的胖指针，指向存储数据的内存位置。区别是：<code>Box&lt;[T]&gt;</code> 只会指向堆，<code>&amp;[T]</code> 指向的位置可以是栈也可以是堆；此外，<code>Box&lt;[T]&gt;</code> 对数据具有所有权，而 <code>&amp;[T]</code> 只是一个借用。</p>
<p><code>Box&lt;[T]&gt;</code> 和 <code>Vec&lt;T&gt;</code> 有一点点差别：<code>Vec&lt;T&gt;</code> 有额外的 capacity，可以增长；而 <code>Box&lt;[T]&gt;</code> 一旦生成就固定下来，没有 capacity，也无法增长。</p>
<p><img src="../images/rust/slice-on-heap.webp" alt="堆上的切片" /></p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::ops::Deref;

fn main() {
    let mut v1 = vec![1, 2, 3, 4];
    v1.push(5);
    println!(&quot;cap should be 8: {}&quot;, v1.capacity());

    // 从 Vec&lt;T&gt; 转换成 Box&lt;[T]&gt;，此时会丢弃多余的 capacity
    let b1 = v1.into_boxed_slice();
    let mut b2 = b1.clone();

    let v2 = b1.into_vec();
    println!(&quot;cap should be exactly 5: {}&quot;, v2.capacity());

    assert!(b2.deref() == v2);

    // Box&lt;[T]&gt; 可以更改其内部数据，但无法 push
    b2[0] = 2;
    // b2.push(6);
    println!(&quot;b2: {:?}&quot;, b2);

    // 注意 Box&lt;[T]&gt; 和 Box&lt;[T; n]&gt; 并不相同
    let b3 = Box::new([2, 2, 3, 4, 5]);
    println!(&quot;b3: {:?}&quot;, b3);

    // b2 和 b3 相等，但 b3.deref() 和 v2 无法比较
    assert!(b2 == b3);
    // assert!(b3.deref() == v2);
}</code></pre></pre>
<p><code>Vec&lt;T&gt;</code> 可以通过 i<code>nto_boxed_slice()</code> 转换成 <code>Box&lt;[T]&gt;</code>，<code>Box&lt;[T]&gt;</code> 也可以通过 <code>into_vec()</code> 转换回 <code>Vec&lt;T&gt;</code>。</p>
<p><code>Box&lt;[T]&gt;</code> 有一个很好的特性是，不像 <code>Box&lt;[T;n]&gt;</code> 那样在编译时就要确定大小，它可以在运行期生成，以后大小不会再改变。</p>
<h2 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h2>
<p>Rust 哈希表不是用冲突链来解决哈希冲突，而是用开放寻址法的二次探查来解决的。</p>
<p>如果只需要简单确认元素是否在集合中，可以用 HashSet，它就是简化的 HashMap，可以用来存放无序的集合。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use hashbrown::hash_map as base;

// RandomState 使用 SipHash 作为缺省的哈希算法
#[derive(Clone)]
pub struct RandomState {
    k0: u64,
    k1: u64,
}

pub struct HashMap&lt;K, V, S = RandomState&gt; {
    // 复用了 hashbrown 库的 HashMap
    base: base::HashMap&lt;K, V, S&gt;,
}

// hashbrown 库的 HashMap
pub struct HashMap&lt;K, V, S = DefaultHashBuilder, A: Allocator + Clone = Global&gt; {
    pub(crate) hash_builder: S,
    pub(crate) table: RawTable&lt;(K, V), A&gt;,
}

pub struct RawTable&lt;T, A: Allocator + Clone = Global&gt; {
    table: RawTableInner&lt;A&gt;,

    // Tell dropck that we own instances of T.
    marker: PhantomData&lt;T&gt;,
}

struct RawTableInner&lt;A&gt; {
    bucket_mask: usize,

    // [Padding], T1, T2, ..., Tlast, C1, C2, ...
    //                                ^ points here
    // 指向哈希表堆内存末端的 ctrl 区
    ctrl: NonNull&lt;u8&gt;,

    // 哈希表在下次自动增长前还能存储多少数据
    // 随着哈希表不断插入数据，它会以 2 的幂减一的方式增长
    growth_left: usize,

    // 哈希表现在有多少数据
    items: usize,
    alloc: A,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="自定义数据结构做-hash-key"><a class="header" href="#自定义数据结构做-hash-key">自定义数据结构做 Hash key</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">use std::{
    collections::{hash_map::DefaultHasher, HashMap},
    hash::{Hash, Hasher},
};

// 如果要支持 Hash，可以用 #[derive(Hash)]，前提是每个字段都实现了 Hash
// 如果要能作为 HashMap 的 key，还需要 PartialEq 和 Eq
#[derive(Debug, Hash, PartialEq, Eq)]
struct Student&lt;'a&gt; {
    name: &amp;'a str,
    age: u8,
}

impl&lt;'a&gt; Student&lt;'a&gt; {
    pub fn new(name: &amp;'a str, age: u8) -&gt; Self {
        Self { name, age }
    }
}

fn main() {
    let mut hasher = DefaultHasher::new();
    let student = Student::new(&quot;Tyr&quot;, 18);
    // 实现了 Hash 的数据结构可以直接调用 hash 方法
    student.hash(&amp;mut hasher);
    let mut map = HashMap::new();
    // 实现了 Hash / PartialEq / Eq 的数据结构可以作为 HashMap 的 key
    map.insert(student, vec![&quot;Math&quot;, &quot;Writing&quot;]);
    println!(&quot;hash: 0x{:x}, map: {:?}&quot;, hasher.finish(), map);
}</code></pre></pre>
<h2 id="btreemap"><a class="header" href="#btreemap">BTreeMap</a></h2>
<p>BTreeMap 是内部使用 B-tree 来组织哈希表的数据结构，和 HashMap 不同的是，BTreeMap 是有序的。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::BTreeMap;

fn main() {
    let map = BTreeMap::new();
    let mut map = explain(&quot;empty&quot;, map);

    for i in 0..16usize {
        map.insert(format!(&quot;Tyr {}&quot;, i), i);
    }

    let mut map = explain(&quot;added&quot;, map);

    map.remove(&quot;Tyr 1&quot;);

    let map = explain(&quot;remove 1&quot;, map);

    for item in map.iter() {
        println!(&quot;{:?}&quot;, item);
    }
}

// BTreeMap 结构有 height，node 和 length
// 我们 transmute 打印之后，再 transmute 回去
fn explain&lt;K, V&gt;(name: &amp;str, map: BTreeMap&lt;K, V&gt;) -&gt; BTreeMap&lt;K, V&gt; {
    let arr: [usize; 3] = unsafe { std::mem::transmute(map) };
    println!(
        &quot;{}: height: {}, root node: 0x{:x}, len: 0x{:x}&quot;,
        name, arr[0], arr[1], arr[2]
    );
    unsafe { std::mem::transmute(arr) }
}</code></pre></pre>
<p>如果想自定义的数据结构可以作为 BTreeMap 的 key，那么需要实现 PartialOrd 和 Ord。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::BTreeMap;

#[derive(Debug, PartialOrd, Ord, PartialEq, Eq)]
struct Name {
    pub name: String,
    pub flags: u32,
}

impl Name {
    pub fn new(name: impl AsRef&lt;str&gt;, flags: u32) -&gt; Self {
        Self {
            name: name.as_ref().to_string(),
            flags,
        }
    }
}

fn main() {
    let mut map = BTreeMap::new();
    map.insert(Name::new(&quot;/etc/password&quot;, 0x1), 12);
    map.insert(Name::new(&quot;/etc/hosts&quot;, 0x1), 4);
    map.insert(Name::new(&quot;/home/tchen&quot;, 0x0), 28);

    for item in map.iter() {
        println!(&quot;{:?}&quot;, item);
    }
}</code></pre></pre>
<h2 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h2>
<h3 id="-操作符"><a class="header" href="#-操作符"><code>?</code> 操作符</a></h3>
<p>? 操作符内部被展开成类似这样的代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match result {
    Ok(v) =&gt; v,
    Err(e) =&gt; return Err(e.into())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="函数式错误处理"><a class="header" href="#函数式错误处理">函数式错误处理</a></h3>
<p><img src="../images/rust/functional-error-handling.webp" alt="函数式错误处理" /></p>
<h3 id="cache_unwind"><a class="header" href="#cache_unwind">cache_unwind</a></h3>
<p>Rust 标准库提供了<code>catch_unwind()</code>函数，能够像异常处理那样将调用栈回溯到 catch_unwind 这一刻，作用和其它语言的 try {…} catch {…} 一样。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::panic;

fn main() {
    let result = panic::catch_unwind(|| {
        println!(&quot;hello!&quot;);
    });
    assert!(result.is_ok());
    let result = panic::catch_unwind(|| {
        panic!(&quot;oh no!&quot;);
    });
    assert!(result.is_err());
    println!(&quot;panic captured: {:#?}&quot;, result);
}</code></pre></pre>
<h3 id="error-trait"><a class="header" href="#error-trait"><code>Error</code> trait</a></h3>
<p>为了规范代表错误的数据类型的行为，Rust 定义了 Error trait：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Error: Debug + Display {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; { ... }
    fn backtrace(&amp;self) -&gt; Option&lt;&amp;Backtrace&gt; { ... }
    fn description(&amp;self) -&gt; &amp;str { ... }
    fn cause(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt; { ... }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://github.com/dtolnay/thiserror">thiserror</a> 可以帮助简化错误类型的定义。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thiserror::Error;
#[derive(Error, Debug)]
#[non_exhaustive]
pub enum DataStoreError {
    #[error(&quot;data store disconnected&quot;)]
    Disconnect(#[from] io::Error),
    #[error(&quot;the data for key `{0}` is not available&quot;)]
    Redaction(String),
    #[error(&quot;invalid header (expected {expected:?}, found {found:?})&quot;)]
    InvalidHeader {
        expected: String,
        found: String,
    },
    #[error(&quot;unknown data store error&quot;)]
    Unknown,
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://github.com/dtolnay/anyhow">anyhow</a> 实现了 <code>anyhow::Error</code> 和任意符合 Error trait 的错误类型之间的转换，让你可以使用 <code>?</code> 操作符，不必再手工转换错误类型。</p>
<h2 id="闭包"><a class="header" href="#闭包">闭包</a></h2>
<p>闭包是一种匿名类型，一旦声明，就会产生一个新的类型，但这个类型无法被其它地方使用。这个类型就像一个结构体，会包含所有捕获的变量。闭包是存储在<strong>栈</strong>上，并且除了捕获的数据外，闭包本身不包含任何额外函数指针指向闭包的代码。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{collections::HashMap, mem::size_of_val};

// 长度为 0
let c1 = || println!(&quot;hello world!&quot;);
// 和参数无关，长度也为 0
let c2 = |i: i32| println!(&quot;hello: {}&quot;, i);
let name = String::from(&quot;tyr&quot;);
let name1 = name.clone();
let mut table = HashMap::new();
table.insert(&quot;hello&quot;, &quot;world&quot;);
// 如果捕获一个引用，长度为 8
let c3 = || println!(&quot;hello: {}&quot;, name);
// 捕获移动的数据 name1(长度 24) + table(长度 48)，因此 closure 长度 72
let c4 = move || println!(&quot;hello: {}, {:?}&quot;, name1, table);
let name2 = name.clone();
// 和局部变量无关，捕获了一个 String name2，因此 closure 长度 24
let c5 = move || {
    let x = 1;
    let name3 = String::from(&quot;lindsey&quot;);
    println!(&quot;hello: {}, {:?}, {:?}&quot;, x, name2, name3);
};

println!(
    &quot;c1: {}, c2: {}, c3: {}, c4: {}, c5: {}, main: {}&quot;,
    size_of_val(&amp;c1),
    size_of_val(&amp;c2),
    size_of_val(&amp;c3),
    size_of_val(&amp;c4),
    size_of_val(&amp;c5),
    size_of_val(&amp;main),
);
<span class="boring">}</span></code></pre></pre>
<p><strong>不带 move 时，闭包捕获的是对应自由变量的引用；带 move 时，对应自由变量的所有权会被移动到闭包结构中</strong>。</p>
<h3 id="闭包的类型"><a class="header" href="#闭包的类型">闭包的类型</a></h3>
<p><img src="../images/rust/closure-trait.webp" alt="闭包的类型" /></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FnOnce&lt;Args&gt; {
    type Output;
    // 会转移 self 的所有权到 call_once 函数中
    extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 一个 FnMut 闭包，可以被传给一个需要 FnOnce 的上下文，此时调用闭包相当于调用了 call_once()
pub trait FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call_mut(
        &amp;mut self,
        args: Args
    ) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 任何需要 FnOnce 或者 FnMut 的场合，都可以传入满足 Fn 的闭包
pub trait Fn&lt;Args&gt;: FnMut&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call(&amp;self, args: Args) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="将闭包作为参数传递"><a class="header" href="#将闭包作为参数传递">将闭包作为参数传递</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let v = vec![0u8; 1024];
    let v1 = vec![0u8; 1023];

    // Fn，不移动所有权
    let mut c = |x: u64| v.len() as u64 * x;
    // Fn，移动所有权
    let mut c1 = move |x: u64| v1.len() as u64 * x;

    println!(&quot;direct call: {}&quot;, c(2));
    println!(&quot;direct call: {}&quot;, c1(2));

    println!(&quot;call: {}&quot;, call(3, &amp;c));
    println!(&quot;call: {}&quot;, call(3, &amp;c1));

    println!(&quot;call_mut: {}&quot;, call_mut(4, &amp;mut c));
    println!(&quot;call_mut: {}&quot;, call_mut(4, &amp;mut c1));

    println!(&quot;call_once: {}&quot;, call_once(5, c));
    println!(&quot;call_once: {}&quot;, call_once(5, c1));
}

fn call(arg: u64, c: &amp;impl Fn(u64) -&gt; u64) -&gt; u64 {
    c(arg)
}

fn call_mut(arg: u64, c: &amp;mut impl FnMut(u64) -&gt; u64) -&gt; u64 {
    c(arg)
}

fn call_once(arg: u64, c: impl FnOnce(u64) -&gt; u64) -&gt; u64 {
    c(arg)
}</code></pre></pre>
<h3 id="返回闭包"><a class="header" href="#返回闭包">返回闭包</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">use std::ops::Mul;

fn main() {
    let c1 = curry(5);
    println!(&quot;5 multiply 2 is: {}&quot;, c1(2));

    let adder2 = curry(3.14);
    println!(&quot;pi multiply 4^2 is: {}&quot;, adder2(4. * 4.));
}

fn curry&lt;T&gt;(x: T) -&gt; impl Fn(T) -&gt; T
where
    T: Mul&lt;Output = T&gt; + Copy,
{
    move |y| x * y
}</code></pre></pre>
<h3 id="给闭包实现其他-trait"><a class="header" href="#给闭包实现其他-trait">给闭包实现其他 trait</a></h3>
<p>有些接口既可以传入一个结构体，又可以传入一个函数或者闭包。</p>
<pre><pre class="playground"><code class="language-rust edition2021">pub trait Executor {
    fn execute(&amp;self, cmd: &amp;str) -&gt; Result&lt;String, &amp;'static str&gt;;
}

struct BashExecutor {
    env: String,
}

impl Executor for BashExecutor {
    fn execute(&amp;self, cmd: &amp;str) -&gt; Result&lt;String, &amp;'static str&gt; {
        Ok(format!(
            &quot;fake bash execute: env: {}, cmd: {}&quot;,
            self.env, cmd
        ))
    }
}

impl&lt;T&gt; Executor for T
where
    T: Fn(&amp;str) -&gt; Result&lt;String, &amp;'static str&gt;,
{
    fn execute(&amp;self, cmd: &amp;str) -&gt; Result&lt;String, &amp;'static str&gt; {
        self(cmd)
    }
}

fn main() {
    let env = &quot;PATH=/usr/bin&quot;.to_string();

    let cmd = &quot;cat /etc/passwd&quot;;
    let r1 = execute(cmd, BashExecutor { env: env.clone() });
    println!(&quot;{:?}&quot;, r1);

    let r2 = execute(cmd, |cmd: &amp;str| {
        Ok(format!(&quot;fake fish execute: env: {}, cmd: {}&quot;, env, cmd))
    });
    println!(&quot;{:?}&quot;, r2);
}

fn execute(cmd: &amp;str, exec: impl Executor) -&gt; Result&lt;String, &amp;'static str&gt; {
    exec.execute(cmd)
}</code></pre></pre>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<ul>
<li><a href="https://cheats.rs/">cheats.rs</a></li>
<li><a href="https://lldb.llvm.org/use/map.html">GDB/LLDB 命令手册</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../cs/openwrt.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../ee/control-system.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../cs/openwrt.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../ee/control-system.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>

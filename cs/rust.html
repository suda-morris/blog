<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust - ğŸğŸ’ suda-morris ä¸ªäººåšå®¢ ğŸ‡</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Personal Blog">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../about-me.html">å…³äºæˆ‘</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">ä½“ç³»ç»“æ„</li><li class="chapter-item expanded "><a href="../cs/riscv.html"><strong aria-hidden="true">1.</strong> RISC-V</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">ç¼–è¯‘ç³»ç»Ÿ</li><li class="chapter-item expanded "><a href="../cs/gcc-toolchains.html"><strong aria-hidden="true">2.</strong> GCC</a></li><li class="chapter-item expanded "><a href="../cs/cmake.html"><strong aria-hidden="true">3.</strong> CMake</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">æ“ä½œç³»ç»Ÿ</li><li class="chapter-item expanded "><a href="../cs/openwrt.html"><strong aria-hidden="true">4.</strong> OpenWRT</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">ç¼–ç¨‹è¯­è¨€</li><li class="chapter-item expanded "><a href="../cs/rust.html" class="active"><strong aria-hidden="true">5.</strong> Rust</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">æ§åˆ¶ç³»ç»Ÿ</li><li class="chapter-item expanded "><a href="../ee/control-system.html"><strong aria-hidden="true">6.</strong> æ§åˆ¶ç³»ç»ŸåŸºç¡€</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">æµ‹è¯•æ¡†æ¶</li><li class="chapter-item expanded "><a href="../cs/pytest.html"><strong aria-hidden="true">7.</strong> pytest</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">å¤šåª’ä½“</li><li class="chapter-item expanded "><a href="../cs/video-process.html"><strong aria-hidden="true">8.</strong> è§†é¢‘å¤„ç†</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">é€šä¿¡åè®®</li><li class="chapter-item expanded "><a href="../ee/usb.html"><strong aria-hidden="true">9.</strong> USB åè®®åŸºç¡€</a></li><li class="chapter-item expanded "><a href="../ee/can.html"><strong aria-hidden="true">10.</strong> CAN åè®®åŸºç¡€</a></li><li class="chapter-item expanded "><a href="../ee/mipi.html"><strong aria-hidden="true">11.</strong> MIPI åè®®åŸºç¡€</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">ç”µè·¯è®¾è®¡</li><li class="chapter-item expanded "><a href="../ee/yosys.html"><strong aria-hidden="true">12.</strong> Yosys</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">å‰ç«¯</li><li class="chapter-item expanded "><a href="../cs/tauri.html"><strong aria-hidden="true">13.</strong> Tauri</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">ç®¡ç†</li><li class="chapter-item expanded "><a href="../cs/git.html"><strong aria-hidden="true">14.</strong> git</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">æ¼”ç¤º</li><li class="chapter-item expanded "><a href="../ux/slides-tool.html"><strong aria-hidden="true">15.</strong> slides å·¥å…·</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ğŸğŸ’ suda-morris ä¸ªäººåšå®¢ ğŸ‡</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/suda-morris/blog" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/suda-morris/blog/edit/master/src/cs/rust.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-çŸ¥è¯†ç¢ç‰‡"><a class="header" href="#rust-çŸ¥è¯†ç¢ç‰‡">Rust çŸ¥è¯†ç¢ç‰‡</a></h1>
<h2 id="ç¼–è¯‘è¿‡ç¨‹"><a class="header" href="#ç¼–è¯‘è¿‡ç¨‹">ç¼–è¯‘è¿‡ç¨‹</a></h2>
<p><img src="../images/rust/compile-process.png" alt="Rust ç¼–è¯‘è¿‡ç¨‹" /></p>
<ol>
<li>åˆ†è¯ï¼šæŠŠè¯æ³•ç»“æ„å¤„ç†æˆè¯æ¡æµ</li>
<li>è¯æ¡æµç»è¿‡è¯­æ³•è§£æå½¢æˆæŠ½è±¡è¯­æ³•æ ‘</li>
<li>æŠ½è±¡è¯­æ³•æ ‘ç®€åŒ–æˆé«˜çº§ä¸­é—´è¯­è¨€ (HIR)ï¼Œç¼–è¯‘å™¨å¯¹ HIR è¿›è¡Œç±»å‹æ£€æŸ¥ã€æ–¹æ³•æŸ¥æ‰¾ç­‰å·¥ä½œ</li>
<li>HIR è¿›ä¸€æ­¥ç®€åŒ–å½¢æˆä¸­çº§ä¸­é—´è¯­è¨€ (MIR)ï¼Œç¼–è¯‘å™¨å¯¹ MIR è¿›è¡Œå€Ÿç”¨æ£€æŸ¥ã€ä¼˜åŒ–ç­‰å·¥ä½œï¼Œåœ¨ MIR ä¸­å·²ç»çœ‹ä¸åˆ° Rust å„ç‰ˆæ¬¡çš„å·®å¼‚äº†</li>
<li>äº§ç”Ÿ LLVM ä¸­é—´è¯­è¨€</li>
<li>LLVM åç«¯ä¼šå¯¹ LLVM ä¸­é—´è¯­è¨€è¿›è¡Œä¼˜åŒ–ï¼Œæœ€ç»ˆç”Ÿæˆæœºå™¨ä»£ç </li>
</ol>
<h2 id="å¸¸ç”¨æ•°æ®ç»“æ„"><a class="header" href="#å¸¸ç”¨æ•°æ®ç»“æ„">å¸¸ç”¨æ•°æ®ç»“æ„</a></h2>
<p><img src="../images/rust/data-structure.webp" alt="æ•°æ®ç»“æ„" /></p>
<h2 id="å€¼æ”¾å †ä¸Šè¿˜æ˜¯æ ˆä¸Š"><a class="header" href="#å€¼æ”¾å †ä¸Šè¿˜æ˜¯æ ˆä¸Š">å€¼æ”¾å †ä¸Šè¿˜æ˜¯æ ˆä¸Š</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello world&quot;.to_string();
println!(&quot;'hello world': {:p}, s: {:p}, len: {}, capacity: {}, size: {}&quot;,
        &amp;&quot;hello world&quot;, &amp;s, s.len(), s.capacity(), std::mem::size_of_val(&amp;s));
<span class="boring">}</span></code></pre></pre>
<p><img src="../images/rust/string-in-memory.webp" alt="stringçš„å†…å­˜å¸ƒå±€" /></p>
<blockquote>
<p>æ ˆä¸Šå­˜æ”¾çš„æ•°æ®æ˜¯é™æ€çš„ï¼Œå›ºå®šå¤§å°ï¼Œå›ºå®šç”Ÿå‘½å‘¨æœŸï¼›å †ä¸Šå­˜æ”¾çš„æ•°æ®æ˜¯åŠ¨æ€çš„ï¼Œä¸å›ºå®šå¤§å°ï¼Œä¸å›ºå®šç”Ÿå‘½å‘¨æœŸã€‚</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static MAX: u32 = 0;
fn foo() {}
let hello = &quot;hello world&quot;.to_string();
let data = Box::new(1);

// string literals æŒ‡å‘ RODATA åœ°å€
println!(&quot;RODATA: {:p}&quot;, &quot;hello world!&quot;);
// static å˜é‡åœ¨ DATA section
println!(&quot;DATA (static var): {:p}&quot;, &amp;MAX);
// function åœ¨ TEXT
println!(&quot;TEXT (function): {:p}&quot;, foo as *const ());
// String ç»“æ„ä½“åˆ†é…åœ¨æ ˆä¸Šï¼Œæ‰€ä»¥å…¶å¼•ç”¨æŒ‡å‘ä¸€ä¸ªæ ˆåœ°å€
println!(&quot;STACK (&amp;hello): {:p}&quot;, &amp;hello);
// éœ€è¦é€šè¿‡è§£å¼•ç”¨è·å–å…¶å †ä¸Šæ•°æ®ï¼Œç„¶åå–å…¶å¼•ç”¨
println!(&quot;HEAP (&amp;*hello): {:p}&quot;, &amp;*hello);
// Box å®ç°äº† Pointer trait æ— éœ€é¢å¤–è§£å¼•ç”¨
println!(&quot;HEAP (box impl Pointer) {:p} {:p}&quot;, data, &amp;*data);
<span class="boring">}</span></code></pre></pre>
<h2 id="move-copy-borrow"><a class="header" href="#move-copy-borrow">move, copy, borrow</a></h2>
<p><img src="../images/rust/move-copy-borrow.jpg" alt="move, copy, borrow" /></p>
<p>å…¶å® Copy å’Œ Move åœ¨å†…éƒ¨å®ç°ä¸Šï¼Œéƒ½æ˜¯æµ…å±‚çš„<strong>æŒ‰ä½</strong>åšå†…å­˜å¤åˆ¶ï¼Œåªä¸è¿‡ Copy å…è®¸ä½ è®¿é—®ä¹‹å‰çš„å˜é‡ï¼Œè€Œ Move ä¸å…è®¸ã€‚</p>
<h3 id="å…³äºå†…å­˜å¤åˆ¶ä¸Šçš„è¯¯åŒº"><a class="header" href="#å…³äºå†…å­˜å¤åˆ¶ä¸Šçš„è¯¯åŒº">å…³äºå†…å­˜å¤åˆ¶ä¸Šçš„è¯¯åŒº</a></h3>
<p>å¦‚æœä»£ç çš„å…³é”®è·¯å¾„ä¸­çš„æ¯æ¬¡éƒ½è¦å¤åˆ¶å‡ ç™¾ k çš„æ•°æ®ï¼ˆæ¯”å¦‚ä¸€ä¸ªå¤§æ•°ç»„ï¼‰ï¼Œè¿™æ˜¯å¾ˆä½æ•ˆçš„ã€‚ä½†æ˜¯ï¼Œå¦‚æœè¦å¤åˆ¶çš„åªæ˜¯åŸç”Ÿç±»å‹ï¼ˆCopyï¼‰æˆ–è€…æ ˆä¸Šçš„èƒ–æŒ‡é’ˆï¼ˆMoveï¼‰ï¼Œä¸æ¶‰åŠå †å†…å­˜çš„å¤åˆ¶ï¼ˆå³æ²¡æœ‰åšæ·±æ‹·è´ï¼ˆdeep copyï¼‰ï¼‰ï¼Œé‚£è¿™ä¸ªæ•ˆç‡æ˜¯éå¸¸é«˜çš„ï¼Œä¸å¿…æ‹…å¿ƒæ¯æ¬¡èµ‹å€¼æˆ–è€…æ¯æ¬¡ä¼ å‚å¸¦æ¥çš„æ€§èƒ½æŸå¤±ã€‚</p>
<p>Rust çš„é›†åˆç±»å‹ä¼šåœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­è‡ªåŠ¨æ‰©å±•ã€‚ä»¥ä¸€ä¸ª Vec ä¸ºä¾‹ï¼Œå½“ä½¿ç”¨å®Œå †å†…å­˜å½“å‰å®¹é‡åï¼Œè¿˜ç»§ç»­æ·»åŠ æ–°çš„å†…å®¹ï¼Œå°±ä¼šè§¦å‘å †å†…å­˜çš„è‡ªåŠ¨å¢é•¿ã€‚æœ‰æ—¶å€™ï¼Œé›†åˆç±»å‹é‡Œçš„æ•°æ®ä¸æ–­è¿›è¿›å‡ºå‡ºï¼Œå¯¼è‡´é›†åˆä¸€ç›´å¢é•¿ï¼Œä½†å®é™…åªä½¿ç”¨äº†å¾ˆå°éƒ¨åˆ†çš„å®¹é‡ï¼Œå¯¼è‡´å†…å­˜çš„ä½¿ç”¨æ•ˆç‡å¾ˆä½ï¼Œè¿™æ—¶å¯ä»¥è€ƒè™‘ä½¿ç”¨ <code>shrink_to_fit</code> æ–¹æ³•æ¥èŠ‚çº¦å¯¹å†…å­˜çš„ä½¿ç”¨ã€‚</p>
<h2 id="æ‰€æœ‰æƒ"><a class="header" href="#æ‰€æœ‰æƒ">æ‰€æœ‰æƒ</a></h2>
<p><img src="../images/rust/ownership.webp" alt="ownership" /></p>
<h3 id="æ‰€æœ‰æƒçš„é™æ€æ£€æŸ¥å’ŒåŠ¨æ€æ£€æŸ¥"><a class="header" href="#æ‰€æœ‰æƒçš„é™æ€æ£€æŸ¥å’ŒåŠ¨æ€æ£€æŸ¥">æ‰€æœ‰æƒçš„é™æ€æ£€æŸ¥å’ŒåŠ¨æ€æ£€æŸ¥</a></h3>
<p>åœ¨æ‰€æœ‰æƒæ¨¡å‹ä¸‹ï¼Œå †å†…å­˜çš„ç”Ÿå‘½å‘¨æœŸï¼Œå’Œåˆ›å»ºå®ƒçš„æ ˆå†…å­˜çš„ç”Ÿå‘½å‘¨æœŸä¿æŒä¸€è‡´ã€‚ç¼–è¯‘å™¨å¯ä»¥ä¿è¯ä»£ç ç¬¦åˆæ‰€æœ‰æƒè§„åˆ™ï¼ˆé™æ€æ£€æŸ¥ï¼‰ã€‚</p>
<p>åŠ¨æ€æ£€æŸ¥ï¼Œé€šè¿‡ <code>Box::leak()</code> è®©å †å†…å­˜æ‹¥æœ‰ä¸å—é™åˆ¶çš„ç”Ÿå‘½å‘¨æœŸï¼Œç„¶ååœ¨è¿è¡Œè¿‡ç¨‹ä¸­ï¼Œé€šè¿‡å¯¹å¼•ç”¨è®¡æ•°çš„æ£€æŸ¥ï¼Œä¿è¯è¿™æ ·çš„å †å†…å­˜æœ€ç»ˆä¼šå¾—åˆ°é‡Šæ”¾ã€‚</p>
<h3 id="å¤–éƒ¨å¯å˜æ€§ä¸å†…éƒ¨å¯å˜æ€§"><a class="header" href="#å¤–éƒ¨å¯å˜æ€§ä¸å†…éƒ¨å¯å˜æ€§">å¤–éƒ¨å¯å˜æ€§ä¸å†…éƒ¨å¯å˜æ€§</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th>ä½¿ç”¨æ–¹æ³•</th><th>æ‰€æœ‰æƒæ£€æŸ¥</th></tr></thead><tbody>
<tr><td>å¤–éƒ¨å¯å˜æ€§</td><td><code>let mut</code> æˆ–è€… <code>&amp;mut</code></td><td>ç¼–è¯‘æ—¶ï¼Œå¦‚æœä¸ç¬¦åˆè§„åˆ™ï¼Œäº§ç”Ÿç¼–è¯‘é”™è¯¯</td></tr>
<tr><td>å†…éƒ¨å¯å˜æ€§</td><td>ä½¿ç”¨ Cell/RefCell</td><td>è¿è¡Œæ—¶ï¼Œå¦‚æœä¸ç¬¦åˆè§„åˆ™ï¼Œäº§ç”Ÿ panic</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust edition2021">use std::cell::RefCell;

fn main() {
    let data = RefCell::new(1);
    // æ ¹æ®æ‰€æœ‰æƒè§„åˆ™ï¼Œåœ¨åŒä¸€ä¸ªä½œç”¨åŸŸä¸‹ï¼Œä¸èƒ½åŒæ—¶æœ‰æ´»è·ƒçš„å¯å˜å€Ÿç”¨å’Œä¸å¯å˜å€Ÿç”¨
    // é€šè¿‡è¿™å¯¹èŠ±æ‹¬å·ï¼Œæˆ‘ä»¬ç¼©å°äº†å¯å˜å€Ÿç”¨çš„ç”Ÿå‘½å‘¨æœŸ
    {
        // è·å¾— RefCell å†…éƒ¨æ•°æ®çš„å¯å˜å€Ÿç”¨
        let mut v = data.borrow_mut();
        *v += 1;
    }
    println!(&quot;data: {:?}&quot;, data.borrow());
}</code></pre></pre>
<h2 id="ç”Ÿå‘½å‘¨æœŸ"><a class="header" href="#ç”Ÿå‘½å‘¨æœŸ">ç”Ÿå‘½å‘¨æœŸ</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">pub fn strtok&lt;'a&gt;(s: &amp;mut &amp;'a str, delimiter: char) -&gt; &amp;'a str {
    if let Some(i) = s.find(delimiter) {
        let prefix = &amp;s[..i];
        // ç”±äº delimiter å¯ä»¥æ˜¯ utf8ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦è·å¾—å…¶ utf8 é•¿åº¦ï¼Œ
        // ç›´æ¥ä½¿ç”¨ len è¿”å›çš„æ˜¯å­—èŠ‚é•¿åº¦ï¼Œä¼šæœ‰é—®é¢˜
        let suffix = &amp;s[(i + delimiter.len_utf8())..];
        *s = suffix;
        prefix
    } else {
        // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œè¿”å›æ•´ä¸ªå­—ç¬¦ä¸²ï¼ŒæŠŠåŸå­—ç¬¦ä¸²æŒ‡é’ˆ s æŒ‡å‘ç©ºä¸²
        let prefix = *s;
        *s = &quot;&quot;;
        prefix
    }
}

fn main() {
    let s = String::from(&quot;hello world&quot;);
    let mut s1 = s.as_str();
    let hello = strtok(&amp;mut s1, ' ');
    println!(&quot;hello is: {}, s1: {}, s: {}&quot;, hello, s1, s);
}</code></pre></pre>
<p><img src="../images/rust/lifetime-example.webp" alt="lifetime" /></p>
<blockquote>
<p>æ³¨æ„ï¼šå½“ä½ è¦è¿”å›åœ¨å‡½æ•°æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œåˆ›å»ºçš„æˆ–è€…å¾—åˆ°çš„æ•°æ®ï¼Œå’Œå‚æ•°æ— å…³ï¼Œé‚£ä¹ˆæ— è®ºå®ƒæ˜¯ä¸€ä¸ªæœ‰æ‰€æœ‰æƒçš„æ•°æ®ï¼Œè¿˜æ˜¯ä¸€ä¸ªå¼•ç”¨ï¼Œä½ åªèƒ½è¿”å›å¸¦æ‰€æœ‰æƒçš„æ•°æ®ã€‚å¯¹äºå¼•ç”¨ï¼Œè¿™å°±æ„å‘³ç€è°ƒç”¨ <code>clone()</code> æˆ–è€… <code>to_owned()</code> æ¥ä»å¼•ç”¨ä¸­å¾—åˆ°æ‰€æœ‰æƒã€‚</p>
</blockquote>
<h2 id="ç»“æ„ä½“æˆå‘˜è‡ªåŠ¨é‡æ’"><a class="header" href="#ç»“æ„ä½“æˆå‘˜è‡ªåŠ¨é‡æ’">ç»“æ„ä½“æˆå‘˜è‡ªåŠ¨é‡æ’</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use std::mem::{align_of, size_of};

struct S1 {
    a: u8,
    b: u16,
    c: u8,
}

struct S2 {
    a: u8,
    c: u8,
    b: u16,
}

#[repr(C)]
struct S3 {
    a: u8,
    b: u16,
    c: u8,
}

fn main() {
    println!(
        &quot;sizeof S1: {}, S2: {}, S3: {}&quot;,
        size_of::&lt;S1&gt;(),
        size_of::&lt;S2&gt;(),
        size_of::&lt;S3&gt;()
    );
    println!(
        &quot;alignof S1: {}, S2: {}, S3: {}&quot;,
        align_of::&lt;S1&gt;(),
        align_of::&lt;S2&gt;(),
        align_of::&lt;S3&gt;()
    );
}</code></pre></pre>
<p>Rust ç¼–è¯‘å™¨é»˜ä¼šä¼˜åŒ–ç»“æ„ä½“çš„æ’åˆ—ï¼Œä½†æˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨ <code>#[repr]</code> å®ï¼Œå¼ºåˆ¶è®© Rust ç¼–è¯‘å™¨ä¸åšä¼˜åŒ–ï¼Œå’Œ C çš„è¡Œä¸ºä¸€è‡´ï¼Œè¿™æ ·ï¼ŒRust ä»£ç å¯ä»¥æ–¹ä¾¿åœ°å’Œ C ä»£ç æ— ç¼äº¤äº’ã€‚</p>
<h2 id="enum-çš„å†…å­˜å¸ƒå±€"><a class="header" href="#enum-çš„å†…å­˜å¸ƒå±€">enum çš„å†…å­˜å¸ƒå±€</a></h2>
<p><img src="../images/rust/enum-memory-layout.webp" alt="enum" /></p>
<p>enum æ˜¯ä¸€ä¸ªæ ‡ç­¾è”åˆä½“ï¼ˆtagged unionï¼‰ï¼Œå®ƒçš„å¤§å°æ˜¯æ ‡ç­¾çš„å¤§å°ï¼ŒåŠ ä¸Šæœ€å¤§ç±»å‹çš„é•¿åº¦ã€‚æ‰€ä»¥å¯¹äº <code>Option&lt;u8&gt;</code>ï¼Œå…¶é•¿åº¦æ˜¯ 1 + 1 = 2 å­—èŠ‚ï¼Œè€Œ <code>Option&lt;f64&gt;</code>ï¼Œé•¿åº¦æ˜¯ 8 + 8 =16 å­—èŠ‚ã€‚</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::HashMap;
use std::mem::size_of;

enum MyEnum {
    A(f64),
    B(HashMap&lt;String, String&gt;),
    C(Result&lt;Vec&lt;u8&gt;, String&gt;),
}

// è¿™æ˜¯ä¸€ä¸ªå£°æ˜å®ï¼Œå®ƒä¼šæ‰“å°å„ç§æ•°æ®ç»“æ„æœ¬èº«çš„å¤§å°ï¼Œåœ¨ Option ä¸­çš„å¤§å°ï¼Œä»¥åŠåœ¨ Result ä¸­çš„å¤§å°
macro_rules! show_size {
    (header) =&gt; {
        println!(
            &quot;{:&lt;24} {:&gt;4}    {}    {}&quot;,
            &quot;Type&quot;, &quot;T&quot;, &quot;Option&lt;T&gt;&quot;, &quot;Result&lt;T, io::Error&gt;&quot;
        );
        println!(&quot;{}&quot;, &quot;-&quot;.repeat(64));
    };
    ($t:ty) =&gt; {
        println!(
            &quot;{:&lt;24} {:4} {:8} {:12}&quot;,
            stringify!($t),
            size_of::&lt;$t&gt;(),
            size_of::&lt;Option&lt;$t&gt;&gt;(),
            size_of::&lt;Result&lt;$t, std::io::Error&gt;&gt;(),
        )
    };
}

fn main() {
    show_size!(header);
    show_size!(u8);
    show_size!(f64);
    show_size!(&amp;u8);
    show_size!(Box&lt;u8&gt;);
    show_size!(&amp;[u8]);

    show_size!(String);
    show_size!(Vec&lt;u8&gt;);
    show_size!(HashMap&lt;String, String&gt;);
    show_size!(MyEnum);
}</code></pre></pre>
<p>ä½†æ˜¯ Rust ç¼–è¯‘å™¨ä¼šå¯¹ enum åšä¸€äº›é¢å¤–çš„ä¼˜åŒ–ï¼Œè®©æŸäº›å¸¸ç”¨ç»“æ„çš„å†…å­˜å¸ƒå±€æ›´ç´§å‡‘ã€‚Option é…åˆå¸¦æœ‰å¼•ç”¨ç±»å‹çš„æ•°æ®ç»“æ„ï¼Œæ¯”å¦‚ &amp;u8ã€Boxã€Vecã€HashMap ï¼Œæ²¡æœ‰é¢å¤–å ç”¨ç©ºé—´ã€‚å¼•ç”¨ç±»å‹çš„ç¬¬ä¸€ä¸ªåŸŸæ˜¯ä¸ªæŒ‡é’ˆï¼Œè€ŒæŒ‡é’ˆæ˜¯ä¸å¯èƒ½ç­‰äº 0 çš„ï¼Œé€šè¿‡å¤ç”¨è¿™ä¸ªæŒ‡é’ˆï¼šå½“å…¶ä¸º 0 æ—¶ï¼Œè¡¨ç¤º Noneï¼Œå¦åˆ™æ˜¯ Someï¼Œå‡å°‘äº†å†…å­˜å ç”¨ã€‚</p>
<h2 id="çº¿ç¨‹å®‰å…¨çš„å…¨å±€å˜é‡-lazy_static"><a class="header" href="#çº¿ç¨‹å®‰å…¨çš„å…¨å±€å˜é‡-lazy_static">çº¿ç¨‹å®‰å…¨çš„å…¨å±€å˜é‡ (lazy_static)</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use lazy_static::lazy_static;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

lazy_static! {
    static ref HASHMAP: Arc&lt;Mutex&lt;HashMap&lt;u32, &amp;'static str&gt;&gt;&gt; = {
        let mut m = HashMap::new();
        m.insert(0, &quot;foo&quot;);
        m.insert(1, &quot;bar&quot;);
        m.insert(2, &quot;baz&quot;);
        Arc::new(Mutex::new(m))
    };
}

fn main() {
    let mut map = HASHMAP.lock().unwrap();
    map.insert(3, &quot;waz&quot;);

    println!(&quot;map: {:?}&quot;, map);
}</code></pre></pre>
<h2 id="å¸¦å…³è”ç±»å‹çš„-trait"><a class="header" href="#å¸¦å…³è”ç±»å‹çš„-trait">å¸¦å…³è”ç±»å‹çš„ trait</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use std::str::FromStr;

use lazy_static::lazy_static;
use regex::Regex;

pub trait ParseFromStr {
    type Error;
    fn parse_from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Error&gt;
    where
        Self: Sized;
}

impl&lt;T&gt; ParseFromStr for T
where
    T: FromStr,
{
    // å®šä¹‰å…³è”ç±»å‹ Error ä¸º String
    type Error = String;

    fn parse_from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Error&gt; {
        // ensure that regular expressions are compiled exactly once.
        lazy_static! {
            static ref RE: Regex = Regex::new(r&quot;^\d+(\.\d+)?&quot;).unwrap();
        };
        if let Some(captures) = RE.captures(s) {
            captures
                .get(0)
                .map_or(Err(&quot;failed to capture&quot;.to_string()), |s| {
                    s.as_str()
                        .parse()
                        .map_err(|_e| &quot;failed to parse captured string&quot;.to_string())
                })
        } else {
            Err(&quot;failed to parse string&quot;.to_string())
        }
    }
}

fn main() {
    println!(&quot;result: {}&quot;, u8::parse_from_str(&quot;255 hello&quot;).unwrap());
    println!(&quot;result: {}&quot;, u8::parse_from_str(&quot;001 world&quot;).unwrap());
    println!(&quot;result: {}&quot;, u8::parse_from_str(&quot;!&quot;).unwrap_or_default());
    println!(&quot;result: {}&quot;, f64::parse_from_str(&quot;123.45abc&quot;).unwrap());
}</code></pre></pre>
<h2 id="trait-object-çš„å®ç°æœºåˆ¶"><a class="header" href="#trait-object-çš„å®ç°æœºåˆ¶">trait object çš„å®ç°æœºåˆ¶</a></h2>
<p><img src="../images/rust/trait-object.webp" alt="trait object çš„å†…å­˜å¸ƒå±€" /></p>
<p>trait object çš„åº•å±‚é€»è¾‘å°±æ˜¯æ—æŒ‡é’ˆï¼Œå…¶ä¸­ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘æ•°æ®æœ¬èº«ï¼Œå¦ä¸€ä¸ªåˆ™æŒ‡å‘è™šå‡½æ•°è¡¨ï¼ˆvtableï¼‰ã€‚vtable æ˜¯ä¸€å¼ é™æ€çš„è¡¨ï¼ŒRust åœ¨ç¼–è¯‘æ—¶ä¼šä¸ºä½¿ç”¨äº† trait object çš„ç±»å‹çš„ trait å®ç°ç”Ÿæˆä¸€å¼ è¡¨ï¼Œæ”¾åœ¨å¯æ‰§è¡Œæ–‡ä»¶ä¸­ï¼ˆä¸€èˆ¬åœ¨textæˆ–rodataæ®µï¼‰ã€‚</p>
<p>å¦‚æœ trait <strong>æ‰€æœ‰</strong>çš„æ–¹æ³•ï¼Œè¿”å›å€¼æ˜¯ Self æˆ–è€…æºå¸¦æ³›å‹å‚æ•°ï¼Œé‚£ä¹ˆè¿™ä¸ª trait å°±ä¸èƒ½äº§ç”Ÿ trait objectã€‚trait object åœ¨äº§ç”Ÿæ—¶ï¼ŒåŸæ¥çš„ç±»å‹ä¼šè¢«æŠ¹å»ï¼Œæ‰€ä»¥ Self ç©¶ç«Ÿæ˜¯è°ä¸çŸ¥é“ã€‚Rust é‡Œå¸¦æ³›å‹çš„ç±»å‹åœ¨ç¼–è¯‘æ—¶ä¼šåš<strong>å•æ€åŒ–</strong>ï¼Œè€Œ trait object æ˜¯è¿è¡Œæ—¶çš„äº§ç‰©ï¼Œä¸¤è€…ä¸èƒ½å…¼å®¹ã€‚<strong>å¦‚æœä¸€ä¸ª trait åªæœ‰éƒ¨åˆ†æ–¹æ³•è¿”å› Self æˆ–è€…æºå¸¦æ³›å‹å‚æ•°ï¼Œé‚£ä¹ˆè¿™éƒ¨åˆ†æ–¹æ³•åœ¨ trait object ä¸­ä¸èƒ½è¢«è°ƒç”¨</strong>ã€‚</p>
<h2 id="å¸¸ç”¨-trait-ä»‹ç»"><a class="header" href="#å¸¸ç”¨-trait-ä»‹ç»">å¸¸ç”¨ trait ä»‹ç»</a></h2>
<h3 id="clone"><a class="header" href="#clone">Clone</a></h3>
<p>Clone æ˜¯æ·±åº¦æ‹·è´ï¼Œæ ˆå†…å­˜å’Œå †å†…å­˜ä¸€èµ·æ‹·è´ã€‚</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Clone {
    // åœ¨ clone ä¸€ä¸ªæ•°æ®æ—¶åªéœ€è¦æœ‰å·²æœ‰æ•°æ®çš„åªè¯»å¼•ç”¨
    fn clone(&amp;self) -&gt; Self;

    fn clone_from(&amp;mut self, source: &amp;Self) {
        *self = source.clone()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="copy"><a class="header" href="#copy">Copy</a></h3>
<p>Copy trait æ²¡æœ‰ä»»ä½•é¢å¤–çš„æ–¹æ³•ï¼Œå®ƒåªæ˜¯ä¸€ä¸ªæ ‡è®° traitï¼Œå¯ä»¥ç”¨ä½œ trait bound æ¥è¿›è¡Œç±»å‹å®‰å…¨æ£€æŸ¥ã€‚</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// å¦‚æœè¦å®ç° Copy trait çš„è¯ï¼Œå¿…é¡»å®ç° Clone traitã€‚
pub trait Copy: Clone {}
<span class="boring">}</span></code></pre></pre>
<h3 id="drop"><a class="header" href="#drop">Drop</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Drop {
    fn drop(&amp;mut self);
}
<span class="boring">}</span></code></pre></pre>
<p>å¤§éƒ¨åˆ†åœºæ™¯æ— éœ€ä¸ºæ•°æ®ç»“æ„æä¾› Drop traitï¼Œç³»ç»Ÿé»˜è®¤ä¼šä¾æ¬¡å¯¹æ•°æ®ç»“æ„çš„æ¯ä¸ªåŸŸåš dropã€‚ä½†æœ‰ä¸¤ç§æƒ…å†µéœ€è¦æ‰‹åŠ¨å®ç° Drop:</p>
<ol>
<li>å¸Œæœ›åœ¨æ•°æ®ç»“æŸç”Ÿå‘½å‘¨æœŸçš„æ—¶å€™åšä¸€äº›äº‹æƒ…ï¼Œæ¯”å¦‚è®°å½•æ—¥å¿—</li>
<li>éœ€è¦å¯¹èµ„æºè¿›è¡Œå›æ”¶ï¼Œæ¯”å¦‚é”èµ„æºçš„é‡Šæ”¾</li>
</ol>
<p><strong>Copy trait å’Œ Drop trait æ˜¯äº’æ–¥çš„ï¼Œä¸¤è€…ä¸èƒ½å…±å­˜</strong>ã€‚å› ä¸º Copy æ˜¯æŒ‰ä½åšæµ…æ‹·è´ï¼Œå®ƒæ‹·è´çš„æ•°æ®æ²¡æœ‰éœ€è¦é‡Šæ”¾çš„èµ„æºï¼Œè€Œ Drop æ°æ°æ˜¯ä¸ºäº†é‡Šæ”¾é¢å¤–çš„èµ„æºè€Œç”Ÿçš„ã€‚</p>
<h3 id="sized"><a class="header" href="#sized">Sized</a></h3>
<p>Sized trait ç”¨äºæ ‡è®°æœ‰å…·ä½“å¤§å°çš„ç±»å‹ã€‚åœ¨ä½¿ç”¨æ³›å‹å‚æ•°æ—¶ï¼ŒRust ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ä¸ºæ³›å‹å‚æ•°åŠ ä¸Š Sized çº¦æŸã€‚å¦‚æœå¼€å‘è€…æ˜¾å¼å®šä¹‰äº†T: ?Sizedï¼Œé‚£ä¹ˆ T å°±å¯ä»¥æ˜¯ä»»æ„å¤§å°ã€‚</p>
<h3 id="send--sync-ç”¨äºå¹¶å‘å®‰å…¨"><a class="header" href="#send--sync-ç”¨äºå¹¶å‘å®‰å…¨">Send / Sync ç”¨äºå¹¶å‘å®‰å…¨</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe auto trait Send {}
pub unsafe auto trait Sync {}
<span class="boring">}</span></code></pre></pre>
<p>è¿™é‡Œçš„ <code>auto</code> æ„å‘³ç€ç¼–è¯‘å™¨ä¼šåœ¨åˆé€‚çš„åœºåˆï¼Œè‡ªåŠ¨ä¸ºæ•°æ®ç»“æ„æ·»åŠ å®ƒä»¬çš„å®ç°ã€‚</p>
<p>å¦‚æœä¸€ä¸ªç±»å‹ T å®ç°äº† Send trait,æ„å‘³ç€ T å¯ä»¥å®‰å…¨åœ°ä»ä¸€ä¸ªçº¿ç¨‹ç§»åŠ¨åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ï¼Œå³æ‰€æœ‰æƒå¯ä»¥åœ¨çº¿ç¨‹é—´ç§»åŠ¨ã€‚
å¦‚æœä¸€ä¸ªç±»å‹ T å®ç°äº† Sync trait,æ„å‘³ç€ &amp;T å¯ä»¥å®‰å…¨åœ°åœ¨å¤šä¸ªçº¿ç¨‹é—´å…±äº«ã€‚</p>
<p>å¯¹äº Send/Sync åœ¨çº¿ç¨‹å®‰å…¨ä¸­çš„ä½œç”¨ï¼šå¦‚æœä¸€ä¸ªç±»å‹ <code>T: Send</code>ï¼Œé‚£ä¹ˆ T åœ¨æŸä¸ªçº¿ç¨‹ä¸­çš„<strong>ç‹¬å è®¿é—®</strong>æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼›å¦‚æœä¸€ä¸ªç±»å‹ <code>T: Sync</code>ï¼Œé‚£ä¹ˆ T åœ¨çº¿ç¨‹é—´çš„<strong>åªè¯»å…±äº«</strong>æ˜¯å®‰å…¨çš„ã€‚</p>
<p>å¼•ç”¨è®¡æ•° <code>Rc&lt;T&gt;</code> ä¸æ”¯æŒ Send ä¹Ÿä¸æ”¯æŒ Syncã€‚æ‰€ä»¥ <code>Rc&lt;T&gt;</code> æ— æ³•è·¨çº¿ç¨‹ã€‚
<code>RefCell&lt;T&gt;</code> å®ç°äº† Sendï¼Œæ‰€ä»¥å¯ä»¥åœ¨çº¿ç¨‹é—´è½¬ç§»æ‰€æœ‰æƒã€‚ä½†æ²¡æœ‰å®ç° Syncï¼Œå› æ­¤æ— æ³•è·¨çº¿ç¨‹ä½¿ç”¨ <code>Arc&lt;RefCell&lt;T&gt;&gt;</code> è¿™æ ·çš„æ•°æ®ï¼ˆå› ä¸º Arc å†…éƒ¨çš„æ•°æ®æ˜¯å…±äº«çš„ï¼Œéœ€è¦æ”¯æŒ Sync çš„æ•°æ®ç»“æ„ï¼‰ã€‚</p>
<h3 id="fromt--intot-ç”¨äºä»å€¼åˆ°å€¼çš„è½¬æ¢"><a class="header" href="#fromt--intot-ç”¨äºä»å€¼åˆ°å€¼çš„è½¬æ¢">From&lt;T&gt; / Into&lt;T&gt; ç”¨äºä»å€¼åˆ°å€¼çš„è½¬æ¢</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait From&lt;T&gt; {
    fn from(t: T) -&gt; Self;
}

pub trait Into&lt;T&gt; {
    fn into(self) -&gt; T;
}

// å®ç° From ä¼šè‡ªåŠ¨å®ç° Into
impl&lt;T, U&gt; Into&lt;U&gt; for T where U: From&lt;T&gt; {
    fn into(self) -&gt; U {
        U::from(self)
    }
}

// Fromï¼ˆä»¥åŠ Intoï¼‰æ˜¯è‡ªåçš„ï¼šæŠŠç±»å‹ T çš„å€¼è½¬æ¢æˆç±»å‹ T,ä¼šç›´æ¥è¿”å›
impl&lt;T&gt; From&lt;T&gt; for T {
    fn from(t: T) -&gt; T {
        t
    }
}
<span class="boring">}</span></code></pre></pre>
<p>æœ‰äº†è¿™ä¸¤ä¸ª trait,å‡½æ•°çš„æ¥å£å°±å¯ä»¥å˜å¾—çµæ´»ï¼Œæ¯”å¦‚å‡½æ•°å¦‚æœæ¥å—ä¸€ä¸ª IpAddr ä¸ºå‚æ•°ï¼Œé‚£å°±å¯ä»¥ä½¿ç”¨ <code>Into&lt;IpAddr&gt;</code> è®©æ›´å¤šçš„ç±»å‹å¯ä»¥è¢«è¿™ä¸ªå‡½æ•°ä½¿ç”¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};

fn print(v: impl Into&lt;IpAddr&gt;) {
    println!(&quot;{:?}&quot;, v.into());
}

fn main() {
    let v4: Ipv4Addr = &quot;2.2.2.2&quot;.parse().unwrap();
    let v6: Ipv6Addr = &quot;::1&quot;.parse().unwrap();

    // IPAddr å®ç°äº† From&lt;[u8; 4]ï¼Œè½¬æ¢ IPv4 åœ°å€
    print([1, 1, 1, 1]);
    // IPAddr å®ç°äº† From&lt;[u16; 8]ï¼Œè½¬æ¢ IPv6 åœ°å€
    print([0xfe80, 0, 0, 0, 0xaede, 0x48ff, 0xfe00, 0x1122]);
    // IPAddr å®ç°äº† From&lt;Ipv4Addr&gt;
    print(v4);
    // IPAddr å®ç°äº† From&lt;Ipv6Addr&gt;
    print(v6);
}</code></pre></pre>
<p>å¦‚æœæ•°æ®ç±»å‹åœ¨è½¬æ¢è¿‡ç¨‹ä¸­æœ‰å¯èƒ½å‡ºç°é”™è¯¯ï¼Œå°±éœ€è¦ä½¿ç”¨ TryFrom&lt;T&gt; å’Œ TryInto&lt;T&gt;ã€‚</p>
<h3 id="asreft--asmutt-ç”¨äºä»å¼•ç”¨åˆ°å¼•ç”¨çš„è½¬æ¢"><a class="header" href="#asreft--asmutt-ç”¨äºä»å¼•ç”¨åˆ°å¼•ç”¨çš„è½¬æ¢">AsRef&lt;T&gt; / AsMut&lt;T&gt; ç”¨äºä»å¼•ç”¨åˆ°å¼•ç”¨çš„è½¬æ¢</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// T ä½¿ç”¨å¤§å°å¯å˜çš„ç±»å‹ï¼Œå¦‚ strã€[u8] ç­‰
pub trait AsRef&lt;T&gt; where T: ?Sized {
    fn as_ref(&amp;self) -&gt; &amp;T;
}

pub trait AsMut&lt;T&gt; where T: ?Sized {
    fn as_mut(&amp;mut self) -&gt; &amp;mut T;
}
<span class="boring">}</span></code></pre></pre>
<p>æ ‡å‡†åº“ä¸­æ‰“å¼€æ–‡ä»¶çš„æ¥å£ <code>std::fs::File::open</code></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn open&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;File&gt;
<span class="boring">}</span></code></pre></pre>
<p>æ„å‘³ç€æˆ‘ä»¬å¯ä»¥ä¸ºè¿™ä¸ªå‚æ•°ä¼ å…¥ Stringã€&amp;strã€PathBufã€Path ç­‰ç±»å‹ï¼Œå½“ä½¿ç”¨ <code>path.as_ref()</code> æ—¶ï¼Œå°±èƒ½å¾—åˆ°ä¸€ä¸ª <code>&amp;Path</code>ã€‚</p>
<h3 id="deref--derefmut"><a class="header" href="#deref--derefmut">Deref / DerefMut</a></h3>
<p>Rust ä¸ºæ‰€æœ‰çš„è¿ç®—ç¬¦éƒ½æä¾›äº† traitï¼Œæˆ‘ä»¬å¯ä»¥ç»™è‡ªå®šä¹‰ç±»å‹é‡è½½æŸäº›æ“ä½œç¬¦ã€‚</p>
<p><img src="../images/rust/operators.webp" alt="æ“ä½œè¿ç®—ç¬¦" /></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Deref {
    // è§£å¼•ç”¨å‡ºæ¥çš„ç»“æœç±»å‹
    type Target: ?Sized;
    fn deref(&amp;self) -&gt; &amp;Self::Target;
}

// DerefMut â€œç»§æ‰¿â€äº† Deref
pub trait DerefMut: Deref {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Deref å’Œ DerefMut æ˜¯è‡ªåŠ¨è°ƒç”¨çš„ï¼Œ<code>*b</code> ä¼šè¢«å±•å¼€ä¸º <code>*(b.deref())</code></strong>ã€‚</p>
<p><img src="../images/rust/deref.webp" alt="deref" /></p>
<h3 id="debug--display"><a class="header" href="#debug--display">Debug / Display</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Debug {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}

pub trait Display {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Debug æ˜¯ä¸ºå¼€å‘è€…è°ƒè¯•æ‰“å°æ•°æ®ç»“æ„æ‰€è®¾è®¡çš„ï¼Œè€Œ Display æ˜¯ç»™ç”¨æˆ·æ˜¾ç¤ºæ•°æ®ç»“æ„æ‰€è®¾è®¡çš„ã€‚Debug trait çš„å®ç°å¯ä»¥é€šè¿‡æ´¾ç”Ÿå®ç›´æ¥ç”Ÿæˆï¼Œè€Œ <strong>Display å¿…é¡»æ‰‹å·¥å®ç°</strong>ã€‚åœ¨ä½¿ç”¨çš„æ—¶å€™ï¼ŒDebug ç”¨ {:?} æ¥æ‰“å°ï¼ŒDisplay ç”¨ {} æ‰“å°ã€‚</p>
<h3 id="default-ä¸ºç±»å‹æä¾›ç¼ºçœå€¼"><a class="header" href="#default-ä¸ºç±»å‹æä¾›ç¼ºçœå€¼">Default ä¸ºç±»å‹æä¾›ç¼ºçœå€¼</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Default {
    fn default() -&gt; Self;
}
<span class="boring">}</span></code></pre></pre>
<p>å¯ä»¥é€šè¿‡ derive å® #[derive(Default)] æ¥ç”Ÿæˆå®ç°ï¼Œå‰ææ˜¯ç±»å‹ä¸­çš„æ¯ä¸ªå­—æ®µéƒ½å®ç°äº† Default traitã€‚æ³¨æ„ï¼Œenum ä¸èƒ½é€šè¿‡ derive å®æ¥å®ç° Defaultï¼Œå› ä¸º enum çš„æ¯ä¸ªå˜ä½“éƒ½å¯èƒ½æœ‰ä¸åŒçš„å­—æ®µï¼Œæ‰€ä»¥éœ€è¦æ‰‹åŠ¨å®ç°ã€‚</p>
<p>åœ¨åˆå§‹åŒ–ä¸€ä¸ªæ•°æ®ç»“æ„æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥éƒ¨åˆ†åˆå§‹åŒ–ï¼Œç„¶åå‰©ä½™çš„éƒ¨åˆ†ä½¿ç”¨ <code>..Default::default()</code>ã€‚</p>
<h2 id="æ™ºèƒ½æŒ‡é’ˆ"><a class="header" href="#æ™ºèƒ½æŒ‡é’ˆ">æ™ºèƒ½æŒ‡é’ˆ</a></h2>
<h3 id="æ™ºèƒ½æŒ‡é’ˆ-vs-èƒ–æŒ‡é’ˆ"><a class="header" href="#æ™ºèƒ½æŒ‡é’ˆ-vs-èƒ–æŒ‡é’ˆ">æ™ºèƒ½æŒ‡é’ˆ vs èƒ–æŒ‡é’ˆ</a></h3>
<p>æ™ºèƒ½æŒ‡é’ˆä¸€å®šæ˜¯èƒ–æŒ‡é’ˆï¼ˆæ¯”å¦‚ <code>String</code>ï¼‰ï¼Œä½†æ˜¯èƒ–æŒ‡é’ˆä¸ä¸€å®šæ˜¯ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆï¼ˆæ¯”å¦‚ <code>&amp;str</code>ï¼‰ï¼Œå› ä¸º String å¯¹å †ä¸Šçš„å€¼æœ‰æ‰€æœ‰æƒï¼Œè€Œ &amp;str æ²¡æœ‰æ‰€æœ‰æƒã€‚</p>
<h3 id="æ™ºèƒ½æŒ‡é’ˆ-vs-ç»“æ„ä½“"><a class="header" href="#æ™ºèƒ½æŒ‡é’ˆ-vs-ç»“æ„ä½“">æ™ºèƒ½æŒ‡é’ˆ vs ç»“æ„ä½“</a></h3>
<p>å‡¡æ˜¯éœ€è¦åšèµ„æºå›æ”¶çš„æ•°æ®ç»“æ„ï¼Œä¸”å®ç°äº† <code>Deref/DerefMut/Drop</code>ï¼Œéƒ½æ˜¯æ™ºèƒ½æŒ‡é’ˆã€‚</p>
<h3 id="boxt"><a class="header" href="#boxt">Box&lt;T&gt;</a></h3>
<h4 id="new-æ–¹æ³•"><a class="header" href="#new-æ–¹æ³•"><code>new</code> æ–¹æ³•</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[cfg(not(no_global_oom_handling))]
#[inline(always)]
pub fn new(x: T) -&gt; Self {
    // box æ˜¯ Rust çš„å†…éƒ¨å…³é”®å­—ï¼Œåœ¨ç¼–è¯‘æ—¶ï¼Œä¼šä½¿ç”¨å†…å­˜åˆ†é…å™¨æ¥åˆ†é…å†…å­˜
    box x
}
<span class="boring">}</span></code></pre></pre>
<p>Box::new() æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œåœ¨ debug æ¨¡å¼ä¸‹ï¼Œä¼ å…¥å®ƒçš„æ•°æ®ä¼šå‡ºç°åœ¨æ ˆä¸Šï¼Œå†ç§»åŠ¨åˆ°å †ä¸Šï¼Œæœ‰å¯èƒ½ä¼šå¼•èµ·æ ˆæº¢å‡ºã€‚åœ¨ release æ¨¡å¼ä¸‹ï¼Œè¯¥å‡½æ•°è°ƒç”¨ä¼šè¢«<strong>inline</strong>ä¼˜åŒ–ã€‚</p>
<h4 id="å®ç°-drop-trait"><a class="header" href="#å®ç°-drop-trait">å®ç° <code>Drop</code> trait</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe impl&lt;#[may_dangle] T: ?Sized, A: Allocator&gt; Drop for Box&lt;T, A&gt; {
    fn drop(&amp;mut self) {
        // Do nothing, drop is currently performed by compiler.
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="cowa-b"><a class="header" href="#cowa-b">Cow&lt;'a, B&gt;</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Cow&lt;'a, B&gt; where B: 'a + ToOwned + ?Sized {
  Borrowed(&amp;'a B),
  Owned(&lt;B as ToOwned&gt;::Owned),
}
<span class="boring">}</span></code></pre></pre>
<p>Cow åŒ…è£¹äº†ä¸€ä¸ªåªè¯»å€Ÿç”¨ï¼Œä½†å¦‚æœè°ƒç”¨è€…éœ€è¦æ‰€æœ‰æƒæˆ–è€…éœ€è¦ä¿®æ”¹å†…å®¹ï¼Œé‚£ä¹ˆå®ƒä¼š clone å€Ÿç”¨çš„æ•°æ®ã€‚è¿™ç§æ•°æ®ç»“æ„å¯ä»¥å‡å°‘ä¸å¿…è¦çš„å †å†…å­˜åˆ†é…ï¼Œæå‡ç³»ç»Ÿæ•ˆç‡ã€‚</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ToOwned {
    type Owned: Borrow&lt;Self&gt;;
    #[must_use = &quot;cloning is often expensive and is not expected to have side effects&quot;]
    fn to_owned(&amp;self) -&gt; Self::Owned;

    fn clone_into(&amp;self, target: &amp;mut Self::Owned) { ... }
}

// Borrow æ˜¯ä¸ªæ³›å‹ traitï¼Œè¡¨æ˜ä¸€ä¸ªç±»å‹å¯ä»¥è¢«å€Ÿç”¨æˆä¸åŒçš„å¼•ç”¨
// æ¯”å¦‚ String å¯ä»¥è¢«å€Ÿç”¨ä¸º &amp;String æˆ–è€… &amp;str
pub trait Borrow&lt;Borrowed&gt; where Borrowed: ?Sized {
    fn borrow(&amp;self) -&gt; &amp;Borrowed;
}
<span class="boring">}</span></code></pre></pre>
<p>str å¯¹ <code>ToOwned</code> trait çš„å®ç°ï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ToOwned for str {
    type Owned = String;
    #[inline]
    fn to_owned(&amp;self) -&gt; String {
        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }
    }

    fn clone_into(&amp;self, target: &amp;mut String) {
        let mut b = mem::take(target).into_bytes();
        self.as_bytes().clone_into(&amp;mut b);
        *target = unsafe { String::from_utf8_unchecked(b) }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>åŒæ—¶ String å¿…é¡»è¦å®ç° <code>Borrow&lt;str&gt;</code> traitï¼Œè¿™æ ·èƒ½ç¬¦åˆ ToOwned çš„è¦æ±‚ã€‚</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Borrow&lt;str&gt; for String {
    #[inline]
    fn borrow(&amp;self) -&gt; &amp;str {
        &amp;self[..]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>ç»™ Cow å®ç° Deref</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: ?Sized + ToOwned&gt; Deref for Cow&lt;'_, B&gt; {
    type Target = B;

    fn deref(&amp;self) -&gt; &amp;B {
        // æˆ‘ä»¬åˆ†åˆ«å–å…¶å†…å®¹ï¼Œç”Ÿæˆå¼•ç”¨
        match *self {
            Borrowed(borrowed) =&gt; borrowed, // å¯¹äº Borrowedï¼Œç›´æ¥å°±æ˜¯å–å‡ºå½“ä¸­çš„å¼•ç”¨
            Owned(ref owned) =&gt; owned.borrow(), // å¯¹äº Ownedï¼Œè°ƒç”¨å…¶ borrow() æ–¹æ³•ï¼Œè·å¾—å¼•ç”¨
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="åº”ç”¨æ¡ˆä¾‹"><a class="header" href="#åº”ç”¨æ¡ˆä¾‹">åº”ç”¨æ¡ˆä¾‹</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">use std::borrow::Cow;
use url::Url;

fn main() {
    let url = Url::parse(&quot;https://tyr.com/rust?page=1024&amp;sort=desc&amp;extra=hello%20world&quot;).unwrap();
    let mut pairs = url.query_pairs();

    assert_eq!(pairs.count(), 3);

    let (mut k, v) = pairs.next().unwrap();
    // å› ä¸º k, v éƒ½æ˜¯ Cow&lt;str&gt; ä»–ä»¬ç”¨èµ·æ¥æ„Ÿè§‰å’Œ &amp;str æˆ–è€… String ä¸€æ ·
    // æ­¤åˆ»ï¼Œä»–ä»¬éƒ½æ˜¯ Borrowed
    println!(&quot;key: {}, v: {}&quot;, k, v);
    // å½“ä¿®æ”¹å‘ç”Ÿæ—¶ï¼Œk å˜æˆ Owned
    k.to_mut().push_str(&quot;_lala&quot;);

    print_pairs((k, v));

    print_pairs(pairs.next().unwrap());
    // åœ¨å¤„ç† extra=hello%20world æ—¶ï¼Œvalue è¢«å¤„ç†æˆ &quot;hello world&quot;
    // æ‰€ä»¥è¿™é‡Œ value æ˜¯ Owned
    print_pairs(pairs.next().unwrap());
}

fn print_pairs(pair: (Cow&lt;str&gt;, Cow&lt;str&gt;)) {
    println!(&quot;key: {}, value: {}&quot;, show_cow(pair.0), show_cow(pair.1));
}

fn show_cow(cow: Cow&lt;str&gt;) -&gt; String {
    match cow {
        Cow::Borrowed(v) =&gt; format!(&quot;Borrowed {}&quot;, v),
        Cow::Owned(v) =&gt; format!(&quot;Owned {}&quot;, v),
    }
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">use serde::Deserialize;
use std::borrow::Cow;

#[derive(Debug, Deserialize)]
struct User&lt;'input&gt; {
    #[serde(borrow)]
    name: Cow&lt;'input, str&gt;,
    age: u8,
}

fn main() {
    let input = r#&quot;{ &quot;name&quot;: &quot;Tyr&quot;, &quot;age&quot;: 18 }&quot;#;
    let user: User = serde_json::from_str(input).unwrap();

    match user.name {
        Cow::Borrowed(x) =&gt; println!(&quot;borrowed {}&quot;, x),
        Cow::Owned(x) =&gt; println!(&quot;owned {}&quot;, x),
    }
}</code></pre></pre>
<h3 id="mutexguardt"><a class="header" href="#mutexguardt">MutexGuard&lt;T&gt;</a></h3>
<p>MutexGuard é€šè¿‡ Drop trait æ¥ç¡®ä¿é€€å‡ºæ—¶é‡Šæ”¾äº’æ–¥é”ï¼Œè¿™æ ·ç”¨æˆ·åœ¨ä½¿ç”¨ Mutex æ—¶ï¼Œå¯ä»¥ä¸å¿…å…³å¿ƒä½•æ—¶é‡Šæ”¾è¿™ä¸ªäº’æ–¥é”ã€‚å› ä¸ºæ— è®ºä½ åœ¨è°ƒç”¨æ ˆä¸Šæ€æ ·ä¼ é€’ MutexGuard ï¼Œå“ªæ€•åœ¨é”™è¯¯å¤„ç†æµç¨‹ä¸Šæå‰é€€å‡ºï¼ŒRust çš„æ‰€æœ‰æƒæœºåˆ¶å¯ä»¥ç¡®ä¿åªè¦ MutexGuard ç¦»å¼€ä½œç”¨åŸŸï¼Œé”å°±ä¼šè¢«é‡Šæ”¾ã€‚</p>
<p>MutexGuard ä¸å…è®¸ Sendï¼Œåªå…è®¸ Syncï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä½ å¯ä»¥æŠŠ MutexGuard çš„å¼•ç”¨ä¼ ç»™å¦ä¸€ä¸ªçº¿ç¨‹ä½¿ç”¨ï¼Œä½†ä½ æ— æ³•æŠŠ MutexGuard æ•´ä¸ªç§»åŠ¨åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ã€‚è¿™æ ·å¯ä»¥é¿å…å› åŠ é”å’Œè§£é”åœ¨ä¸åŒçš„çº¿ç¨‹ä¸‹å¸¦æ¥çš„æ­»é”é£é™©ã€‚</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::borrow::Cow;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

fn main() {
    // ç”¨ Arc æ¥æä¾›å¹¶å‘ç¯å¢ƒä¸‹çš„å…±äº«æ‰€æœ‰æƒï¼ˆä½¿ç”¨å¼•ç”¨è®¡æ•°ï¼‰
    let metrics: Arc&lt;Mutex&lt;HashMap&lt;Cow&lt;'static, str&gt;, usize&gt;&gt;&gt; =
        Arc::new(Mutex::new(HashMap::new()));
    for _ in 0..32 {
        let m = metrics.clone();
        thread::spawn(move || {
            let mut g = m.lock().unwrap();
            // æ­¤æ—¶åªæœ‰æ‹¿åˆ° MutexGuard çš„çº¿ç¨‹å¯ä»¥è®¿é—® HashMap
            let data = &amp;mut *g;
            // Cow å®ç°äº†å¾ˆå¤šæ•°æ®ç»“æ„çš„ From traitï¼Œ
            // æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨ &quot;hello&quot;.into() ç”Ÿæˆ Cow
            let entry = data.entry(&quot;hello&quot;.into()).or_insert(0);
            *entry += 1;
            // MutexGuard è¢« Dropï¼Œé”è¢«é‡Šæ”¾
        });
    }

    thread::sleep(Duration::from_millis(100));

    println!(&quot;metrics: {:?}&quot;, metrics.lock().unwrap());
}</code></pre></pre>
<h2 id="å†…å­˜åˆ†é…å™¨"><a class="header" href="#å†…å­˜åˆ†é…å™¨">å†…å­˜åˆ†é…å™¨</a></h2>
<h3 id="æ›¿æ¢é»˜è®¤çš„å†…å­˜åˆ†é…å™¨"><a class="header" href="#æ›¿æ¢é»˜è®¤çš„å†…å­˜åˆ†é…å™¨">æ›¿æ¢é»˜è®¤çš„å†…å­˜åˆ†é…å™¨</a></h3>
<p>å †ä¸Šåˆ†é…å†…å­˜çš„ <code>Box&lt;T&gt;</code> æœ‰ä¸€ä¸ªç¼ºçœçš„æ³›å‹å‚æ•° <code>A</code>ï¼Œéœ€è¦æ»¡è¶³ <code>Allocator</code>ï¼Œå¹¶ä¸”é»˜è®¤æ˜¯ <code>Global</code>ï¼Œè¿™ä¸ª <code>Global</code> å°±æ˜¯é»˜è®¤çš„å†…å­˜åˆ†é…å™¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust edition2021">use jemallocator::Jemalloc;

#[global_allocator]
static GLOBAL: Jemalloc = Jemalloc;

fn main() {}</code></pre></pre>
<h3 id="è‡ªå®šä¹‰å†…å­˜åˆ†é…å™¨"><a class="header" href="#è‡ªå®šä¹‰å†…å­˜åˆ†é…å™¨">è‡ªå®šä¹‰å†…å­˜åˆ†é…å™¨</a></h3>
<p>å¦‚æœæƒ³è¦ç¼–å†™ä¸€ä¸ªå…¨å±€åˆ†é…å™¨ï¼Œå¯ä»¥å®ç° <code>GlobalAlloc</code> traitï¼Œå®ƒå’Œ <code>Allocator</code> trait çš„ä¸»è¦åŒºåˆ«åœ¨äºæ˜¯å¦å…è®¸åˆ†é…é•¿åº¦ä¸º0çš„å†…å­˜ã€‚</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::alloc::{GlobalAlloc, Layout, System};

struct MyAllocator;

unsafe impl GlobalAlloc for MyAllocator {
    unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8 {
        let data = System.alloc(layout);
        // è¿™é‡Œä¸èƒ½ä½¿ç”¨ println!()
        // stdout ä¼šæ‰“å°åˆ°ä¸€ä¸ªç”± Mutex äº’æ–¥é”ä¿æŠ¤çš„å…±äº«å…¨å±€ buffer ä¸­ï¼Œè¿™ä¸ªè¿‡ç¨‹ä¸­ä¼šæ¶‰åŠå†…å­˜çš„åˆ†é…
        // åˆ†é…çš„å†…å­˜åˆä¼šè§¦å‘ println!()ï¼Œæœ€ç»ˆé€ æˆç¨‹åºå´©æºƒ
        // eprintln! ç›´æ¥æ‰“å°åˆ° stderrï¼Œä¸ä¼š buffer
        eprintln!(&quot;ALLOC: {:p}, size {}&quot;, data, layout.size());
        data
    }

    unsafe fn dealloc(&amp;self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout);
        eprintln!(&quot;FREE: {:p}, size {}&quot;, ptr, layout.size());
    }
}

#[global_allocator]
static GLOBAL: MyAllocator = MyAllocator;

#[allow(dead_code)]
struct Matrix {
    // ä½¿ç”¨ä¸è§„åˆ™çš„æ•°å­—å¦‚ 505 å¯ä»¥è®© dbg! çš„æ‰“å°å¾ˆå®¹æ˜“åˆ†è¾¨å‡ºæ¥
    data: [u8; 505],
}

impl Default for Matrix {
    fn default() -&gt; Self {
        Self { data: [0; 505] }
    }
}

fn main() {
    // åœ¨è¿™å¥æ‰§è¡Œä¹‹å‰å·²ç»æœ‰å¥½å¤šå†…å­˜åˆ†é…
    let data = Box::new(Matrix::default());

    // è¾“å‡ºä¸­æœ‰ä¸€ä¸ª 1024 å¤§å°çš„å†…å­˜åˆ†é…ï¼Œæ˜¯ println! å¯¼è‡´çš„
    println!(
        &quot;!!! allocated memory: {:p}, len: {}&quot;,
        &amp;*data,
        std::mem::size_of::&lt;Matrix&gt;()
    );

    // data åœ¨è¿™é‡Œ dropï¼Œå¯ä»¥åœ¨æ‰“å°ä¸­çœ‹åˆ° FREE
    // ä¹‹åè¿˜æœ‰å¾ˆå¤šå…¶å®ƒå†…å­˜è¢«é‡Šæ”¾
}</code></pre></pre>
<p>Standard Error ä¸­è¾“å‡ºçš„ç»“æœå¦‚ä¸‹ï¼š</p>
<pre><code class="language-plain">ALLOC: 0x55c63eb5b940, size 5
ALLOC: 0x55c63eb5b960, size 48
ALLOC: 0x55c63eb5b9d0, size 505
ALLOC: 0x55c63eb5b500, size 1024
FREE: 0x55c63eb5b9d0, size 505
FREE: 0x55c63eb5b500, size 1024
FREE: 0x55c63eb5b940, size 5
FREE: 0x55c63eb5b960, size 48
</code></pre>
<h2 id="åˆ‡ç‰‡"><a class="header" href="#åˆ‡ç‰‡">åˆ‡ç‰‡</a></h2>
<blockquote>
<p>å½“æˆ‘ä»¬æ„å»ºè‡ªå·±çš„æ•°æ®ç»“æ„æ—¶ï¼Œå¦‚æœå®ƒå†…éƒ¨ä¹Ÿæœ‰è¿ç»­æ’åˆ—çš„ç­‰é•¿çš„æ•°æ®ç»“æ„ï¼Œå¯ä»¥è€ƒè™‘ AsRef æˆ–è€… Deref åˆ°åˆ‡ç‰‡ã€‚</p>
</blockquote>
<p>åˆ‡ç‰‡æ˜¯æè¿°ä¸€ç»„å±äºåŒä¸€ç±»å‹ã€é•¿åº¦ä¸ç¡®å®šçš„ã€åœ¨å†…å­˜ä¸­è¿ç»­å­˜æ”¾çš„æ•°æ®ç»“æ„ï¼Œç”¨ [T] æ¥è¡¨è¿°ã€‚å› ä¸ºé•¿åº¦ä¸ç¡®å®šï¼Œæ‰€ä»¥åˆ‡ç‰‡æ˜¯ä¸ª DSTï¼ˆDynamically Sized Typeï¼‰ã€‚åœ¨ä½¿ç”¨ä¸­ä¸»è¦ç”¨ä»¥ä¸‹å½¢å¼ï¼š</p>
<ul>
<li>&amp;[T]ï¼šè¡¨ç¤ºä¸€ä¸ªåªè¯»çš„åˆ‡ç‰‡å¼•ç”¨</li>
<li>&amp;mut [T]ï¼šè¡¨ç¤ºä¸€ä¸ªå¯å†™çš„åˆ‡ç‰‡å¼•ç”¨</li>
<li>Box&lt;[T]&gt;ï¼šä¸€ä¸ªåœ¨å †ä¸Šåˆ†é…çš„åˆ‡ç‰‡ã€‚</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let arr = [1, 2, 3, 4, 5];
    let vec = vec![1, 2, 3, 4, 5];
    let s1 = &amp;arr[..2];
    let s2 = &amp;vec[..2];
    println!(&quot;s1: {:?}, s2: {:?}&quot;, s1, s2);

    // &amp;[T] å’Œ &amp;[T] æ˜¯å¦ç›¸ç­‰å–å†³äºé•¿åº¦å’Œå†…å®¹æ˜¯å¦ç›¸ç­‰
    assert_eq!(s1, s2);
    // &amp;[T] å¯ä»¥å’Œ Vec&lt;T&gt;/[T;n] æ¯”è¾ƒï¼Œä¹Ÿä¼šçœ‹é•¿åº¦å’Œå†…å®¹
    // è¿™æ˜¯å› ä¸ºå®ƒä»¬ä¹‹é—´å®ç°äº† PartialEq trait
    assert_eq!(&amp;arr[..], vec);
    assert_eq!(&amp;vec[..], arr);
}</code></pre></pre>
<p>åœ¨ä½¿ç”¨çš„æ—¶å€™ï¼Œæ”¯æŒåˆ‡ç‰‡çš„å…·ä½“æ•°æ®ç±»å‹ï¼Œå¯ä»¥æ ¹æ®éœ€è¦ï¼Œè§£å¼•ç”¨è½¬æ¢æˆåˆ‡ç‰‡ç±»å‹ã€‚æ¯”å¦‚ Vec å’Œ [T; n] ä¼šè½¬åŒ–æˆä¸º &amp;[T]ï¼Œè¿™æ˜¯å› ä¸º Vec å®ç°äº† Deref traitï¼Œè€Œ array å†…å»ºäº†åˆ° &amp;[T] çš„è§£å¼•ç”¨ã€‚è¿™ä¹Ÿå°±æ„å‘³ç€ï¼Œé€šè¿‡è§£å¼•ç”¨ï¼Œè¿™å‡ ä¸ªå’Œåˆ‡ç‰‡æœ‰å…³çš„æ•°æ®ç»“æ„éƒ½ä¼šè·å¾—åˆ‡ç‰‡çš„æ‰€æœ‰èƒ½åŠ›ï¼ŒåŒ…æ‹¬ï¼š<code>binary_search</code>ã€<code>chunks</code>ã€<code>concat</code>ã€<code>contains</code>ã€<code>start_with</code>ã€<code>end_with</code>ã€<code>group_by</code>ã€<code>iter</code>ã€<code>join</code>ã€<code>sort</code>ã€<code>split</code>ã€<code>swap</code> ç­‰ä¸€ç³»åˆ—ä¸°å¯Œçš„åŠŸèƒ½ã€‚</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fmt;
fn main() {
    let v = vec![1, 2, 3, 4];

    // Vec å®ç°äº† Derefï¼Œ&amp;Vec&lt;T&gt; ä¼šè¢«è‡ªåŠ¨è§£å¼•ç”¨ä¸º &amp;[T]ï¼Œç¬¦åˆæ¥å£å®šä¹‰
    print_slice(&amp;v);
    // ç›´æ¥æ˜¯ &amp;[T]ï¼Œç¬¦åˆæ¥å£å®šä¹‰
    print_slice(&amp;v[..]);

    // &amp;Vec&lt;T&gt; æ”¯æŒ AsRef&lt;[T]&gt;
    print_slice1(&amp;v);
    // &amp;[T] æ”¯æŒ AsRef&lt;[T]&gt;
    print_slice1(&amp;v[..]);
    // Vec&lt;T&gt; ä¹Ÿæ”¯æŒ AsRef&lt;[T]&gt;
    print_slice1(v);

    let arr = [1, 2, 3, 4];
    // æ•°ç»„è™½æ²¡æœ‰å®ç° Derefï¼Œä½†å®ƒçš„è§£å¼•ç”¨å°±æ˜¯ &amp;[T]
    print_slice(&amp;arr);
    print_slice(&amp;arr[..]);
    print_slice1(&amp;arr);
    print_slice1(&amp;arr[..]);
    print_slice1(arr);
}

fn print_slice&lt;T: fmt::Debug&gt;(s: &amp;[T]) {
    println!(&quot;{:?}&quot;, s);
}

fn print_slice1&lt;T, U&gt;(s: T)
where
    T: AsRef&lt;[U]&gt;,
    U: fmt::Debug,
{
    println!(&quot;{:?}&quot;, s.as_ref());
}</code></pre></pre>
<h3 id="å°†-slice-è½¬åŒ–æˆè¿­ä»£å™¨"><a class="header" href="#å°†-slice-è½¬åŒ–æˆè¿­ä»£å™¨">å°† slice è½¬åŒ–æˆè¿­ä»£å™¨</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // è¿™é‡Œ Vec åœ¨è°ƒç”¨ iter() æ—¶è¢«è§£å¼•ç”¨æˆ &amp;[T]ï¼Œæ‰€ä»¥å¯ä»¥è®¿é—® iter()
    let result: Vec&lt;i32&gt; = vec![1, 2, 3, 4]
        .iter()
        .map(|v| v * v)
        .filter(|v| *v &lt; 16)
        .collect();

    println!(&quot;{:?}&quot;, result);
}</code></pre></pre>
<p>Rust ä¸‹çš„è¿­ä»£å™¨æ˜¯ä¸ª<code>æ‡’æ¥å£ï¼ˆlazy interfaceï¼‰</code>ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™æ®µä»£ç ç›´åˆ°è¿è¡Œåˆ° <code>collect</code> æ—¶æ‰çœŸæ­£å¼€å§‹æ‰§è¡Œï¼Œä¹‹å‰çš„éƒ¨åˆ†ä¸è¿‡æ˜¯åœ¨ä¸æ–­åœ°ç”Ÿæˆæ–°çš„ç»“æ„ï¼Œæ¥ç´¯ç§¯å¤„ç†é€»è¾‘è€Œå·²ã€‚Rust å¤§é‡ä½¿ç”¨äº† inline ç­‰ä¼˜åŒ–æŠ€å·§ï¼Œä½¿å¾—è¿­ä»£å™¨çš„æ€§èƒ½å’Œ C è¯­è¨€çš„ for å¾ªç¯å·®åˆ«ä¸å¤§ã€‚</p>
<p>æ­¤å¤–ï¼Œ<code>itertools</code> crate è¿˜æä¾›äº†é¢å¤–çš„ï¼Œæ ‡å‡†åº“ä¸­æ²¡æœ‰æä¾›çš„è¿­ä»£å™¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust edition2021">use itertools::Itertools;

fn main() {
    let err_str = &quot;bad happened&quot;;
    let input = vec![Ok(21), Err(err_str), Ok(7)];
    let it = input
        .into_iter()
        // å¯¹æˆåŠŸçš„ç»“æœè¿›ä¸€æ­¥åš filter/map æ“ä½œ
        .filter_map_ok(|i| if i &gt; 10 { Some(i * 2) } else { None });
    // ç»“æœåº”è¯¥æ˜¯ï¼švec![Ok(42), Err(err_str)]
    println!(&quot;{:?}&quot;, it.collect::&lt;Vec&lt;_&gt;&gt;());
}</code></pre></pre>
<h3 id="ç‰¹æ®Šçš„åˆ‡ç‰‡-str"><a class="header" href="#ç‰¹æ®Šçš„åˆ‡ç‰‡-str">ç‰¹æ®Šçš„åˆ‡ç‰‡ &amp;str</a></h3>
<p><img src="../images/rust/string-slice-vs-vector-slice.webp" alt="å­—ç¬¦åˆ—è¡¨å’Œå­—ç¬¦ä¸²çš„åŒºåˆ«" /></p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::iter::FromIterator;

fn main() {
    let arr = ['h', 'e', 'l', 'l', 'o'];
    let vec = vec!['h', 'e', 'l', 'l', 'o'];
    let s = String::from(&quot;hello&quot;);
    let s1 = &amp;arr[1..3];
    let s2 = &amp;vec[1..3];
    // &amp;str æœ¬èº«å°±æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ slice
    let s3 = &amp;s[1..3];
    println!(&quot;s1: {:?}, s2: {:?}, s3: {:?}&quot;, s1, s2, s3);

    // &amp;[char] å’Œ &amp;[char] æ˜¯å¦ç›¸ç­‰å–å†³äºé•¿åº¦å’Œå†…å®¹æ˜¯å¦ç›¸ç­‰
    assert_eq!(s1, s2);
    // &amp;[char] å’Œ &amp;str ä¸èƒ½ç›´æ¥å¯¹æ¯”ï¼Œæˆ‘ä»¬æŠŠ s3 å˜æˆ Vec&lt;char&gt;
    assert_eq!(s2, s3.chars().collect::&lt;Vec&lt;_&gt;&gt;());
    // &amp;[char] å¯ä»¥é€šè¿‡è¿­ä»£å™¨è½¬æ¢æˆ Stringï¼ŒString å’Œ &amp;str å¯ä»¥ç›´æ¥å¯¹æ¯”
    assert_eq!(String::from_iter(s2), s3);
}</code></pre></pre>
<p>å­—ç¬¦åˆ—è¡¨å¯ä»¥é€šè¿‡è¿­ä»£å™¨è½¬æ¢æˆ Stringï¼ŒString ä¹Ÿå¯ä»¥é€šè¿‡ chars() å‡½æ•°è½¬æ¢æˆå­—ç¬¦åˆ—è¡¨ï¼Œå¦‚æœä¸è½¬æ¢ï¼ŒäºŒè€…ä¸èƒ½æ¯”è¾ƒã€‚</p>
<h3 id="boxt-å †ä¸Šçš„åˆ‡ç‰‡"><a class="header" href="#boxt-å †ä¸Šçš„åˆ‡ç‰‡">Box&lt;[T]&gt; å †ä¸Šçš„åˆ‡ç‰‡</a></h3>
<p><code>Box&lt;[T]&gt;</code> å’Œåˆ‡ç‰‡çš„å¼•ç”¨ <code>&amp;[T]</code> å¾ˆç±»ä¼¼ï¼šå®ƒä»¬éƒ½æ˜¯åœ¨æ ˆä¸Šæœ‰ä¸€ä¸ªåŒ…å«é•¿åº¦çš„èƒ–æŒ‡é’ˆï¼ŒæŒ‡å‘å­˜å‚¨æ•°æ®çš„å†…å­˜ä½ç½®ã€‚åŒºåˆ«æ˜¯ï¼š<code>Box&lt;[T]&gt;</code> åªä¼šæŒ‡å‘å †ï¼Œ<code>&amp;[T]</code> æŒ‡å‘çš„ä½ç½®å¯ä»¥æ˜¯æ ˆä¹Ÿå¯ä»¥æ˜¯å †ï¼›æ­¤å¤–ï¼Œ<code>Box&lt;[T]&gt;</code> å¯¹æ•°æ®å…·æœ‰æ‰€æœ‰æƒï¼Œè€Œ <code>&amp;[T]</code> åªæ˜¯ä¸€ä¸ªå€Ÿç”¨ã€‚</p>
<p><code>Box&lt;[T]&gt;</code> å’Œ <code>Vec&lt;T&gt;</code> æœ‰ä¸€ç‚¹ç‚¹å·®åˆ«ï¼š<code>Vec&lt;T&gt;</code> æœ‰é¢å¤–çš„ capacityï¼Œå¯ä»¥å¢é•¿ï¼›è€Œ <code>Box&lt;[T]&gt;</code> ä¸€æ—¦ç”Ÿæˆå°±å›ºå®šä¸‹æ¥ï¼Œæ²¡æœ‰ capacityï¼Œä¹Ÿæ— æ³•å¢é•¿ã€‚</p>
<p><img src="../images/rust/slice-on-heap.webp" alt="å †ä¸Šçš„åˆ‡ç‰‡" /></p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::ops::Deref;

fn main() {
    let mut v1 = vec![1, 2, 3, 4];
    v1.push(5);
    println!(&quot;cap should be 8: {}&quot;, v1.capacity());

    // ä» Vec&lt;T&gt; è½¬æ¢æˆ Box&lt;[T]&gt;ï¼Œæ­¤æ—¶ä¼šä¸¢å¼ƒå¤šä½™çš„ capacity
    let b1 = v1.into_boxed_slice();
    let mut b2 = b1.clone();

    let v2 = b1.into_vec();
    println!(&quot;cap should be exactly 5: {}&quot;, v2.capacity());

    assert!(b2.deref() == v2);

    // Box&lt;[T]&gt; å¯ä»¥æ›´æ”¹å…¶å†…éƒ¨æ•°æ®ï¼Œä½†æ— æ³• push
    b2[0] = 2;
    // b2.push(6);
    println!(&quot;b2: {:?}&quot;, b2);

    // æ³¨æ„ Box&lt;[T]&gt; å’Œ Box&lt;[T; n]&gt; å¹¶ä¸ç›¸åŒ
    let b3 = Box::new([2, 2, 3, 4, 5]);
    println!(&quot;b3: {:?}&quot;, b3);

    // b2 å’Œ b3 ç›¸ç­‰ï¼Œä½† b3.deref() å’Œ v2 æ— æ³•æ¯”è¾ƒ
    assert!(b2 == b3);
    // assert!(b3.deref() == v2);
}</code></pre></pre>
<p><code>Vec&lt;T&gt;</code> å¯ä»¥é€šè¿‡ i<code>nto_boxed_slice()</code> è½¬æ¢æˆ <code>Box&lt;[T]&gt;</code>ï¼Œ<code>Box&lt;[T]&gt;</code> ä¹Ÿå¯ä»¥é€šè¿‡ <code>into_vec()</code> è½¬æ¢å› <code>Vec&lt;T&gt;</code>ã€‚</p>
<p><code>Box&lt;[T]&gt;</code> æœ‰ä¸€ä¸ªå¾ˆå¥½çš„ç‰¹æ€§æ˜¯ï¼Œä¸åƒ <code>Box&lt;[T;n]&gt;</code> é‚£æ ·åœ¨ç¼–è¯‘æ—¶å°±è¦ç¡®å®šå¤§å°ï¼Œå®ƒå¯ä»¥åœ¨è¿è¡ŒæœŸç”Ÿæˆï¼Œä»¥åå¤§å°ä¸ä¼šå†æ”¹å˜ã€‚</p>
<h2 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h2>
<p>Rust å“ˆå¸Œè¡¨ä¸æ˜¯ç”¨å†²çªé“¾æ¥è§£å†³å“ˆå¸Œå†²çªï¼Œè€Œæ˜¯ç”¨å¼€æ”¾å¯»å€æ³•çš„äºŒæ¬¡æ¢æŸ¥æ¥è§£å†³çš„ã€‚</p>
<p>å¦‚æœåªéœ€è¦ç®€å•ç¡®è®¤å…ƒç´ æ˜¯å¦åœ¨é›†åˆä¸­ï¼Œå¯ä»¥ç”¨ HashSetï¼Œå®ƒå°±æ˜¯ç®€åŒ–çš„ HashMapï¼Œå¯ä»¥ç”¨æ¥å­˜æ”¾æ— åºçš„é›†åˆã€‚</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use hashbrown::hash_map as base;

// RandomState ä½¿ç”¨ SipHash ä½œä¸ºç¼ºçœçš„å“ˆå¸Œç®—æ³•
#[derive(Clone)]
pub struct RandomState {
    k0: u64,
    k1: u64,
}

pub struct HashMap&lt;K, V, S = RandomState&gt; {
    // å¤ç”¨äº† hashbrown åº“çš„ HashMap
    base: base::HashMap&lt;K, V, S&gt;,
}

// hashbrown åº“çš„ HashMap
pub struct HashMap&lt;K, V, S = DefaultHashBuilder, A: Allocator + Clone = Global&gt; {
    pub(crate) hash_builder: S,
    pub(crate) table: RawTable&lt;(K, V), A&gt;,
}

pub struct RawTable&lt;T, A: Allocator + Clone = Global&gt; {
    table: RawTableInner&lt;A&gt;,

    // Tell dropck that we own instances of T.
    marker: PhantomData&lt;T&gt;,
}

struct RawTableInner&lt;A&gt; {
    bucket_mask: usize,

    // [Padding], T1, T2, ..., Tlast, C1, C2, ...
    //                                ^ points here
    // æŒ‡å‘å“ˆå¸Œè¡¨å †å†…å­˜æœ«ç«¯çš„ ctrl åŒº
    ctrl: NonNull&lt;u8&gt;,

    // å“ˆå¸Œè¡¨åœ¨ä¸‹æ¬¡è‡ªåŠ¨å¢é•¿å‰è¿˜èƒ½å­˜å‚¨å¤šå°‘æ•°æ®
    // éšç€å“ˆå¸Œè¡¨ä¸æ–­æ’å…¥æ•°æ®ï¼Œå®ƒä¼šä»¥ 2 çš„å¹‚å‡ä¸€çš„æ–¹å¼å¢é•¿
    growth_left: usize,

    // å“ˆå¸Œè¡¨ç°åœ¨æœ‰å¤šå°‘æ•°æ®
    items: usize,
    alloc: A,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="è‡ªå®šä¹‰æ•°æ®ç»“æ„åš-hash-key"><a class="header" href="#è‡ªå®šä¹‰æ•°æ®ç»“æ„åš-hash-key">è‡ªå®šä¹‰æ•°æ®ç»“æ„åš Hash key</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">use std::{
    collections::{hash_map::DefaultHasher, HashMap},
    hash::{Hash, Hasher},
};

// å¦‚æœè¦æ”¯æŒ Hashï¼Œå¯ä»¥ç”¨ #[derive(Hash)]ï¼Œå‰ææ˜¯æ¯ä¸ªå­—æ®µéƒ½å®ç°äº† Hash
// å¦‚æœè¦èƒ½ä½œä¸º HashMap çš„ keyï¼Œè¿˜éœ€è¦ PartialEq å’Œ Eq
#[derive(Debug, Hash, PartialEq, Eq)]
struct Student&lt;'a&gt; {
    name: &amp;'a str,
    age: u8,
}

impl&lt;'a&gt; Student&lt;'a&gt; {
    pub fn new(name: &amp;'a str, age: u8) -&gt; Self {
        Self { name, age }
    }
}

fn main() {
    let mut hasher = DefaultHasher::new();
    let student = Student::new(&quot;Tyr&quot;, 18);
    // å®ç°äº† Hash çš„æ•°æ®ç»“æ„å¯ä»¥ç›´æ¥è°ƒç”¨ hash æ–¹æ³•
    student.hash(&amp;mut hasher);
    let mut map = HashMap::new();
    // å®ç°äº† Hash / PartialEq / Eq çš„æ•°æ®ç»“æ„å¯ä»¥ä½œä¸º HashMap çš„ key
    map.insert(student, vec![&quot;Math&quot;, &quot;Writing&quot;]);
    println!(&quot;hash: 0x{:x}, map: {:?}&quot;, hasher.finish(), map);
}</code></pre></pre>
<h2 id="btreemap"><a class="header" href="#btreemap">BTreeMap</a></h2>
<p>BTreeMap æ˜¯å†…éƒ¨ä½¿ç”¨ B-tree æ¥ç»„ç»‡å“ˆå¸Œè¡¨çš„æ•°æ®ç»“æ„ï¼Œå’Œ HashMap ä¸åŒçš„æ˜¯ï¼ŒBTreeMap æ˜¯æœ‰åºçš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::BTreeMap;

fn main() {
    let map = BTreeMap::new();
    let mut map = explain(&quot;empty&quot;, map);

    for i in 0..16usize {
        map.insert(format!(&quot;Tyr {}&quot;, i), i);
    }

    let mut map = explain(&quot;added&quot;, map);

    map.remove(&quot;Tyr 1&quot;);

    let map = explain(&quot;remove 1&quot;, map);

    for item in map.iter() {
        println!(&quot;{:?}&quot;, item);
    }
}

// BTreeMap ç»“æ„æœ‰ heightï¼Œnode å’Œ length
// æˆ‘ä»¬ transmute æ‰“å°ä¹‹åï¼Œå† transmute å›å»
fn explain&lt;K, V&gt;(name: &amp;str, map: BTreeMap&lt;K, V&gt;) -&gt; BTreeMap&lt;K, V&gt; {
    let arr: [usize; 3] = unsafe { std::mem::transmute(map) };
    println!(
        &quot;{}: height: {}, root node: 0x{:x}, len: 0x{:x}&quot;,
        name, arr[0], arr[1], arr[2]
    );
    unsafe { std::mem::transmute(arr) }
}</code></pre></pre>
<p>å¦‚æœæƒ³è‡ªå®šä¹‰çš„æ•°æ®ç»“æ„å¯ä»¥ä½œä¸º BTreeMap çš„ keyï¼Œé‚£ä¹ˆéœ€è¦å®ç° PartialOrd å’Œ Ordã€‚</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::BTreeMap;

#[derive(Debug, PartialOrd, Ord, PartialEq, Eq)]
struct Name {
    pub name: String,
    pub flags: u32,
}

impl Name {
    pub fn new(name: impl AsRef&lt;str&gt;, flags: u32) -&gt; Self {
        Self {
            name: name.as_ref().to_string(),
            flags,
        }
    }
}

fn main() {
    let mut map = BTreeMap::new();
    map.insert(Name::new(&quot;/etc/password&quot;, 0x1), 12);
    map.insert(Name::new(&quot;/etc/hosts&quot;, 0x1), 4);
    map.insert(Name::new(&quot;/home/tchen&quot;, 0x0), 28);

    for item in map.iter() {
        println!(&quot;{:?}&quot;, item);
    }
}</code></pre></pre>
<h2 id="é”™è¯¯å¤„ç†"><a class="header" href="#é”™è¯¯å¤„ç†">é”™è¯¯å¤„ç†</a></h2>
<h3 id="-æ“ä½œç¬¦"><a class="header" href="#-æ“ä½œç¬¦"><code>?</code> æ“ä½œç¬¦</a></h3>
<p>? æ“ä½œç¬¦å†…éƒ¨è¢«å±•å¼€æˆç±»ä¼¼è¿™æ ·çš„ä»£ç ï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match result {
    Ok(v) =&gt; v,
    Err(e) =&gt; return Err(e.into())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="å‡½æ•°å¼é”™è¯¯å¤„ç†"><a class="header" href="#å‡½æ•°å¼é”™è¯¯å¤„ç†">å‡½æ•°å¼é”™è¯¯å¤„ç†</a></h3>
<p><img src="../images/rust/functional-error-handling.webp" alt="å‡½æ•°å¼é”™è¯¯å¤„ç†" /></p>
<h3 id="cache_unwind"><a class="header" href="#cache_unwind">cache_unwind</a></h3>
<p>Rust æ ‡å‡†åº“æä¾›äº†<code>catch_unwind()</code>å‡½æ•°ï¼Œèƒ½å¤Ÿåƒå¼‚å¸¸å¤„ç†é‚£æ ·å°†è°ƒç”¨æ ˆå›æº¯åˆ° catch_unwind è¿™ä¸€åˆ»ï¼Œä½œç”¨å’Œå…¶å®ƒè¯­è¨€çš„ try {â€¦} catch {â€¦} ä¸€æ ·ã€‚</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::panic;

fn main() {
    let result = panic::catch_unwind(|| {
        println!(&quot;hello!&quot;);
    });
    assert!(result.is_ok());
    let result = panic::catch_unwind(|| {
        panic!(&quot;oh no!&quot;);
    });
    assert!(result.is_err());
    println!(&quot;panic captured: {:#?}&quot;, result);
}</code></pre></pre>
<h3 id="error-trait"><a class="header" href="#error-trait"><code>Error</code> trait</a></h3>
<p>ä¸ºäº†è§„èŒƒä»£è¡¨é”™è¯¯çš„æ•°æ®ç±»å‹çš„è¡Œä¸ºï¼ŒRust å®šä¹‰äº† Error traitï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Error: Debug + Display {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; { ... }
    fn backtrace(&amp;self) -&gt; Option&lt;&amp;Backtrace&gt; { ... }
    fn description(&amp;self) -&gt; &amp;str { ... }
    fn cause(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt; { ... }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://github.com/dtolnay/thiserror">thiserror</a> å¯ä»¥å¸®åŠ©ç®€åŒ–é”™è¯¯ç±»å‹çš„å®šä¹‰ã€‚</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thiserror::Error;
#[derive(Error, Debug)]
#[non_exhaustive]
pub enum DataStoreError {
    #[error(&quot;data store disconnected&quot;)]
    Disconnect(#[from] io::Error),
    #[error(&quot;the data for key `{0}` is not available&quot;)]
    Redaction(String),
    #[error(&quot;invalid header (expected {expected:?}, found {found:?})&quot;)]
    InvalidHeader {
        expected: String,
        found: String,
    },
    #[error(&quot;unknown data store error&quot;)]
    Unknown,
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://github.com/dtolnay/anyhow">anyhow</a> å®ç°äº† <code>anyhow::Error</code> å’Œä»»æ„ç¬¦åˆ Error trait çš„é”™è¯¯ç±»å‹ä¹‹é—´çš„è½¬æ¢ï¼Œè®©ä½ å¯ä»¥ä½¿ç”¨ <code>?</code> æ“ä½œç¬¦ï¼Œä¸å¿…å†æ‰‹å·¥è½¬æ¢é”™è¯¯ç±»å‹ã€‚</p>
<h2 id="é—­åŒ…"><a class="header" href="#é—­åŒ…">é—­åŒ…</a></h2>
<p>é—­åŒ…æ˜¯ä¸€ç§åŒ¿åç±»å‹ï¼Œä¸€æ—¦å£°æ˜ï¼Œå°±ä¼šäº§ç”Ÿä¸€ä¸ªæ–°çš„ç±»å‹ï¼Œä½†è¿™ä¸ªç±»å‹æ— æ³•è¢«å…¶å®ƒåœ°æ–¹ä½¿ç”¨ã€‚è¿™ä¸ªç±»å‹å°±åƒä¸€ä¸ªç»“æ„ä½“ï¼Œä¼šåŒ…å«æ‰€æœ‰æ•è·çš„å˜é‡ã€‚é—­åŒ…æ˜¯å­˜å‚¨åœ¨<strong>æ ˆ</strong>ä¸Šï¼Œå¹¶ä¸”é™¤äº†æ•è·çš„æ•°æ®å¤–ï¼Œé—­åŒ…æœ¬èº«ä¸åŒ…å«ä»»ä½•é¢å¤–å‡½æ•°æŒ‡é’ˆæŒ‡å‘é—­åŒ…çš„ä»£ç ã€‚</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{collections::HashMap, mem::size_of_val};

// é•¿åº¦ä¸º 0
let c1 = || println!(&quot;hello world!&quot;);
// å’Œå‚æ•°æ— å…³ï¼Œé•¿åº¦ä¹Ÿä¸º 0
let c2 = |i: i32| println!(&quot;hello: {}&quot;, i);
let name = String::from(&quot;tyr&quot;);
let name1 = name.clone();
let mut table = HashMap::new();
table.insert(&quot;hello&quot;, &quot;world&quot;);
// å¦‚æœæ•è·ä¸€ä¸ªå¼•ç”¨ï¼Œé•¿åº¦ä¸º 8
let c3 = || println!(&quot;hello: {}&quot;, name);
// æ•è·ç§»åŠ¨çš„æ•°æ® name1(é•¿åº¦ 24) + table(é•¿åº¦ 48)ï¼Œå› æ­¤ closure é•¿åº¦ 72
let c4 = move || println!(&quot;hello: {}, {:?}&quot;, name1, table);
let name2 = name.clone();
// å’Œå±€éƒ¨å˜é‡æ— å…³ï¼Œæ•è·äº†ä¸€ä¸ª String name2ï¼Œå› æ­¤ closure é•¿åº¦ 24
let c5 = move || {
    let x = 1;
    let name3 = String::from(&quot;lindsey&quot;);
    println!(&quot;hello: {}, {:?}, {:?}&quot;, x, name2, name3);
};

println!(
    &quot;c1: {}, c2: {}, c3: {}, c4: {}, c5: {}, main: {}&quot;,
    size_of_val(&amp;c1),
    size_of_val(&amp;c2),
    size_of_val(&amp;c3),
    size_of_val(&amp;c4),
    size_of_val(&amp;c5),
    size_of_val(&amp;main),
);
<span class="boring">}</span></code></pre></pre>
<p><strong>ä¸å¸¦ move æ—¶ï¼Œé—­åŒ…æ•è·çš„æ˜¯å¯¹åº”è‡ªç”±å˜é‡çš„å¼•ç”¨ï¼›å¸¦ move æ—¶ï¼Œå¯¹åº”è‡ªç”±å˜é‡çš„æ‰€æœ‰æƒä¼šè¢«ç§»åŠ¨åˆ°é—­åŒ…ç»“æ„ä¸­</strong>ã€‚</p>
<h3 id="é—­åŒ…çš„ç±»å‹"><a class="header" href="#é—­åŒ…çš„ç±»å‹">é—­åŒ…çš„ç±»å‹</a></h3>
<p><img src="../images/rust/closure-trait.webp" alt="é—­åŒ…çš„ç±»å‹" /></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FnOnce&lt;Args&gt; {
    type Output;
    // ä¼šè½¬ç§» self çš„æ‰€æœ‰æƒåˆ° call_once å‡½æ•°ä¸­
    extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ä¸€ä¸ª FnMut é—­åŒ…ï¼Œå¯ä»¥è¢«ä¼ ç»™ä¸€ä¸ªéœ€è¦ FnOnce çš„ä¸Šä¸‹æ–‡ï¼Œæ­¤æ—¶è°ƒç”¨é—­åŒ…ç›¸å½“äºè°ƒç”¨äº† call_once()
pub trait FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call_mut(
        &amp;mut self,
        args: Args
    ) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ä»»ä½•éœ€è¦ FnOnce æˆ–è€… FnMut çš„åœºåˆï¼Œéƒ½å¯ä»¥ä¼ å…¥æ»¡è¶³ Fn çš„é—­åŒ…
pub trait Fn&lt;Args&gt;: FnMut&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call(&amp;self, args: Args) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="å°†é—­åŒ…ä½œä¸ºå‚æ•°ä¼ é€’"><a class="header" href="#å°†é—­åŒ…ä½œä¸ºå‚æ•°ä¼ é€’">å°†é—­åŒ…ä½œä¸ºå‚æ•°ä¼ é€’</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let v = vec![0u8; 1024];
    let v1 = vec![0u8; 1023];

    // Fnï¼Œä¸ç§»åŠ¨æ‰€æœ‰æƒ
    let mut c = |x: u64| v.len() as u64 * x;
    // Fnï¼Œç§»åŠ¨æ‰€æœ‰æƒ
    let mut c1 = move |x: u64| v1.len() as u64 * x;

    println!(&quot;direct call: {}&quot;, c(2));
    println!(&quot;direct call: {}&quot;, c1(2));

    println!(&quot;call: {}&quot;, call(3, &amp;c));
    println!(&quot;call: {}&quot;, call(3, &amp;c1));

    println!(&quot;call_mut: {}&quot;, call_mut(4, &amp;mut c));
    println!(&quot;call_mut: {}&quot;, call_mut(4, &amp;mut c1));

    println!(&quot;call_once: {}&quot;, call_once(5, c));
    println!(&quot;call_once: {}&quot;, call_once(5, c1));
}

fn call(arg: u64, c: &amp;impl Fn(u64) -&gt; u64) -&gt; u64 {
    c(arg)
}

fn call_mut(arg: u64, c: &amp;mut impl FnMut(u64) -&gt; u64) -&gt; u64 {
    c(arg)
}

fn call_once(arg: u64, c: impl FnOnce(u64) -&gt; u64) -&gt; u64 {
    c(arg)
}</code></pre></pre>
<h3 id="è¿”å›é—­åŒ…"><a class="header" href="#è¿”å›é—­åŒ…">è¿”å›é—­åŒ…</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">use std::ops::Mul;

fn main() {
    let c1 = curry(5);
    println!(&quot;5 multiply 2 is: {}&quot;, c1(2));

    let adder2 = curry(3.14);
    println!(&quot;pi multiply 4^2 is: {}&quot;, adder2(4. * 4.));
}

fn curry&lt;T&gt;(x: T) -&gt; impl Fn(T) -&gt; T
where
    T: Mul&lt;Output = T&gt; + Copy,
{
    move |y| x * y
}</code></pre></pre>
<h3 id="ç»™é—­åŒ…å®ç°å…¶ä»–-trait"><a class="header" href="#ç»™é—­åŒ…å®ç°å…¶ä»–-trait">ç»™é—­åŒ…å®ç°å…¶ä»– trait</a></h3>
<p>æœ‰äº›æ¥å£æ—¢å¯ä»¥ä¼ å…¥ä¸€ä¸ªç»“æ„ä½“ï¼Œåˆå¯ä»¥ä¼ å…¥ä¸€ä¸ªå‡½æ•°æˆ–è€…é—­åŒ…ã€‚</p>
<pre><pre class="playground"><code class="language-rust edition2021">pub trait Executor {
    fn execute(&amp;self, cmd: &amp;str) -&gt; Result&lt;String, &amp;'static str&gt;;
}

struct BashExecutor {
    env: String,
}

impl Executor for BashExecutor {
    fn execute(&amp;self, cmd: &amp;str) -&gt; Result&lt;String, &amp;'static str&gt; {
        Ok(format!(
            &quot;fake bash execute: env: {}, cmd: {}&quot;,
            self.env, cmd
        ))
    }
}

impl&lt;T&gt; Executor for T
where
    T: Fn(&amp;str) -&gt; Result&lt;String, &amp;'static str&gt;,
{
    fn execute(&amp;self, cmd: &amp;str) -&gt; Result&lt;String, &amp;'static str&gt; {
        self(cmd)
    }
}

fn main() {
    let env = &quot;PATH=/usr/bin&quot;.to_string();

    let cmd = &quot;cat /etc/passwd&quot;;
    let r1 = execute(cmd, BashExecutor { env: env.clone() });
    println!(&quot;{:?}&quot;, r1);

    let r2 = execute(cmd, |cmd: &amp;str| {
        Ok(format!(&quot;fake fish execute: env: {}, cmd: {}&quot;, env, cmd))
    });
    println!(&quot;{:?}&quot;, r2);
}

fn execute(cmd: &amp;str, exec: impl Executor) -&gt; Result&lt;String, &amp;'static str&gt; {
    exec.execute(cmd)
}</code></pre></pre>
<h2 id="å‚è€ƒèµ„æ–™"><a class="header" href="#å‚è€ƒèµ„æ–™">å‚è€ƒèµ„æ–™</a></h2>
<ul>
<li><a href="https://cheats.rs/">cheats.rs</a></li>
<li><a href="https://lldb.llvm.org/use/map.html">GDB/LLDB å‘½ä»¤æ‰‹å†Œ</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../cs/openwrt.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../ee/control-system.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../cs/openwrt.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../ee/control-system.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>

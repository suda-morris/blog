<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RISC-V - 🐏 suda-morris 个人博客 🐇</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Personal Blog">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../about-me.html">关于我</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">体系结构</li><li class="chapter-item expanded "><a href="../cs/riscv.html" class="active"><strong aria-hidden="true">1.</strong> RISC-V</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">编译系统</li><li class="chapter-item expanded "><a href="../cs/gcc-toolchains.html"><strong aria-hidden="true">2.</strong> GCC</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">操作系统</li><li class="chapter-item expanded "><a href="../cs/openwrt.html"><strong aria-hidden="true">3.</strong> OpenWRT</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">控制系统</li><li class="chapter-item expanded "><a href="../ee/control-system.html"><strong aria-hidden="true">4.</strong> 控制系统基础</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">测试框架</li><li class="chapter-item expanded "><a href="../cs/pytest.html"><strong aria-hidden="true">5.</strong> pytest</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">多媒体</li><li class="chapter-item expanded "><a href="../cs/video-process.html"><strong aria-hidden="true">6.</strong> 视频处理</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">通信协议</li><li class="chapter-item expanded "><a href="../ee/usb.html"><strong aria-hidden="true">7.</strong> USB 协议基础</a></li><li class="chapter-item expanded "><a href="../ee/can.html"><strong aria-hidden="true">8.</strong> CAN 协议基础</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">电路设计</li><li class="chapter-item expanded "><a href="../ee/yosys.html"><strong aria-hidden="true">9.</strong> Yosys</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">前端</li><li class="chapter-item expanded "><a href="../cs/tauri.html"><strong aria-hidden="true">10.</strong> Tauri</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">管理</li><li class="chapter-item expanded "><a href="../cs/git.html"><strong aria-hidden="true">11.</strong> git</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">演示</li><li class="chapter-item expanded "><a href="../ux/slides-tool.html"><strong aria-hidden="true">12.</strong> slides 工具</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">🐏 suda-morris 个人博客 🐇</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/suda-morris/blog" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/suda-morris/blog/edit/master/src/cs/riscv.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="risc-v-基础"><a class="header" href="#risc-v-基础">RISC-V 基础</a></h1>
<h2 id="指令集划分"><a class="header" href="#指令集划分">指令集划分</a></h2>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>类别</th><th>说明</th></tr></thead><tbody>
<tr><td>RV32I</td><td>基础指令</td><td>整数指令，包含算术、分支、逻辑、访存指令，有32个32位寄存器，能寻址32位地址空间</td></tr>
<tr><td>RV32E</td><td>基础指令</td><td>与RV32I一样，只不过只能使用前16个32位寄存器</td></tr>
<tr><td>RV64I</td><td>基础指令</td><td>整数指令，包含算术、分支、逻辑、访存指令，有32个64位寄存器，能寻址64位地址空间</td></tr>
<tr><td>RV128I</td><td>基础指令</td><td>整数指令，包含算术、分支、逻辑、访存指令，有32个128位寄存器，能寻址128位地址空间</td></tr>
<tr><td>M</td><td>扩展指令</td><td>包含乘法、除法、求模取余指令</td></tr>
<tr><td>F</td><td>扩展指令</td><td>单精度(32bit)浮点指令</td></tr>
<tr><td>D</td><td>扩展指令</td><td>双精度(32bit)浮点指令,必须要同时支持F扩展指令</td></tr>
<tr><td>Q</td><td>扩展指令</td><td>四倍精度浮点指令</td></tr>
<tr><td>A</td><td>扩展指令</td><td>存储器原子操作指令，比如比较并交换，读-改-写等指令</td></tr>
<tr><td>C</td><td>扩展指令</td><td>压缩指令,指令长度为16位，主要用于改善程序大小</td></tr>
<tr><td>P</td><td>扩展指令</td><td>单指令多数据（Packed-SIMD)指令</td></tr>
<tr><td>B</td><td>扩展指令</td><td>位操作指令</td></tr>
<tr><td>H</td><td>扩展指令</td><td>支持 Hypervisor 管理指令</td></tr>
<tr><td>J</td><td>扩展指令</td><td>动态翻译语言的指令</td></tr>
<tr><td>L</td><td>扩展指令</td><td>十进制浮点指令</td></tr>
<tr><td>N</td><td>扩展指令</td><td>用户中断指令</td></tr>
<tr><td>G</td><td>通用指令</td><td>包含 I、M、A、F、D指令</td></tr>
</tbody></table>
</div>
<h3 id="rv32i-基础指令集"><a class="header" href="#rv32i-基础指令集">RV32I 基础指令集</a></h3>
<p><img src="../images/risc-v/rv32i.png" alt="RV32I" /></p>
<h3 id="rv32i-通用寄存器"><a class="header" href="#rv32i-通用寄存器">RV32I 通用寄存器</a></h3>
<div class="table-wrapper"><table><thead><tr><th>寄存器</th><th>ABI 名字</th><th>描述</th><th>Saver</th></tr></thead><tbody>
<tr><td>x0</td><td>zero</td><td>0值寄存器，硬编码为0,写入数据忽略，读取永远为0</td><td>-</td></tr>
<tr><td>x1</td><td>ra</td><td>返回地址</td><td>Caller</td></tr>
<tr><td>x2</td><td>sp</td><td>栈指针</td><td>Callee</td></tr>
<tr><td>x3</td><td>gp</td><td>全局指针</td><td>-</td></tr>
<tr><td>x4</td><td>tp</td><td>线程指针</td><td>-</td></tr>
<tr><td>x5</td><td>t0</td><td>临时寄存器或者备用的链接寄存器</td><td>Caller</td></tr>
<tr><td>x6-x7</td><td>t1-t2</td><td>临时寄存器</td><td>Caller</td></tr>
<tr><td>x8</td><td>s0/fp</td><td>需要保存的寄存器或者帧指针寄存器</td><td>Callee</td></tr>
<tr><td>x9</td><td>s1</td><td>需要保存的寄存器，保存原进程中的关键数据，避免在函数调用过程中被破坏</td><td>Callee</td></tr>
<tr><td>x10-x11</td><td>a0-a1</td><td>函数参数/返回值</td><td>Caller</td></tr>
<tr><td>x12-x17</td><td>a2-a7</td><td>函数参数</td><td>Caller</td></tr>
<tr><td>x18-x27</td><td>s2-s11</td><td>需要保存的寄存器</td><td>Callee</td></tr>
<tr><td>x28-x31</td><td>t3-t6</td><td>临时寄存器</td><td>Caller</td></tr>
</tbody></table>
</div>
<h4 id="函数调用时保留的寄存器"><a class="header" href="#函数调用时保留的寄存器">函数调用时保留的寄存器</a></h4>
<p>被调用函数一般不会使用这些寄存器，即便使用也会提前保存好原值，可以信任。这些寄存器有：sp, gp, tp 和 s0-s11 寄存器。</p>
<h4 id="函数调用时不保存的寄存器"><a class="header" href="#函数调用时不保存的寄存器">函数调用时不保存的寄存器</a></h4>
<p>有可能被调用函数使用更改，需要caller在调用前对自己用到的寄存器进行保存。这些寄存器有：参数与返回地址寄存器 a0-a7，返回地址寄存器 ra，临时寄存器 t0-t6</p>
<h2 id="rv32i-基础指令格式"><a class="header" href="#rv32i-基础指令格式">RV32I 基础指令格式</a></h2>
<p><img src="../images/risc-v/rv32i_instruction_format.webp" alt="RV32I 指令编码格式" /></p>
<ul>
<li>源寄存器和目标寄存器都设计固定在所有 RISC-V 指令同样的位置上，指令译码相对简单，所以指令在 CPU 流水线中执行时，可以先开始访问寄存器，然后再完成指令解码。</li>
<li>所有立即数的<strong>符号位</strong>总是在指令的<strong>最高位</strong>。这么做的好处是，有可能成为关键路径的<strong>立即数符号扩展</strong>可以在指令解码前进行，有利于 CPU 流水线的时序优化。</li>
</ul>
<h3 id="寄存器-寄存器的算术指令"><a class="header" href="#寄存器-寄存器的算术指令">寄存器-寄存器的算术指令</a></h3>
<p><img src="../images/risc-v/rv32i_instruction_arithmetic_reg2reg.webp" alt="RV32I 寄存器-寄存器的算术指令" /></p>
<h4 id="指令汇编格式"><a class="header" href="#指令汇编格式">指令汇编格式</a></h4>
<h5 id="加法"><a class="header" href="#加法">加法</a></h5>
<pre><code class="language-assembly">add rd, rs1, rs2
</code></pre>
<h5 id="减法"><a class="header" href="#减法">减法</a></h5>
<pre><code class="language-assembly">sub rd, rs1, rs2
</code></pre>
<h5 id="逻辑与"><a class="header" href="#逻辑与">逻辑与</a></h5>
<pre><code class="language-assembly">and rd, rs1, rs2
</code></pre>
<h5 id="逻辑或"><a class="header" href="#逻辑或">逻辑或</a></h5>
<pre><code class="language-assembly">or rd, rs1, rs2
</code></pre>
<h5 id="逻辑异或"><a class="header" href="#逻辑异或">逻辑异或</a></h5>
<pre><code class="language-assembly">xor rd, rs1, rs2
</code></pre>
<h5 id="有符号小于比较"><a class="header" href="#有符号小于比较">有符号小于比较</a></h5>
<pre><code class="language-assembly">slt rd, rs1, rs2
</code></pre>
<h5 id="无符号小于比较"><a class="header" href="#无符号小于比较">无符号小于比较</a></h5>
<pre><code class="language-assembly">sltu rd, rs1, rs2
</code></pre>
<h5 id="逻辑左移"><a class="header" href="#逻辑左移">逻辑左移</a></h5>
<pre><code class="language-assembly">sll rd, rs1, rs2
</code></pre>
<h5 id="逻辑右移"><a class="header" href="#逻辑右移">逻辑右移</a></h5>
<pre><code class="language-assembly">srl rd, rs1, rs2
</code></pre>
<h5 id="算数右移"><a class="header" href="#算数右移">算数右移</a></h5>
<pre><code class="language-assembly">sra rd, rs1, rs2
</code></pre>
<h3 id="立即数的算术指令"><a class="header" href="#立即数的算术指令">立即数的算术指令</a></h3>
<p><img src="../images/risc-v/rv32i_instruction_arithmetic_immediate.webp" alt="RV32I 立即数的算术指令" /></p>
<blockquote>
<p>注意，在立即数算术指令中，没有减法运算。</p>
</blockquote>
<h4 id="指令汇编格式-1"><a class="header" href="#指令汇编格式-1">指令汇编格式</a></h4>
<h5 id="立即数加法"><a class="header" href="#立即数加法">立即数加法</a></h5>
<pre><code class="language-assembly">addi rd, rs1, imm[11:0]
</code></pre>
<h5 id="立即数逻辑与"><a class="header" href="#立即数逻辑与">立即数逻辑与</a></h5>
<pre><code class="language-assembly">andi rd, rs1, imm[11:0]
</code></pre>
<h5 id="立即数逻辑或"><a class="header" href="#立即数逻辑或">立即数逻辑或</a></h5>
<pre><code class="language-assembly">ori rd, rs1, imm[11:0]
</code></pre>
<h5 id="立即数逻辑异或"><a class="header" href="#立即数逻辑异或">立即数逻辑异或</a></h5>
<pre><code class="language-assembly">xori rd, rs1, imm[11:0]
</code></pre>
<h5 id="立即数有符号小于比较"><a class="header" href="#立即数有符号小于比较">立即数有符号小于比较</a></h5>
<pre><code class="language-assembly">slti rd, rs1, imm[11:0]
</code></pre>
<h5 id="立即数无符号小于比较"><a class="header" href="#立即数无符号小于比较">立即数无符号小于比较</a></h5>
<pre><code class="language-assembly">sltiu rd, rs1, imm[11:0]
</code></pre>
<h5 id="立即数逻辑左移"><a class="header" href="#立即数逻辑左移">立即数逻辑左移</a></h5>
<pre><code class="language-assembly">slli rd, rs1, shamt[4:0]
</code></pre>
<h5 id="立即数逻辑右移"><a class="header" href="#立即数逻辑右移">立即数逻辑右移</a></h5>
<pre><code class="language-assembly">srli rd, rs1, shamt[4:0]
</code></pre>
<h5 id="立即数算数右移"><a class="header" href="#立即数算数右移">立即数算数右移</a></h5>
<pre><code class="language-assembly">srai rd, rs1, shamt[4:0]
</code></pre>
<h3 id="loadstore-指令"><a class="header" href="#loadstore-指令">Load/Store 指令</a></h3>
<p><img src="../images/risc-v/rv32i_instruction_load_store.webp" alt="RV32I Load/Store 指令" /></p>
<p>Load 和 Store 的寻址模式只能是符号扩展 12 位的立即数，加上基地址寄存器得到访问的存储器地址。因为没有了复杂的内存寻址方式，这让 CPU 流水线可以对数据冲突提前做出判断，并通过流水线各级之间的转送加以处理，而不需要插入空操作（NOP），极大提高了代码的执行效率。</p>
<blockquote>
<p>注意，Load指令属于 <strong>I</strong> 型指令，而 Store 指令属于 <strong>S</strong> 型指令。</p>
</blockquote>
<h4 id="指令汇编格式-2"><a class="header" href="#指令汇编格式-2">指令汇编格式</a></h4>
<h5 id="字加载"><a class="header" href="#字加载">字加载</a></h5>
<pre><code class="language-assembly">lw rd, offset[11:0](rs1)
</code></pre>
<h5 id="半字加载"><a class="header" href="#半字加载">半字加载</a></h5>
<pre><code class="language-assembly">lh rd, offset[11:0](rs1)
</code></pre>
<h5 id="无符号半字加载"><a class="header" href="#无符号半字加载">无符号半字加载</a></h5>
<pre><code class="language-assembly">lhu rd, offset[11:0](rs1)
</code></pre>
<h5 id="字节加载"><a class="header" href="#字节加载">字节加载</a></h5>
<pre><code class="language-assembly">lb rd, offset[11:0](rs1)
</code></pre>
<h5 id="无符号字节加载"><a class="header" href="#无符号字节加载">无符号字节加载</a></h5>
<pre><code class="language-assembly">lbu rd, offset[11:0](rs1)
</code></pre>
<h5 id="字存储"><a class="header" href="#字存储">字存储</a></h5>
<pre><code class="language-assembly">sw rs2, offset[11:0](rs1)
</code></pre>
<h5 id="半字存储"><a class="header" href="#半字存储">半字存储</a></h5>
<pre><code class="language-assembly">sh rs2, offset[11:0](rs1)
</code></pre>
<h5 id="字节存储"><a class="header" href="#字节存储">字节存储</a></h5>
<pre><code class="language-assembly">sb rs2, offset[11:0](rs1)
</code></pre>
<h3 id="有条件分支跳转指令"><a class="header" href="#有条件分支跳转指令">有条件分支跳转指令</a></h3>
<p><img src="../images/risc-v/rv32i_instruction_branch_condition.webp" alt="有条件分支跳转指令" /></p>
<h4 id="指令汇编格式-3"><a class="header" href="#指令汇编格式-3">指令汇编格式</a></h4>
<h5 id="相等跳转"><a class="header" href="#相等跳转">相等跳转</a></h5>
<pre><code class="language-assembly">beq rs1, rs2, label
</code></pre>
<h5 id="不等跳转"><a class="header" href="#不等跳转">不等跳转</a></h5>
<pre><code class="language-assembly">bne rs1, rs2, label
</code></pre>
<h5 id="小于跳转"><a class="header" href="#小于跳转">小于跳转</a></h5>
<pre><code class="language-assembly">blt rs1, rs2, label
</code></pre>
<h5 id="无符号小于跳转"><a class="header" href="#无符号小于跳转">无符号小于跳转</a></h5>
<pre><code class="language-assembly">bltu rs1, rs2, label
</code></pre>
<h5 id="大于等于跳转"><a class="header" href="#大于等于跳转">大于等于跳转</a></h5>
<pre><code class="language-assembly">bge rs1, rs2, label
</code></pre>
<h5 id="无符号大于等于跳转"><a class="header" href="#无符号大于等于跳转">无符号大于等于跳转</a></h5>
<pre><code class="language-assembly">bgeu rs1, rs2, label
</code></pre>
<h3 id="无条件跳转指令"><a class="header" href="#无条件跳转指令">无条件跳转指令</a></h3>
<blockquote>
<p>注意，直接跳转是 <strong>J</strong> 型指令，而相对跳转是 <strong>I</strong> 型指令。</p>
</blockquote>
<h4 id="直接跳转指令"><a class="header" href="#直接跳转指令">直接跳转指令</a></h4>
<p><img src="../images/risc-v/rv32i_instruction_branch_direct.webp" alt="无条件直接跳转" /></p>
<p>JAL 指令的执行过程：</p>
<ol>
<li>首先，把 20 位的立即数做符号扩展，并左移一位，产生一个 32 位的符号数</li>
<li>然后，将该 32 位符号数和 PC 相加来产生目标地址（这样 JAL 可以作为短跳转指令，跳转至 PC±1MB 的地址范围内）</li>
<li>同时，JAL 会把紧随其后的那条指令的地址，存入目标寄存器中。这样，如果目标寄存器是0,则 JAL 就等同于 goto 指令；如果目标寄存器不为零，JAL 可以实现函数调用的功能</li>
</ol>
<h4 id="相对跳转指令"><a class="header" href="#相对跳转指令">相对跳转指令</a></h4>
<p><img src="../images/risc-v/rv32i_instruction_branch_relative.webp" alt="无条件相对跳转" /></p>
<p>JALR 指令会把 12 位立即数和源寄存器相加，并把相加的结果末位清零，作为新的跳转地址。和 JAL 指令一样，JALR 也会把紧随其后的那条指令的地址，存入目标寄存器中。</p>
<h4 id="指令汇编格式-4"><a class="header" href="#指令汇编格式-4">指令汇编格式</a></h4>
<h5 id="无条件直接跳转"><a class="header" href="#无条件直接跳转">无条件直接跳转</a></h5>
<pre><code class="language-assembly">jal rd, label # 将 PC+4 的值保存到 rd 寄存器中，然后设置 PC = PC + offset
</code></pre>
<p>伪指令 <code>j</code> 实际上就是jal指令的变体，此时 rd 会被设置为 x0,表示丢弃返回地址</p>
<h5 id="无条件相对跳转"><a class="header" href="#无条件相对跳转">无条件相对跳转</a></h5>
<pre><code class="language-assembly">jalr rd, rs1, imm # 将 PC+4 保存到 rd 寄存器中，然后设置 PC = rs1  + imm
</code></pre>
<p>跳转到任意 32 位绝对地址处</p>
<pre><code class="language-assembly">lui x1, &lt;hi20bits&gt;
jalr ra, x1, &lt;lo12bits&gt;
</code></pre>
<p>相对PC地址32位偏移量的相对跳转</p>
<pre><code class="language-assembly">auipc x1, &lt;hi20bits&gt;
jalr x0, x1, &lt;lo12bits&gt;
</code></pre>
<h3 id="uupper-immediate型指令"><a class="header" href="#uupper-immediate型指令">U(Upper immediate)型指令</a></h3>
<p><img src="../images/risc-v/riscv_U_instruction.png" alt="U型指令" /></p>
<h4 id="指令汇编格式-5"><a class="header" href="#指令汇编格式-5">指令汇编格式</a></h4>
<h5 id="lui-指令-load-upper-immediate"><a class="header" href="#lui-指令-load-upper-immediate">lui 指令 (Load Upper Immediate)</a></h5>
<pre><code class="language-assembly">lui rd, imm # 将 20 位的立即数左移12位，低 12 位补零，并写回寄存器 rd 中
</code></pre>
<p>配合 addi 指令（设置低 12 比特）可实现讲寄存器设置为任意 32 比特的立即数，例如：</p>
<pre><code class="language-assembly">lui x10, 0x87654     # x10 = 0x87654000
addi x10, x10, 0x321 # x10 = 0x87654321
</code></pre>
<p>但是，当这个 12 位的立即数为负数（即最高比特位是1）时，得到的结果是高 20 位减 1 再和低 12 位拼接，比如：</p>
<pre><code class="language-assembly">lui x10, 0xDEADB     # x10 = 0xDEADB000
addi x10, x10, 0xEEF # x10 = 0xDEADBEEF
</code></pre>
<p>解决这个问题的一种方法是，如果低 12 位的立即数的符号位是 1 ,那就预先给高 20 位的数加 1。<code>li</code> 伪指令可以替我们处理好这种特殊情况。</p>
<h5 id="auipc-指令-add-upper-immediate-to-pc"><a class="header" href="#auipc-指令-add-upper-immediate-to-pc">auipc 指令 (Add Upper Immediate to PC)</a></h5>
<pre><code class="language-assembly">auipc rd, imm # 将 20 位的立即数左移12位，低 12 位补零，将得到的 32 位数与 pc 的值相加，最后写回寄存器 rd 中
</code></pre>
<p>具体应用有：</p>
<pre><code class="language-assembly">Label: auipc x10, 0 # 将 Label 的地址保存在 x10 寄存器中
</code></pre>
<h3 id="指令编码空间的可扩展性"><a class="header" href="#指令编码空间的可扩展性">指令编码空间的可扩展性</a></h3>
<p><img src="../images/risc-v/riscv_isa_custom_instruction.png" alt="指令编码空间的扩展" /></p>
<ul>
<li>custom-0、custom-1 用于 RV32 的自定义指令集扩展</li>
<li>custom-2、custom-3 预留给 RV128，也可以用于 RV32、RV64 的用户自定义指令集扩展</li>
</ul>
<h2 id="csr-寄存器指令"><a class="header" href="#csr-寄存器指令">CSR 寄存器指令</a></h2>
<p>除了内存地址空间和通用寄存器地址空间外，RISC-V 中还定义了一个独立的控制与状态寄存器（CSR）地址空间。</p>
<h3 id="独立的-12-位地址编码空间"><a class="header" href="#独立的-12-位地址编码空间">独立的 12 位地址编码空间</a></h3>
<p><img src="../images/risc-v/csr_register_encoding.png" alt="CSR寄存器访问指令的编码" /></p>
<h3 id="专用的-csr-指令"><a class="header" href="#专用的-csr-指令">专用的 CSR 指令</a></h3>
<p><img src="../images/risc-v/rv32i_csr_instruction.webp" alt="CSR 指令" /></p>
<h2 id="其他指令"><a class="header" href="#其他指令">其他指令</a></h2>
<ul>
<li>系统调用 <code>ecall</code> 指令</li>
<li>调试时用于将控制转移到调试环境的 <code>ebreak</code> 指令</li>
</ul>
<h3 id="常用汇编伪指令"><a class="header" href="#常用汇编伪指令">常用汇编伪指令</a></h3>
<h5 id="赋值指令"><a class="header" href="#赋值指令">赋值指令</a></h5>
<pre><code class="language-assembly">mv rd, rs # 等效于 addi rd, rs, x0
</code></pre>
<h5 id="加载立即数"><a class="header" href="#加载立即数">加载立即数</a></h5>
<pre><code class="language-assembly">li rd, 13 # 等效于 addi rd, x0, 13
</code></pre>
<h5 id="函数调用和返回"><a class="header" href="#函数调用和返回">函数调用和返回</a></h5>
<pre><code class="language-assembly">jal my_foo # 函数调用
ret # 函数返回，等效于 jr ra，等效于 jalr x0, ra, 0
</code></pre>
<h2 id="单核-cpu-组成结构"><a class="header" href="#单核-cpu-组成结构">单核 CPU 组成结构</a></h2>
<p><img src="../images/risc-v/riscv_alu.png" alt="ALU" /></p>
<p><strong>数据通路</strong>是处理器中执行处理器所需操作的硬件部分，就像是处理器的四肢。</p>
<p><strong>控制器</strong>是对数据通路要做什么操作进行行为调度的硬件结构，就像是处理器的大脑。</p>
<h3 id="流水线技术"><a class="header" href="#流水线技术">流水线技术</a></h3>
<h4 id="五级流水线"><a class="header" href="#五级流水线">五级流水线</a></h4>
<p><img src="../images/risc-v/rv32i_5stage_pipelines.jpeg" alt="五级流水线" /></p>
<h4 id="流水线在不同阶段使用的资源"><a class="header" href="#流水线在不同阶段使用的资源">流水线在不同阶段使用的资源</a></h4>
<p><img src="../images/risc-v/riscv_pipeline_resource_usage.png" alt="流水线资源使用" /></p>
<blockquote>
<p>为了确保硬件共享的时候，前一阶段的数据不被丢失，需要在流水线之间插入“阶段寄存器”来保存中间值和控制信号。</p>
</blockquote>
<h3 id="数据通路"><a class="header" href="#数据通路">数据通路</a></h3>
<p><img src="../images/risc-v/riscv_data_path.png" alt="数据通路" /></p>
<ol>
<li>取指阶段（Instruction Fetch）：将指令从存储器中读取出来，PC 寄存器告诉当前指令在存储器中的位置。读取一条指令后，PC 寄存器会根据指令的长度自动递增，或者改写成指定的地址。</li>
<li>译码阶段（Instruction Decode）：将存储器中取出的指令进行翻译，识别出指令的类别以及所需的各种操作数。</li>
<li>执行阶段（Instruction Execute）：对指令进行真正的运算，期间最关键的模块是算术逻辑单元（ALU）。</li>
<li>访存阶段（Memory Access）：存储器访问指令将数据从存储器中读出，或写入存储器。</li>
<li>写回阶段（Write Back）：将指令执行的结果写回通用寄存器。</li>
</ol>
<h3 id="简易-cpu-内部组件框图"><a class="header" href="#简易-cpu-内部组件框图">简易 CPU 内部组件框图</a></h3>
<p><img src="../images/risc-v/rv32i_cpu_design.jpeg" alt="RV32I CPU 5级流水线设计框图" /></p>
<h3 id="pre_if-模块设计"><a class="header" href="#pre_if-模块设计">pre_if 模块设计</a></h3>
<p>根据当前的指令和 PC 寄存器，预测下一条指令的地址。为了实现程序分支跳转的功能，就需要设计一个<strong>预读取</strong>模块，不管指令是否跳转（这个结果会在指令执行阶段结束才能知道），都提前把跳转之后的下一条指令从存储器中读取出来，以备流水线的下一个阶段使用，这能提到 CPU 的执行效率。</p>
<pre><code class="language-verilog">module pre_if (
    input [31:0] instr,
    input [31:0] pc,

    output [31:0] pre_pc
);

    wire is_bxx = (instr[6:0] == `OPCODE_BRANCH); // 条件跳转指令的操作码
    wire is_jal = (instr[6:0] == `OPCODE_JAL) ;   // 无条件跳转指令的操作码

    // B型指令的立即数拼接
    wire [31:0] bimm  = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};
    // J型指令的立即数拼接
    wire [31:0] jimm  = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};

    // 指令地址的偏移量
    // 这里实际上做了一个简单的分支预测
    wire [31:0] adder = is_jal ? jimm : (is_bxx &amp; bimm[31]) ? bimm : 4;
    // 根据当前 PC 和指令的偏移量相加，得到预测的 PC 值
    assign pre_pc = pc + adder;

endmodule
</code></pre>
<h3 id="if_id-模块设计"><a class="header" href="#if_id-模块设计">if_id 模块设计</a></h3>
<p>预读取模块读出的指令并不是全部都能发送给后续的模块执行的，比如条件分支指令在执行后发现跳转条件不成立，这时预读取的指令就是无效的，需要对流水线进行冲刷（flush），把无效的指令都清除掉。</p>
<pre><code class="language-verilog">module if_id (
  input         clk,
  input         reset,
  input  [31:0] in_instr,
  input  [31:0] in_pc,
  input         flush,
  input         valid,
  output [31:0] out_instr,
  output [31:0] out_pc,
  output        out_noflush
);

  reg [31:0] reg_instr;
  reg [31:0] reg_pc;
  reg        reg_noflush;

  assign out_instr = reg_instr;
  assign out_pc = reg_pc;
  assign out_noflush = reg_noflush;

  //指令传递
  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_instr &lt;= 32'h0;
    end else if (flush) begin
      reg_instr &lt;= 32'h0;
    end else if (valid) begin
      reg_instr &lt;= in_instr;
    end
  end

  //PC值转递
  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_pc &lt;= 32'h0;
    end else if (flush) begin
      reg_pc &lt;= 32'h0;
    end else if (valid) begin
      reg_pc &lt;= in_pc;
    end
  end

  //流水线冲刷标志位
  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_noflush &lt;= 1'h0;
    end else if (flush) begin
      reg_noflush &lt;= 1'h0;
    end else if (valid) begin
      reg_noflush &lt;= 1'h1;
    end

  end

endmodule
</code></pre>
<h3 id="decode-模块设计"><a class="header" href="#decode-模块设计">decode 模块设计</a></h3>
<p>尽管指令格式不同，但是指令译码模块翻译指令的工作机制是<strong>统一</strong>的。首先会翻译出指令中携带的寄存器索引、立即数等信息，接着处理可能存在的数据冒险，再由译码数据通路负责把译码后的指令信息，发送给对应的执行单元去执行。</p>
<p>译码的过程：先识别指令的操作码（永远是低7位），根据操作码对应的代码标识，产生分支信号 branch、跳转信号 jump、读存储器信号 mem_read ......</p>
<pre><code class="language-verilog">module decode (
  input   [31:0] instr,

  output  [4:0] rs1_addr,
  output  [4:0] rs2_addr,
  output  [4:0] rd_addr,
  output  [2:0] funct3,
  output  [6:0] funct7,
  output        branch,
  output [1:0]  jump,
  output        mem_read,
  output        mem_write,
  output        reg_write,
  output        to_reg,
  output [1:0]  result_sel,
  output        alu_src,
  output        pc_add,
  output [6:0]  types,
  output [1:0]  alu_ctrlop,
  output        valid_inst,
  output [31:0] imm
);

localparam DEC_INVALID = 21'b0;

reg [20:0] dec_array;

//---------- decode rs1、rs2 -----------------
assign rs1_addr = instr[19:15];
assign rs2_addr = instr[24:20];

//---------- decode rd -----------------------
assign rd_addr = instr[11:7];

//---------- decode funct3、funct7 -----------
assign funct7 = instr[31:25];
assign funct3 = instr[14:12];

// ----------------------------- decode signals ---------------------------------

//                        20     19-18  17       16        15        14     13-12      11      10     9--------3  2---1      0
//                        branch jump   memRead  memWrite  regWrite  toReg  resultSel  aluSrc  pcAdd     RISBUJZ  aluctrlop  validInst
localparam DEC_LUI     = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b01,     1'b0,   1'b0,  7'b0000100, 2'b00,     1'b1};
localparam DEC_AUIPC   = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b1,   1'b1,  7'b0000100, 2'b00,     1'b1};
localparam DEC_JAL     = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b10,     1'b0,   1'b0,  7'b0000010, 2'b00,     1'b1};
localparam DEC_JALR    = {1'b0,  2'b11, 1'b0,    1'b0,     1'b1,     1'b0,  2'b10,     1'b1,   1'b0,  7'b0100000, 2'b00,     1'b1};
localparam DEC_BRANCH  = {1'b1,  2'b00, 1'b0,    1'b0,     1'b0,     1'b0,  2'b00,     1'b0,   1'b0,  7'b0001000, 2'b10,     1'b1};
localparam DEC_LOAD    = {1'b0,  2'b00, 1'b1,    1'b0,     1'b1,     1'b1,  2'b00,     1'b1,   1'b0,  7'b0100000, 2'b00,     1'b1};
localparam DEC_STORE   = {1'b0,  2'b00, 1'b0,    1'b1,     1'b0,     1'b0,  2'b00,     1'b1,   1'b0,  7'b0010000, 2'b00,     1'b1};
localparam DEC_ALUI    = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b1,   1'b0,  7'b0100000, 2'b01,     1'b1};
localparam DEC_ALUR    = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b0,   1'b0,  7'b1000000, 2'b01,     1'b1};

assign  {branch, jump, mem_read, mem_write, reg_write, to_reg, result_sel, alu_src, pc_add, types, alu_ctrlop, valid_inst} = dec_array;


always @(*) begin
  //$write(&quot;%x&quot;, instr);
  case(instr[6:0])
    `OPCODE_LUI    :   dec_array &lt;= DEC_LUI;
    `OPCODE_AUIPC  :   dec_array &lt;= DEC_AUIPC;
    `OPCODE_JAL    :   dec_array &lt;= DEC_JAL;
    `OPCODE_JALR   :   dec_array &lt;= DEC_JALR;
    `OPCODE_BRANCH :   dec_array &lt;= DEC_BRANCH;
    `OPCODE_LOAD   :   dec_array &lt;= DEC_LOAD;
    `OPCODE_STORE  :   dec_array &lt;= DEC_STORE;
    `OPCODE_ALUI   :   dec_array &lt;= DEC_ALUI;
    `OPCODE_ALUR   :   dec_array &lt;= DEC_ALUR;
    default        :  begin
                 dec_array &lt;= DEC_INVALID;
               //  $display(&quot;~~~decode error~~~%x&quot;, instr);
    end
  endcase
end

// -------------------- IMM -------------------------

wire [31:0] Iimm = {{21{instr[31]}}, instr[30:20]};
wire [31:0] Simm = {{21{instr[31]}}, instr[30:25], instr[11:7]};
wire [31:0] Bimm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};
wire [31:0] Uimm = {instr[31:12], 12'b0};
wire [31:0] Jimm = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};

assign imm = {32{types[5]}} &amp; Iimm
           | {32{types[4]}} &amp; Simm
           | {32{types[3]}} &amp; Bimm
           | {32{types[2]}} &amp; Uimm
           | {32{types[1]}} &amp; Jimm;

endmodule
</code></pre>
<p>前面译码模块得到的指令信号可以分为两大类，一类是指令的操作码经过译码后产生的<strong>指令控制信号</strong>，另一类是从指令源码中提取出来的<strong>数据信息</strong>，如立即数、寄存器索引、功能码等。为了能对流水线更好地实施控制，我们把译码后的数据和控制信号分开处理。</p>
<h3 id="译码控制模块"><a class="header" href="#译码控制模块">译码控制模块</a></h3>
<p>当指令发生冲突时，需要对流水线进行冲刷，译码阶段的指令信息也需要清除。</p>
<pre><code class="language-Verilog">module id_ex_ctrl (
  input        clk,
  input        reset,
  input        in_ex_ctrl_itype,
  input  [1:0] in_ex_ctrl_alu_ctrlop,
  input  [1:0] in_ex_ctrl_result_sel,
  input        in_ex_ctrl_alu_src,
  input        in_ex_ctrl_pc_add,
  input        in_ex_ctrl_branch,
  input  [1:0] in_ex_ctrl_jump,
  input        in_mem_ctrl_mem_read,
  input        in_mem_ctrl_mem_write,
  input  [1:0] in_mem_ctrl_mask_mode,
  input        in_mem_ctrl_sext,
  input        in_wb_ctrl_to_reg,
  input        in_wb_ctrl_reg_write,
  input        in_noflush,
  input        flush,
  input        valid,
  output       out_ex_ctrl_itype,
  output [1:0] out_ex_ctrl_alu_ctrlop,
  output [1:0] out_ex_ctrl_result_sel,
  output       out_ex_ctrl_alu_src,
  output       out_ex_ctrl_pc_add,
  output       out_ex_ctrl_branch,
  output [1:0] out_ex_ctrl_jump,
  output       out_mem_ctrl_mem_read,
  output       out_mem_ctrl_mem_write,
  output [1:0] out_mem_ctrl_mask_mode,
  output       out_mem_ctrl_sext,
  output       out_wb_ctrl_to_reg,
  output       out_wb_ctrl_reg_write,
  output       out_noflush
);

  reg  reg_ex_ctrl_itype;
  reg [1:0] reg_ex_ctrl_alu_ctrlop;
  reg [1:0] reg_ex_ctrl_result_sel;
  reg  reg_ex_ctrl_alu_src;
  reg  reg_ex_ctrl_pc_add;
  reg  reg_ex_ctrl_branch;
  reg [1:0] reg_ex_ctrl_jump;
  reg  reg_mem_ctrl_mem_read;
  reg  reg_mem_ctrl_mem_write;
  reg [1:0] reg_mem_ctrl_mask_mode;
  reg  reg_mem_ctrl_sext;
  reg  reg_wb_ctrl_to_reg;
  reg  reg_wb_ctrl_reg_write;
  reg  reg_noflush;

  assign out_ex_ctrl_itype = reg_ex_ctrl_itype;
  assign out_ex_ctrl_alu_ctrlop = reg_ex_ctrl_alu_ctrlop;
  assign out_ex_ctrl_result_sel = reg_ex_ctrl_result_sel;
  assign out_ex_ctrl_alu_src = reg_ex_ctrl_alu_src;
  assign out_ex_ctrl_pc_add = reg_ex_ctrl_pc_add;
  assign out_ex_ctrl_branch = reg_ex_ctrl_branch;
  assign out_ex_ctrl_jump = reg_ex_ctrl_jump;
  assign out_mem_ctrl_mem_read = reg_mem_ctrl_mem_read;
  assign out_mem_ctrl_mem_write = reg_mem_ctrl_mem_write;
  assign out_mem_ctrl_mask_mode = reg_mem_ctrl_mask_mode;
  assign out_mem_ctrl_sext = reg_mem_ctrl_sext;
  assign out_wb_ctrl_to_reg = reg_wb_ctrl_to_reg;
  assign out_wb_ctrl_reg_write = reg_wb_ctrl_reg_write;
  assign out_noflush = reg_noflush;

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_ex_ctrl_itype &lt;= 1'h0;
    end else if (flush) begin
      reg_ex_ctrl_itype &lt;= 1'h0;
    end else if (valid) begin
      reg_ex_ctrl_itype &lt;= in_ex_ctrl_itype;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_ex_ctrl_alu_ctrlop &lt;= 2'h0;
    end else if (flush) begin
      reg_ex_ctrl_alu_ctrlop &lt;= 2'h0;
    end else if (valid) begin
      reg_ex_ctrl_alu_ctrlop &lt;= in_ex_ctrl_alu_ctrlop;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_ex_ctrl_result_sel &lt;= 2'h0;
    end else if (flush) begin
      reg_ex_ctrl_result_sel &lt;= 2'h0;
    end else if (valid) begin
      reg_ex_ctrl_result_sel &lt;= in_ex_ctrl_result_sel;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_ex_ctrl_alu_src &lt;= 1'h0;
    end else if (flush) begin
      reg_ex_ctrl_alu_src &lt;= 1'h0;
    end else if (valid) begin
      reg_ex_ctrl_alu_src &lt;= in_ex_ctrl_alu_src;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_ex_ctrl_pc_add &lt;= 1'h0;
    end else if (flush) begin
      reg_ex_ctrl_pc_add &lt;= 1'h0;
    end else if (valid) begin
      reg_ex_ctrl_pc_add &lt;= in_ex_ctrl_pc_add;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_ex_ctrl_branch &lt;= 1'h0;
    end else if (flush) begin
      reg_ex_ctrl_branch &lt;= 1'h0;
    end else if (valid) begin
      reg_ex_ctrl_branch &lt;= in_ex_ctrl_branch;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_ex_ctrl_jump &lt;= 2'h0;
    end else if (flush) begin
      reg_ex_ctrl_jump &lt;= 2'h0;
    end else if (valid) begin
      reg_ex_ctrl_jump &lt;= in_ex_ctrl_jump;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_mem_ctrl_mem_read &lt;= 1'h0;
    end else if (flush) begin
      reg_mem_ctrl_mem_read &lt;= 1'h0;
    end else if (valid) begin
      reg_mem_ctrl_mem_read &lt;= in_mem_ctrl_mem_read;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_mem_ctrl_mem_write &lt;= 1'h0;
    end else if (flush) begin
      reg_mem_ctrl_mem_write &lt;= 1'h0;
    end else if (valid) begin
      reg_mem_ctrl_mem_write &lt;= in_mem_ctrl_mem_write;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_mem_ctrl_mask_mode &lt;= 2'h0;
    end else if (flush) begin
      reg_mem_ctrl_mask_mode &lt;= 2'h0;
    end else if (valid) begin
      reg_mem_ctrl_mask_mode &lt;= in_mem_ctrl_mask_mode;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_mem_ctrl_sext &lt;= 1'h0;
    end else if (flush) begin
      reg_mem_ctrl_sext &lt;= 1'h0;
    end else if (valid) begin
      reg_mem_ctrl_sext &lt;= in_mem_ctrl_sext;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_wb_ctrl_to_reg &lt;= 1'h0;
    end else if (flush) begin
      reg_wb_ctrl_to_reg &lt;= 1'h0;
    end else if (valid) begin
      reg_wb_ctrl_to_reg &lt;= in_wb_ctrl_to_reg;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_wb_ctrl_reg_write &lt;= 1'h0;
    end else if (flush) begin
      reg_wb_ctrl_reg_write &lt;= 1'h0;
    end else if (valid) begin
      reg_wb_ctrl_reg_write &lt;= in_wb_ctrl_reg_write;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_noflush &lt;= 1'h0;
    end else if (flush) begin
      reg_noflush &lt;= 1'h0;
    end else if (valid) begin
      reg_noflush &lt;= in_noflush;
    end
  end


endmodule
</code></pre>
<h3 id="译码数据通路模块"><a class="header" href="#译码数据通路模块">译码数据通路模块</a></h3>
<p>译码数据通路会根据 CPU 相关控制模块产生的流水线冲刷控制信号，决定要不要把这些数据发送给后续模块。</p>
<pre><code class="language-Verilog">module id_ex (
  input         clk,
  input         reset,
  input  [4:0]  in_rd_addr,
  input  [6:0]  in_funct7,
  input  [2:0]  in_funct3,
  input  [31:0] in_imm,
  input  [31:0] in_rs2_data,
  input  [31:0] in_rs1_data,
  input  [31:0] in_pc,
  input  [4:0]  in_rs1_addr,
  input  [4:0]  in_rs2_addr,
  input         flush,
  input         valid,
  output [4:0]  out_rd_addr,
  output [6:0]  out_funct7,
  output [2:0]  out_funct3,
  output [31:0] out_imm,
  output [31:0] out_rs2_data,
  output [31:0] out_rs1_data,
  output [31:0] out_pc,
  output [4:0]  out_rs1_addr,
  output [4:0]  out_rs2_addr
);
  reg [4:0] reg_rd_addr;
  reg [6:0] reg_funct7;
  reg [2:0] reg_funct3;
  reg [31:0] reg_imm;
  reg [31:0] reg_rs2_data;
  reg [31:0] reg_rs1_data;
  reg [31:0] reg_pc;
  reg [4:0] reg_rs1_addr;
  reg [4:0] reg_rs2_addr;

  assign out_rd_addr = reg_rd_addr;
  assign out_funct7 = reg_funct7;
  assign out_funct3 = reg_funct3;
  assign out_imm = reg_imm;
  assign out_rs2_data = reg_rs2_data;
  assign out_rs1_data = reg_rs1_data;
  assign out_pc = reg_pc;
  assign out_rs1_addr = reg_rs1_addr;
  assign out_rs2_addr = reg_rs2_addr;

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_rd_addr &lt;= 5'h0;
    end else if (flush) begin
      reg_rd_addr &lt;= 5'h0;
    end else if (valid) begin
      reg_rd_addr &lt;= in_rd_addr;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_funct7 &lt;= 7'h0;
    end else if (flush) begin
      reg_funct7 &lt;= 7'h0;
    end else if (valid) begin
      reg_funct7 &lt;= in_funct7;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_funct3 &lt;= 3'h0;
    end else if (flush) begin
      reg_funct3 &lt;= 3'h0;
    end else if (valid) begin
      reg_funct3 &lt;= in_funct3;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_imm &lt;= 32'h0;
    end else if (flush) begin
      reg_imm &lt;= 32'h0;
    end else if (valid) begin
      reg_imm &lt;= in_imm;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_rs2_data &lt;= 32'h0;
    end else if (flush) begin
      reg_rs2_data &lt;= 32'h0;
    end else if (valid) begin
      reg_rs2_data &lt;= in_rs2_data;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_rs1_data &lt;= 32'h0;
    end else if (flush) begin
      reg_rs1_data &lt;= 32'h0;
    end else if (valid) begin
      reg_rs1_data &lt;= in_rs1_data;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_pc &lt;= 32'h0;
    end else if (flush) begin
      reg_pc &lt;= 32'h0;
    end else if (valid) begin
      reg_pc &lt;= in_pc;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_rs1_addr &lt;= 5'h0;
    end else if (flush) begin
      reg_rs1_addr &lt;= 5'h0;
    end else if (valid) begin
      reg_rs1_addr &lt;= in_rs1_addr;
    end
  end

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_rs2_addr &lt;= 5'h0;
    end else if (flush) begin
      reg_rs2_addr &lt;= 5'h0;
    end else if (valid) begin
      reg_rs2_addr &lt;= in_rs2_addr;
    end
  end

endmodule
</code></pre>
<h3 id="执行控制模块"><a class="header" href="#执行控制模块">执行控制模块</a></h3>
<p>在指令执行阶段，存储访问指令用 ALU 进行地址计算，条件分支跳转指令用 ALU 进行条件比较，算术逻辑指令用 ALU 进行逻辑运算。</p>
<pre><code class="language-Verilog">module alu_ctrl (
    input [2:0]  funct3,
    input [6:0]  funct7,
    input [1:0]  aluCtrlOp,
    input        itype,
    output reg [3:0] aluOp
);
    always @(*) begin
      case(aluCtrlOp)
        2'b00:  aluOp &lt;= `ALU_OP_ADD;           // Load or Store
        2'b01:  begin
          if(itype &amp; funct3[1:0] != 2'b01)
            aluOp &lt;= {1'b0, funct3};
          else
            aluOp &lt;= {funct7[5], funct3};   // normal ALUI/ALUR
        end
        2'b10:  begin
         // $display(&quot;~~~aluCtrl bxx~~~%d&quot;, funct3);
          case(funct3)                    // bxx
            `BEQ_FUNCT3:  aluOp &lt;= `ALU_OP_EQ;
            `BNE_FUNCT3:  aluOp &lt;= `ALU_OP_NEQ;
            `BLT_FUNCT3:  aluOp &lt;= `ALU_OP_SLT;
            `BGE_FUNCT3:  aluOp &lt;= `ALU_OP_GE;
            `BLTU_FUNCT3: aluOp &lt;= `ALU_OP_SLTU;
            `BGEU_FUNCT3: aluOp &lt;= `ALU_OP_GEU;
            default:      aluOp &lt;= `ALU_OP_XXX;
          endcase
          end
        default: aluOp &lt;= `ALU_OP_XXX;
      endcase
    end
endmodule
</code></pre>
<h3 id="通用寄存器模块"><a class="header" href="#通用寄存器模块">通用寄存器模块</a></h3>
<pre><code class="language-Verilog">module gen_regs (
    input  clk,
    input  reset,
    input  wen,
    input  [4:0] regRAddr1, regRAddr2, regWAddr,
    input  [31:0] regWData,
    output [31:0] regRData1,
    output [31:0] regRData2
);
    integer ii;
    reg [31:0] regs[31:0];

    // write registers
    always @(posedge clk or posedge reset) begin
        if(reset) begin
            for(ii=0; ii&lt;32; ii=ii+1)
                regs[ii] &lt;= 32'b0;
        end
        else if(wen &amp; (|regWAddr))
                regs[regWAddr] &lt;= regWData;
    end

    // read registers
    assign regRData1 = wen &amp; (regWAddr == regRAddr1) ? regWData
                    : ((regRAddr1 != 5'b0) ? regs[regRAddr1] : 32'b0);
    assign regRData2 = wen &amp; (regWAddr == regRAddr2) ? regWData
                    : ((regRAddr2 != 5'b0) ? regs[regRAddr2] : 32'b0);

endmodule
</code></pre>
<p>写寄存器是边沿触发的，在一个时钟周期内写入的存储器数据，需要在写一个时钟周期才能把写入的数据读取出来。为了提高读写效率，在对同一个寄存器进行读写时，如果写使能 wen 有效，就直接把写入寄存器的数据送给读数据接口。</p>
<h3 id="alu-模块"><a class="header" href="#alu-模块">ALU 模块</a></h3>
<pre><code class="language-Verilog">module alu (
  input  [31:0] alu_data1_i,
  input  [31:0] alu_data2_i,
  input  [ 3:0] alu_op_i,
  output [31:0] alu_result_o
);

  reg  [31:0] result;

  // alu_op_i 的第3位和第1位为1时，做减法运算，这是为减法指令或者比较大小而准备的
  wire [31:0] sum    = alu_data1_i + ((alu_op_i[3] | alu_op_i[1]) ? -alu_data2_i : alu_data2_i);
  // 根据前面两个操作数相减的结果判断两个操作数是否相等
  wire        neq    = |sum;
  // 比较两个操作数的大小：
  // 如果操作数的符号位相同，则根据两个操作数相减的差值的符号位去判断
  // 如果操作数的符号位不同，先根据alu_op_i 的最低位判断是否是无符号数比较运算
  wire        cmp    = (alu_data1_i[31] == alu_data2_i[31]) ? sum[31]
                     : alu_op_i[0] ? alu_data2_i[31] : alu_data1_i[31];
  wire [ 4:0] shamt  = alu_data2_i[4:0];
  // 判断是左移还是右移，如果是左移，就先对源操作数做镜像处理
  wire [31:0] shin   = alu_op_i[2] ? alu_data1_i : reverse(alu_data1_i);
  // 判断是算术右移还是逻辑右移，如果是算术右移，需要在最高位补一个符号位
  wire [32:0] shift  = {alu_op_i[3] &amp; shin[31], shin};
  // $signed() 函数会在右移操作前先把操作数的符号位扩位成跟结果相同的位宽
  wire [32:0] shiftt = ($signed(shift) &gt;&gt;&gt; shamt);
  wire [31:0] shiftr = shiftt[31:0];
  // 左移的结果是右移后的结果再进行镜像处理
  wire [31:0] shiftl = reverse(shiftr);

  always @(*) begin
    case(alu_op_i)
      `ALU_OP_ADD:    result &lt;= sum;
      `ALU_OP_SUB:    result &lt;= sum;
      `ALU_OP_SLL:    result &lt;= shiftl;
      `ALU_OP_SLT:    result &lt;= cmp;
      `ALU_OP_SLTU:   result &lt;= cmp;
      `ALU_OP_XOR:    result &lt;= (alu_data1_i ^ alu_data2_i);
      `ALU_OP_SRL:    result &lt;= shiftr;
      `ALU_OP_SRA:    result &lt;= shiftr;
      `ALU_OP_OR:     result &lt;= (alu_data1_i | alu_data2_i);
      `ALU_OP_AND:    result &lt;= (alu_data1_i &amp; alu_data2_i);

      `ALU_OP_EQ:     result &lt;= {31'b0, ~neq};
      `ALU_OP_NEQ:    result &lt;= {31'b0, neq};
      `ALU_OP_GE:     result &lt;= {31'b0, ~cmp};
      `ALU_OP_GEU:    result &lt;= {31'b0, ~cmp};
      default:        begin
                      result &lt;= 32'b0;
                      //$display(&quot;*** alu error ! ***%x&quot;, alu_op_i);
        end
    endcase
  end

  function [31:0] reverse;
    input [31:0] in;
    integer i;
    for(i=0; i&lt;32; i=i+1) begin
      reverse[i] = in[31-i];
    end
  endfunction

  assign alu_result_o = result;

endmodule
</code></pre>
<ul>
<li>左移运算复用了右移运算的电路，方便实现</li>
</ul>
<h3 id="完整的数据通路"><a class="header" href="#完整的数据通路">完整的数据通路</a></h3>
<p><img src="../images/risc-v/riscv_full_data_path.png" alt="完整的数据通路" /></p>
<ul>
<li>译码阶段，会将指令的功能码和操作码发送给<strong>控制器</strong>，来产生相应的控制信号</li>
<li>立即数扩展信号：ImmSel</li>
<li>ALU 功能选择信号：ALUSel</li>
</ul>
<h3 id="控制器的设计"><a class="header" href="#控制器的设计">控制器的设计</a></h3>
<p><img src="../images/risc-v/riscv_cpu_controller_truth_table.png" alt="控制器的设计" /></p>
<h3 id="r-型指令数据通路"><a class="header" href="#r-型指令数据通路">R 型指令数据通路</a></h3>
<p><img src="../images/risc-v/riscv_R_instruction_data_path.png" alt="R型指令数据通路" /></p>
<ul>
<li><code>ALUSel</code> 会根据指令的 <code>funct3</code>来取不同的值</li>
</ul>
<h3 id="i-型指令数据通路"><a class="header" href="#i-型指令数据通路">I 型指令数据通路</a></h3>
<p><img src="../images/risc-v/riscv_I_instruction_data_path.png" alt="I型指令数据通路" /></p>
<h3 id="load-指令数据通路"><a class="header" href="#load-指令数据通路">Load 指令数据通路</a></h3>
<p><img src="../images/risc-v/riscv_load_instruction_data_path.png" alt="Load指令数据通路" /></p>
<h3 id="store-指令数据通路"><a class="header" href="#store-指令数据通路">Store 指令数据通路</a></h3>
<p><img src="../images/risc-v/riscv_store_instruction_data_path.png" alt="Store指令数据通路" /></p>
<ul>
<li>立即数来自<code>inst[31:25][11:7]</code>，这个和Load不同</li>
<li>Store指令没有<strong>写回</strong>阶段</li>
</ul>
<h3 id="b-型指令数据通路"><a class="header" href="#b-型指令数据通路">B 型指令数据通路</a></h3>
<p><img src="../images/risc-v/riscv_B_instruction_data_path.png" alt="B指令数据通路" /></p>
<ul>
<li>无<strong>访存</strong>和<strong>写回</strong>阶段</li>
</ul>
<h3 id="jalr-指令数据通路"><a class="header" href="#jalr-指令数据通路">jalr 指令数据通路</a></h3>
<p><img src="../images/risc-v/riscv_jalr_instruction_data_path.png" alt="jalr指令数据通路" /></p>
<ul>
<li>PC+4 的值会保存到<code>rd</code> 中</li>
</ul>
<h3 id="jal-指令数据通路"><a class="header" href="#jal-指令数据通路">jal 指令数据通路</a></h3>
<p><img src="../images/risc-v/riscv_jal_instruction_data_path.png" alt="jal指令数据通路" /></p>
<h2 id="cache"><a class="header" href="#cache">Cache</a></h2>
<p><img src="../images/risc-v/riscv_cache.png" alt="Cache" /></p>
<h3 id="cache-的结构"><a class="header" href="#cache-的结构">Cache 的结构</a></h3>
<p><img src="../images/risc-v/riscv_cache_structure.png" alt="Cache的结构" /></p>
<ul>
<li>块（block）：两级存储器层次结构中存储器信息交换的最小单元</li>
<li>命中（hit）：如果处理器需要的数据存放在高层存储器中的某个块中，称为一次命中</li>
<li>缺失（miss）：如果在高层存储器中没有找到所需的数据，这次数据请求称为一次缺失
<ul>
<li>缺失代价（miss penalty）：将相应的块从底层存储器替换到高层存储器的时间+将该信息块传送给处理器的时间</li>
</ul>
</li>
</ul>
<h3 id="cache-直接映射"><a class="header" href="#cache-直接映射">Cache 直接映射</a></h3>
<p>直接映射：一种 cache 结构，其中每个存储器地址仅仅对应到 cache 中的一个位置</p>
<p>映射方法：（块地址）mod（cache 中的块数）</p>
<p>标记：表中的一个字段，包含了地址信息，这些地址信息可以用来判断cache中的字是否就是所请求的字</p>
<p>有效位：表中的一个字段，用来标识一个块是否包含有一个有效数据</p>
<p><img src="../images/risc-v/riscv_cache_direct_mapping.png" alt="Cache直接映射" /></p>
<p><img src="../images/risc-v/riscv_cache_direct_mapping_example.png" alt="Cache直接映射示例" /></p>
<p>缺点：利用率低，命中率低</p>
<h3 id="cache-全相联映射"><a class="header" href="#cache-全相联映射">Cache 全相联映射</a></h3>
<p>全相联映射：一个块可以被放置在 cache 中的任何位置</p>
<p><img src="../images/risc-v/riscv_cache_full_association_mapping.png" alt="Cache全相联映射" /></p>
<p><img src="../images/risc-v/riscv_cache_full_association_mapping_example.png" alt="Cache全相联映射示例" /></p>
<p>缺点：硬件开销大（有多少cache块就配有相等数量的比较器）</p>
<h3 id="cache-组相联映射"><a class="header" href="#cache-组相联映射">Cache 组相联映射</a></h3>
<p>在组相联映射中，每个块可被放置的位置数是固定的，每个块有 n 个位置可放的 cache 被称为 n 路组相联 Cache</p>
<p><img src="../images/risc-v/riscv_set_associative_cache.png" alt="Cache组相联映射" /></p>
<p><img src="../images/risc-v/riscv_set_associative_cache_example.png" alt="Cache组相联映射示例" /></p>
<p>四路组相联 Cache：</p>
<ul>
<li>4 个比较器</li>
<li>1 个四选一多路选择器</li>
</ul>
<h3 id="cache-的设计"><a class="header" href="#cache-的设计">Cache 的设计</a></h3>
<ul>
<li>要考虑的维度
<ul>
<li>Cache 的容量</li>
<li>块大小</li>
<li>组织方式（Direct，Fully Associative，Set Associative）</li>
<li>替换算法（FIFO，LRU）</li>
<li>写策略（write-through, write-back）</li>
</ul>
</li>
</ul>
<h2 id="虚拟地址"><a class="header" href="#虚拟地址">虚拟地址</a></h2>
<p><img src="../images/risc-v/riscv_mmu.png" alt="虚拟存储器管理" /></p>
<h3 id="分段管理"><a class="header" href="#分段管理">分段管理</a></h3>
<p><img src="../images/risc-v/riscv_mmu_segment_manage.png" alt="分段管理" /></p>
<p>分段管理：将一个程序按照逻辑单元分成多个程序段，每一个段使用自己单独的虚拟地址空间。</p>
<ul>
<li>逻辑上相互独立</li>
<li>容易实现共享和保护</li>
<li>非常容易产生碎片（段长是不确定的）</li>
</ul>
<h3 id="分页管理"><a class="header" href="#分页管理">分页管理</a></h3>
<p><img src="../images/risc-v/riscv_mmu_page_manage.png" alt="分页管理" /></p>
<ul>
<li>如果页表项为4字节，那么整张页表会占据4MB大小的内存空间</li>
</ul>
<h3 id="两级分页管理"><a class="header" href="#两级分页管理">两级分页管理</a></h3>
<p><img src="../images/risc-v/riscv_mmu_two_level_page_manage.png" alt="两级分页管理" /></p>
<ul>
<li>4KB的页目录+4KB的页表</li>
</ul>
<h3 id="快速地址转换-tlb"><a class="header" href="#快速地址转换-tlb">快速地址转换 TLB</a></h3>
<p><img src="../images/risc-v/riscv_tlb.png" alt="块表" /></p>
<p>块表（Translation-Lookaside Buffer）：用于记录最近使用地址的映射信息的高速缓存，从而可以避免每次都要访问页表</p>
<h3 id="使用-tlb-进行地址转换"><a class="header" href="#使用-tlb-进行地址转换">使用 TLB 进行地址转换</a></h3>
<p><img src="../images/risc-v/riscv_tlb_location.png" alt="TLB的位置" /></p>
<p><img src="../images/risc-v/riscv_tlb_translation.png" alt="TLB实现地址转换的原理" /></p>
<p><img src="../images/risc-v/riscv_vma_pma_translation.png" alt="TLB虚实地址转换" /></p>
<h2 id="特权级别"><a class="header" href="#特权级别">特权级别</a></h2>
<p>一个 RISC-V 的硬件线程在任一时刻只能运行在某一个特权级上，这个特权级由 CSR 指定和配置。</p>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>级别</th><th>缩写</th><th>编码</th><th>说明</th></tr></thead><tbody>
<tr><td>用户应用程序特权级</td><td>0</td><td>U</td><td>00</td><td>运行应用程序，同样也适用于嵌入式系统</td></tr>
<tr><td>管理员特权级</td><td>1</td><td>S</td><td>01</td><td>主要用于支持现代操作系统，如Linux</td></tr>
<tr><td>虚拟机监视特权级</td><td>2</td><td>H</td><td>10</td><td>支持虚拟机监视器</td></tr>
<tr><td>机器特权级</td><td>3</td><td>M</td><td>11</td><td>对内存、I/O和一些必要的底层功能（启动和系统配置）有着完全的控制权</td></tr>
</tbody></table>
</div>
<h3 id="标准寄存器列表"><a class="header" href="#标准寄存器列表">标准寄存器列表</a></h3>
<h4 id="machine-mode"><a class="header" href="#machine-mode">Machine Mode</a></h4>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>地址</th><th>属性</th><th>备注</th></tr></thead><tbody>
<tr><td>mvendorid</td><td>0xF11</td><td>RO</td><td>商业供应商编号寄存器</td></tr>
<tr><td>marchid</td><td>0xF12</td><td>RO</td><td>架构编号寄存器</td></tr>
<tr><td>mimpid</td><td>0xF13</td><td>RO</td><td>硬件实现编号寄存器</td></tr>
<tr><td>mhartid</td><td>0xF14</td><td>RO</td><td>Hart编号寄存器 (Hart: Hardware Thread)</td></tr>
<tr><td>mstatus</td><td>0x300</td><td>RW</td><td>异常处理状态寄存器</td></tr>
<tr><td>misa</td><td>0x301</td><td>RO</td><td>指令集架构寄存器</td></tr>
<tr><td>mie</td><td>0x304</td><td>RW</td><td>局部中断屏蔽控制寄存器</td></tr>
<tr><td>mtvec</td><td>0x305</td><td>RW</td><td>异常入口基地址寄存器</td></tr>
<tr><td>mtvt</td><td>0x307</td><td>RW</td><td>中断向量表的基地址，至少为 <strong>64byte</strong> 对齐</td></tr>
<tr><td>mscratch</td><td>0x340</td><td>RW</td><td>暂存寄存器，比如进入异常处理模式后，将应用程序的用户的 sp 寄存器临时保存到这个寄存器中</td></tr>
<tr><td>mepc</td><td>0x341</td><td>RW</td><td>异常PC寄存器</td></tr>
<tr><td>mcause</td><td>0x342</td><td>RW</td><td>异常原因寄存器</td></tr>
<tr><td>mtval</td><td>0x343</td><td>RW</td><td>异常值寄存器，保存进入异常之前出错指令的编码值或者存储器访问的地址值</td></tr>
<tr><td>mip</td><td>0x344</td><td>RW</td><td>中断等待寄存器</td></tr>
<tr><td>mnxti</td><td>0x345</td><td>RW</td><td>读操作返回值是下一个中断的handler地址，写回操作会更新中断使能的状态</td></tr>
<tr><td>mintstatus</td><td>0x346</td><td>RO</td><td>用于保存当前中断 Level</td></tr>
<tr><td>mscratchcsw</td><td>0x348</td><td>RW</td><td>用于在特权模式变化时交换mscratch与目的寄存器的值</td></tr>
<tr><td>mscratchcswl</td><td>0x349</td><td>RW</td><td>用于在中断Level变化时交换mscratch与目的寄存器的值</td></tr>
<tr><td>mcycle</td><td>0xB00</td><td>RW</td><td>周期计数器的低32位</td></tr>
<tr><td>mcycleh</td><td>0xB80</td><td>RW</td><td>周期计数器的高32位</td></tr>
<tr><td>minstret</td><td>0xB02</td><td>RW</td><td>完成指令计数器的低32位，该寄存器用于衡量处理器的性能</td></tr>
<tr><td>minstrech</td><td>0xB82</td><td>RW</td><td>完成指令计数器的高32位</td></tr>
</tbody></table>
</div>
<h4 id="user-mode"><a class="header" href="#user-mode">User Mode</a></h4>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>地址</th><th>属性</th><th>备注</th></tr></thead><tbody>
<tr><td>cycle</td><td>0xC00</td><td>RO</td><td>mcycle寄存器的只读副本</td></tr>
<tr><td>time</td><td>0xC01</td><td>RO</td><td>mtime寄存器的只读副本</td></tr>
<tr><td>instret</td><td>0xC02</td><td>RO</td><td>minstret寄存器的只读副本</td></tr>
<tr><td>cycleh</td><td>0xC80</td><td>RO</td><td>mcycleh寄存器的只读副本</td></tr>
<tr><td>timeh</td><td>0xC81</td><td>RO</td><td>mtimeh寄存器的只读副本</td></tr>
<tr><td>instreth</td><td>0xC82</td><td>RO</td><td>minstreth寄存器的只读副本</td></tr>
</tbody></table>
</div>
<h2 id="risc-v-的中断"><a class="header" href="#risc-v-的中断">RISC-V 的中断</a></h2>
<p><img src="../images/risc-v/riscv_interrupt_enter.png" alt="进入中断" /></p>
<p><img src="../images/risc-v/riscv_interrupt_exit.png" alt="退出中断" /></p>
<h3 id="中断和异常相关的寄存器"><a class="header" href="#中断和异常相关的寄存器">中断和异常相关的寄存器</a></h3>
<p><img src="../images/risc-v/riscv_exception_csr_registers.png" alt="异常相关的CSR寄存器" /></p>
<p><img src="../images/risc-v/riscv_exception_csr_register_definitions.png" alt="异常相关的CSR寄存器具体定义" /></p>
<h3 id="mstatus"><a class="header" href="#mstatus">mstatus</a></h3>
<ul>
<li>MIE：为1表示中断的全局开关打开，中断能够被正常响应</li>
<li>FS：维护浮点单元的状态。上电默认为0,表示Off，为了能够正常使用浮点单元，软件需要使用 CSR 写指令将 FS 的值改写为非 0 值以打开浮点单元的功能。操作系统在进行上下文切换的时候，需要通过该值来判断是否需要对浮点单元进行上下文的保存</li>
<li>XS：维护用户自定义的扩展指令单元状态，类似与 FS</li>
</ul>
<h3 id="mtvec"><a class="header" href="#mtvec">mtvec</a></h3>
<p><img src="../images/risc-v/riscv_exception_mtvec_register.png" alt="mtvec寄存器" /></p>
<h3 id="异常代码"><a class="header" href="#异常代码">异常代码</a></h3>
<p><img src="../images/risc-v/riscv_machine_exception_codes.png" alt="异常代码" /></p>
<h3 id="中断返回"><a class="header" href="#中断返回">中断返回</a></h3>
<p><img src="../images/risc-v/riscv_exception_return.png" alt="中断返回" /></p>
<h3 id="中断屏蔽与中断等待"><a class="header" href="#中断屏蔽与中断等待">中断屏蔽与中断等待</a></h3>
<p><img src="../images/risc-v/riscv_interrupt_enable_pending.png" alt="中断屏蔽和等待相关额寄存器" /></p>
<h3 id="中断优先级"><a class="header" href="#中断优先级">中断优先级</a></h3>
<p><img src="../images/risc-v/riscv_interrupt_priority.png" alt="中断优先级" /></p>
<h3 id="单指令数据通路的中断响应与退出"><a class="header" href="#单指令数据通路的中断响应与退出">单指令数据通路的中断响应与退出</a></h3>
<p><img src="../images/risc-v/riscv_one_cycle_intruction_interrupt_enter.png" alt="中断响应" /></p>
<p><img src="../images/risc-v/riscv_one_cycle_intruction_interrupt_exit.png" alt="中断退出" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../about-me.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../cs/gcc-toolchains.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../about-me.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../cs/gcc-toolchains.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>

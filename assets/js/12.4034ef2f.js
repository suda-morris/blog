(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{448:function(t,s,a){t.exports=a.p+"assets/img/rust_version_edition.4d9eab76.png"},449:function(t,s,a){t.exports=a.p+"assets/img/rust_compile_process.f98a877e.png"},450:function(t,s,a){t.exports=a.p+"assets/img/rust_expression_classify.fe97eeaf.png"},451:function(t,s,a){t.exports=a.p+"assets/img/rust_memory_management_behind_expression.bfae4ded.png"},541:function(t,s,a){"use strict";a.r(s);var e=a(12),r=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"rust-基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-基础"}},[t._v("#")]),t._v(" Rust 基础")]),t._v(" "),s("h2",{attrs:{id:"语言基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#语言基础"}},[t._v("#")]),t._v(" 语言基础")]),t._v(" "),s("h3",{attrs:{id:"语言版本说明"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#语言版本说明"}},[t._v("#")]),t._v(" 语言版本说明")]),t._v(" "),s("p",[s("img",{attrs:{src:a(448),alt:"Rust语言语义化版本与版次"}})]),t._v(" "),s("div",{staticClass:"language-toml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-toml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token table class-name"}},[t._v("package")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token key property"}},[t._v("name")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"learning-rust"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token key property"}},[t._v("version")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0.1.0"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token key property"}},[t._v("authors")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"morris"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token key property"}},[t._v("edition")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"2018"')]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("h3",{attrs:{id:"编译过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译过程"}},[t._v("#")]),t._v(" 编译过程")]),t._v(" "),s("p",[s("img",{attrs:{src:a(449),alt:"Rust 编译过程"}})]),t._v(" "),s("ol",[s("li",[t._v("分词：把词法结构处理成词条流")]),t._v(" "),s("li",[t._v("词条流经过语法解析形成抽象语法树")]),t._v(" "),s("li",[t._v("抽象语法树简化成高级中间语言 (HIR)，编译器对 HIR 进行类型检查、方法查找等工作")]),t._v(" "),s("li",[t._v("HIR 进一步简化形成中级中间语言 (MIR)，编译器对 MIR 进行借用检查、优化等工作，在 MIR 中已经看不到 Rust 各版次的差异了")]),t._v(" "),s("li",[t._v("产生 LLVM 中间语言")]),t._v(" "),s("li",[t._v("LLVM 后端会对 LLVM 中间语言进行优化，最终生成机器代码")])]),t._v(" "),s("h3",{attrs:{id:"词法结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#词法结构"}},[t._v("#")]),t._v(" 词法结构")]),t._v(" "),s("h4",{attrs:{id:"关键字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关键字"}},[t._v("#")]),t._v(" 关键字")]),t._v(" "),s("ul",[s("li",[t._v("严格关键字 (Strict)，比如 "),s("code",[t._v("as")]),t._v(", "),s("code",[t._v("crate")]),t._v(", "),s("code",[t._v("fn")]),t._v(", "),s("code",[t._v("let")]),t._v(", "),s("code",[t._v("impl")]),t._v(", "),s("code",[t._v("mod")]),t._v(", "),s("code",[t._v("match")]),t._v(", "),s("code",[t._v("move")]),t._v(", "),s("code",[t._v("mut")]),t._v(", "),s("code",[t._v("pub")]),t._v(", "),s("code",[t._v("ref")]),t._v(", "),s("code",[t._v("async")]),t._v(", "),s("code",[t._v("await")]),t._v("等等")]),t._v(" "),s("li",[t._v("保留字 (Reserved)，比如 "),s("code",[t._v("do")]),t._v(", "),s("code",[t._v("final")]),t._v(", "),s("code",[t._v("override")]),t._v(", "),s("code",[t._v("priv")]),t._v(", "),s("code",[t._v("typeof")]),t._v(", "),s("code",[t._v("virtual")]),t._v(", "),s("code",[t._v("yield")]),t._v(", "),s("code",[t._v("abstract")]),t._v(" 等等")]),t._v(" "),s("li",[t._v("弱关键字 (Weak)，比如 "),s("code",[t._v("union")]),t._v(" 只在声明联合体的时候才被当作关键字")])]),t._v(" "),s("h4",{attrs:{id:"标识符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标识符"}},[t._v("#")]),t._v(" 标识符")]),t._v(" "),s("p",[t._v("变量名、函数名、类型名、参数名都属于标识符，只能以字母或者下划线开头 （未来可能会支持非 ascii 字符）。")]),t._v(" "),s("h4",{attrs:{id:"注释"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注释"}},[t._v("#")]),t._v(" 注释")]),t._v(" "),s("ul",[s("li",[t._v("模块级文档注释: "),s("code",[t._v("//!")])]),t._v(" "),s("li",[t._v("语言项（方法、函数）级文档注释: "),s("code",[t._v("///")])])]),t._v(" "),s("h4",{attrs:{id:"空白"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#空白"}},[t._v("#")]),t._v(" 空白")]),t._v(" "),s("p",[t._v("Rust 中的空白字符只用作分隔标记，没有语意")]),t._v(" "),s("h4",{attrs:{id:"词条"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#词条"}},[t._v("#")]),t._v(" 词条")]),t._v(" "),s("p",[t._v("语言项，块，语句，表达式，模式，关键字，标识符，字面量，生命周期，可见性，标点符号，分隔符，词条树，属性")]),t._v(" "),s("h4",{attrs:{id:"路径"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#路径"}},[t._v("#")]),t._v(" 路径")]),t._v(" "),s("p",[t._v("路径分隔符"),s("code",[t._v("::")])]),t._v(" "),s("p",[t._v("范型函数 "),s("em",[t._v("turbofish")]),t._v(" 操作符"),s("code",[t._v("::<>")]),t._v("，给范型函数指定具体的数据类型")]),t._v(" "),s("h3",{attrs:{id:"表达式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#表达式"}},[t._v("#")]),t._v(" 表达式")]),t._v(" "),s("h4",{attrs:{id:"rust-语法的-骨架"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-语法的-骨架"}},[t._v("#")]),t._v(" Rust 语法的“骨架”")]),t._v(" "),s("ul",[s("li",[t._v("属性，类似于 "),s("code",[t._v("#![...]")])]),t._v(" "),s("li",[t._v("分号 "),s("code",[t._v(";")]),t._v("，行分隔符")]),t._v(" "),s("li",[t._v("花括号"),s("code",[t._v("{...}")]),t._v("，块分隔符")])]),t._v(" "),s("h4",{attrs:{id:"分号表达式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分号表达式"}},[t._v("#")]),t._v(" 分号表达式")]),t._v(" "),s("ul",[s("li",[t._v("分号表达式返回值永远是自身的单元类型："),s("code",[t._v("()")])]),t._v(" "),s("li",[t._v("分号表达式只有在块表达式最后一行才会进行求值，其他时候只作为“连接符”存在")])]),t._v(" "),s("h4",{attrs:{id:"块表达式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#块表达式"}},[t._v("#")]),t._v(" 块表达式")]),t._v(" "),s("p",[t._v("块表达式只对其最后一行表达式进行求值")]),t._v(" "),s("h3",{attrs:{id:"编译期计算"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译期计算"}},[t._v("#")]),t._v(" 编译期计算")]),t._v(" "),s("ol",[s("li",[t._v("过程宏 + Build 脚本 (build.rs)")]),t._v(" "),s("li",[t._v("类似于 Cpp 中 constexpr 的 CTFE 功能")])]),t._v(" "),s("h4",{attrs:{id:"常量上下文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常量上下文"}},[t._v("#")]),t._v(" 常量上下文")]),t._v(" "),s("p",[s("strong",[t._v("常量上下文是编译器唯一进行编译期求值的地方")])]),t._v(" "),s("ol",[s("li",[t._v("常量值初始化位置")]),t._v(" "),s("li",[t._v("静态数组的长度表达式")]),t._v(" "),s("li",[t._v("重复的长度表达式")]),t._v(" "),s("li",[t._v("静态变量、枚举判别式的初始化位置")])]),t._v(" "),s("p",[s("strong",[t._v("常量传播和编译期计算不同")])]),t._v(" "),s("ol",[s("li",[t._v("常量传播是编译器的一种优化")]),t._v(" "),s("li",[t._v("常量传播并不能改变程序的任何行为，并且对开发者是隐藏的")]),t._v(" "),s("li",[t._v("编译期计算则是编译时执行的代码，必须知道其结果才能继续执行")])]),t._v(" "),s("div",{staticClass:"language-rust line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("X")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("u32")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// CTFE (compile time function evaluation)")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" uew "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 不是 CTFE，因为它不在常量上下文，但是可能会被编译器做常量传播优化")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[s("strong",[t._v("常量长下文可接受的常量表达式")])]),t._v(" "),s("ol",[s("li",[t._v("const fn 函数")]),t._v(" "),s("li",[t._v("元组结构体")]),t._v(" "),s("li",[t._v("元组的值")])]),t._v(" "),s("div",{staticClass:"language-rust line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// String 是一个在堆上分配内存的智能指针类型，无法在编译期进行计算")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("hello")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Hello"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("to_string")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Error")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("S")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hello")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("h4",{attrs:{id:"常量安全子类型系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常量安全子类型系统"}},[t._v("#")]),t._v(" 常量安全子类型系统")]),t._v(" "),s("ol",[s("li",[t._v("普通的 fn 关键字定义的函数，是 Safe Rust 主类型系统保证安全。")]),t._v(" "),s("li",[t._v("const fn 定义的函数，是 Safe Rust 主类型系统下有一个专门用于常量计算的子类型系统来保证常量安全")])]),t._v(" "),s("h4",{attrs:{id:"编译期计算是如何实现的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译期计算是如何实现的"}},[t._v("#")]),t._v(" 编译期计算是如何实现的")]),t._v(" "),s("p",[t._v("Rust 编译器内置 MIR （中级中间语言）的解释器——Miri，它可以执行 MIR 代码，"),s("strong",[t._v("编译期计算就是通过 Miri 执行 MIR 中 const 上下文相关的 const 代码")]),t._v("。")]),t._v(" "),s("h4",{attrs:{id:"为什么需要常量泛型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要常量泛型"}},[t._v("#")]),t._v(" 为什么需要常量泛型")]),t._v(" "),s("p",[t._v("在Rust中，"),s("code",[t._v("let arr: [u32; 3] = [1, 2, 3];")]),t._v(" 和 "),s("code",[t._v("let arr: [u32; 5] = [1, 2, 3, 4, 5];")]),t._v(" 属于不同类型，所以无法使用一个泛型来统一定义不同长度的数组。")]),t._v(" "),s("h4",{attrs:{id:"表达式的分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#表达式的分类"}},[t._v("#")]),t._v(" 表达式的分类")]),t._v(" "),s("p",[s("img",{attrs:{src:a(450),alt:"Rust 表达式的分类"}})]),t._v(" "),s("p",[s("img",{attrs:{src:a(451),alt:"Rust 表达式背后的内存管理"}})]),t._v(" "),s("h5",{attrs:{id:"位置表达式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#位置表达式"}},[t._v("#")]),t._v(" 位置表达式")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("位置表达式")]),t._v(" "),s("th",[t._v("举例")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("静态变量初始化")]),t._v(" "),s("td",[t._v("static mut LEVELS: u32 = 0;")])]),t._v(" "),s("tr",[s("td",[t._v("解引用表达式")]),t._v(" "),s("td",[t._v("*expr")])]),t._v(" "),s("tr",[s("td",[t._v("数组索引表达式")]),t._v(" "),s("td",[t._v("expr[expr]")])]),t._v(" "),s("tr",[s("td",[t._v("字段表达式")]),t._v(" "),s("td",[t._v("expr.field")])])])]),t._v(" "),s("h5",{attrs:{id:"rust-所有权语义在表达式上的体现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rust-所有权语义在表达式上的体现"}},[t._v("#")]),t._v(" Rust 所有权语义在表达式上的体现")]),t._v(" "),s("div",{staticClass:"language-rust line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" stack_a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// stack_a 是位置表达式，值42实现了 Copy,所以保存在栈内存")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" stack_b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" stack_a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// stack_a 出现在了值上下文中，发生了 Copy")]),t._v("\nstack_a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 合法")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" heap_a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("to_string")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// heap_a 是位置表达式，字符串未实现 Copy,所以保存在堆内存")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" heap_b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" heap_a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// heap_a 出现在值上下文，发生了 Move")]),t._v("\nheap_a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 错误")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])])])}),[],!1,null,null,null);s.default=r.exports}}]);